<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《计算机网络（英文版·第5版）》 The Network Layer | Jckling's Blog</title><meta name="keywords" content="计算机网络,Computer Networks"><meta name="author" content="Jckling"><meta name="copyright" content="Jckling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《计算机网络》第五版（英文） 网络层">
<meta property="og:type" content="article">
<meta property="og:title" content="《计算机网络（英文版·第5版）》 The Network Layer">
<meta property="og:url" content="https://jckling.github.io/2018/06/15/Notes/Computer%20Networks/The-Network-Layer/index.html">
<meta property="og:site_name" content="Jckling&#39;s Blog">
<meta property="og:description" content="《计算机网络》第五版（英文） 网络层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg">
<meta property="article:published_time" content="2018-06-15T00:19:00.000Z">
<meta property="article:modified_time" content="2021-11-23T14:04:58.773Z">
<meta property="article:author" content="Jckling">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="Computer Networks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg"><link rel="shortcut icon" href="/img/jckling/favicon.ico"><link rel="canonical" href="https://jckling.github.io/2018/06/15/Notes/Computer%20Networks/The-Network-Layer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google_site_verification" content="pZZt69mo0ndoxIJ1vjEe830lXbvD26aiVAZ-k0FWM5k"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?20b7797c0b5f4e821c1449cd4c6c98c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-164555720-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-164555720-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《计算机网络（英文版·第5版）》 The Network Layer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-23 22:04:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Jckling's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/jckling/avatar.jpg" onerror="onerror=null;src='/img/jckling/avatar_404.png'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jckling's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《计算机网络（英文版·第5版）》 The Network Layer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2018-06-15T00:19:00.000Z" title="undefined 2018-06-15 08:19:00">2018-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Notes/">Notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《计算机网络（英文版·第5版）》 The Network Layer"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2018/06/15/Notes/Computer%20Networks/The-Network-Layer/#post-comment"><span class="waline-comment-count" id="/2018/06/15/Notes/Computer%20Networks/The-Network-Layer/"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>网络层关注的是如何将源端数据包一路送到接收方</p>
<p>为了将数据包送到接收方，可能沿途要经过许多跳（hop）中间路由器</p>
<p>数据链路层只是将帧从线路一边传送到另一边</p>
<p>网络层是处理端到端数据传输的最底层</p>
<p>为了实现这个目标，网络层必须知道网络拓扑结构（即所有路由器和链路的集合），并从中选择适当的路径。同时，网络层还必修仔细选择路由器。避免某些通信线路和路由器负载过重，而其他线路和路由器空闲。最后，当源端和接收方位于不同网络时，网络层还需要再解决些问题</p>
<p>OSI 参考模型</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-1.png" width="65%">


<p>通信子网</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-2.png" width="65%">


<h1 id="网络层设计问题"><a href="#网络层设计问题" class="headerlink" title="网络层设计问题"></a>网络层设计问题</h1><h2 id="存储-转发数据包交换"><a href="#存储-转发数据包交换" class="headerlink" title="存储-转发数据包交换"></a>存储-转发数据包交换</h2><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-3.png" width="65%">

<p>机制</p>
<ul>
<li>如果一台主机要发送一个数据包，它就将数据包传输给最近的路由器，路由器可能在它自己的 LAN 上，也可能在一条通向 ISP 的点到点链路上</li>
<li>在该数据包到达路由器，并且路由器的链路层完成了对它校验和的验证之后，它先被存储在路由器上</li>
<li>然后沿着路径被转发到下一个路由器，直至到达目标主机</li>
</ul>
<p>注意</p>
<ul>
<li>网络层负责将数据包从源端路由到目的地</li>
<li>路由算法是决定数据包接下来去哪里的软件的一部分（例如，哪个输出线路，广播信道上的哪个节点）</li>
<li>对于无线网络，路由决策是针对每个数据报进行的。对于面向连接的网络，路由决策在电路建立时设置一次</li>
</ul>
<h2 id="提供给传输层的服务"><a href="#提供给传输层的服务" class="headerlink" title="提供给传输层的服务"></a>提供给传输层的服务</h2><p>网络层通过网络层/传输层接口向传输层提供服务</p>
<p>网络层服务的目标</p>
<ol>
<li>向上提供的服务应该独立于路由器技术</li>
<li>应该向传输层屏蔽路由器的数量、类型和拓扑关系</li>
<li>传输层可用的网络地址应该有一个统一编址方案，甚至可以跨越 LAN 和 WAN</li>
</ol>
<p>问题</p>
<ul>
<li>网络层应该提供面向连接的服务还是无连接的服务</li>
<li>错误 / 流量控制是网络层还是传输层的事？</li>
</ul>
<p>Internet 社团</p>
<ul>
<li>路由器的任务仅仅是传送数据包</li>
<li>网络（子网）从本质上讲总是不可靠的</li>
<li>主机需要自己来完成错误控制（错误检测和纠正）和流量控制任务</li>
<li>网络层再做一遍不会带来更大的好处<ul>
<li>端-端论点，每个数据包必须携带完整的目标地址，因为每个数据包的运送独立于它前面的那些数据包（如果有的话）</li>
</ul>
</li>
<li>TCP/IP 互联网在实现时是无连接的，但为用户提供连接</li>
</ul>
<p>电话公司</p>
<ul>
<li>面向连接的方法是正确的</li>
<li>用户不需要主机中的错误/流量控制协议</li>
<li>用户需要可靠、无故障的服务</li>
<li>服务质量是主要因素</li>
</ul>
<h2 id="无连接服务的实现"><a href="#无连接服务的实现" class="headerlink" title="无连接服务的实现"></a>无连接服务的实现</h2><p>如果提供的是无连接的服务，那么所有的数据包都被独立地注入到网络中，并且每个数据包独立路由，不需要提前建立任何设置</p>
<ul>
<li>数据包通常称为数据报（datagram），对应的网络称为数据报网络</li>
</ul>
<p>如果使用了面向连接的服务，那么在发送数据包之前，必须首先建立起一条从源路由器到目标路由器之间的路径</p>
<ul>
<li>这个连接称为虚电路（VC, virtuall circuit），对应的网络称为虚电路网络</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-4.png" width="65%">


<p>每一台路由器都有一个内部表，指明了针对每一个可能的目标地址应该将数据包发送到哪里<br>每个表项由两部分组成：目标地址、通往目标地址所用的出境线路（直连线路）</p>
<p>管理这些路由表并做出路由选择的算法称为路由算法（routing algorithm）</p>
<p>IP 协议（Internet Protocol）是整个Internet的基础，它是无连接网络服务的重要范例</p>
<ul>
<li>每个数据包携带一个目标 IP 地址，路由器使用该地址来单独转发每一个数据包</li>
<li>IPv4 数据包的地址是 32 位，IPv6 数据包的地址是 128 位</li>
</ul>
<h2 id="面向连接服务的实现"><a href="#面向连接服务的实现" class="headerlink" title="面向连接服务的实现"></a>面向连接服务的实现</h2><ul>
<li>当建立一个连接时，从源机器到目标机器之间的一条路径就被当作这个连接的一部分确定了下来，并且保存在这些中间路由器的表中</li>
<li>所有需要在这个连接上通过的流量，都使用这条路径</li>
<li>当连接被释放之后，虚电路也随之消失</li>
<li>在面向连接的服务中，每个数据包包含一个标识符，指明了它属于哪一条虚电路</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-5.png" width="65%">

<ul>
<li>连接标识符 1 的数据包来自于 H1，将被发送到路由器 C，并赋予连接标识符 1</li>
<li>H3 也希望与 H2 建立连接，新增第二行，因为 A 可以区分数据包来自 H1 还是 H3 但 C 无法区分，基于这个原因，A 给第二个连接的出境流量分配一个不同的连接标识符</li>
</ul>
<h3 id="标签交换（label-switching）"><a href="#标签交换（label-switching）" class="headerlink" title="标签交换（label switching）"></a>标签交换（label switching）</h3><p>虚电路</p>
<ul>
<li>请求连接，在每个数据可以传输前请求</li>
<li>每个数据包携带一个 VC 标识符（不是目标主机ID）</li>
<li>在源端-目标地址路径上的每个路由器为每个经过的连接维护状态</li>
<li>传输层连接只涉及到两个端系统</li>
<li>可以为虚电路分配链路（link）、路由器资源（带宽、缓冲）</li>
</ul>
<p>一种面向连接的网络服务例子是多协议标签交换（MPLS）</p>
<ul>
<li>主要被用在 Internet 的 ISP 网络，IP 数据包被一个有 20 位连接标识或标签的 MPLS 头包裹着</li>
<li>MPLS 往往对客户端是隐藏的，客户看不到这些标签，ISP 用它来为超大流量建立长期的连接</li>
<li>但是，当服务质量变得很重要而且还需要协助其他 ISP 完成流量管理任务时，ISP 的作用越来越突出</li>
</ul>
<h2 id="虚电路与数据报网络的比较"><a href="#虚电路与数据报网络的比较" class="headerlink" title="虚电路与数据报网络的比较"></a>虚电路与数据报网络的比较</h2><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-6.png" width="65%">

<p>在网络内部，数据报和虚电路网络之间存在着几个方面的权衡</p>
<ul>
<li>建立时间和地址解析时间<ul>
<li>使用虚电路需要一个建立阶段，这个阶段计划费时间也消耗资源</li>
<li>在数据报网络中，不需要建立电路，但路由器需要执行一个更为复杂的查找过程以便找到目标表项</li>
</ul>
</li>
<li>开销和带宽<ul>
<li>如果数据包相当短，在每个数据包中都包括完整的目标地址可能意味着大量的协议开销，因而造成带宽资源的浪费</li>
</ul>
</li>
<li>路由器内存所要求的表空间的数量<ul>
<li>数据报网络中，针对每一个可能的目标地址都要求有一个表项</li>
<li>虚电路网络中，只要为每一条虚电路提供一个表项即可</li>
</ul>
</li>
</ul>
<p>其他方面</p>
<ul>
<li>从保证服务质量以及避免网络拥塞的角度来看，虚电路有一定的优势，因为在建立连接时，资源可以提前预留（比如缓冲区控件、带宽和 CPU 周期）</li>
<li>路由器崩溃，虚电路网络中，经过该路由器的连接都不得不中断，而在数据报网络中，丢失的数据包可以立即重传</li>
<li>数据报还允许路由器平衡网络流量，因为一个长序列数据包的传输路径可以在序列传输的中途改变</li>
</ul>
<h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><p><strong>路由和转发</strong></p>
<p>路由即对使用哪一条路径做出决策，而转发则是当一个数据包到达时应该采取什么动作</p>
<ul>
<li>可以把路由器想象成内部有两个进程<ul>
<li>一个进程在每个数据包到达的时候对其进行处理，它在路由表中查找该数据包所对应的出境线路，这个进程即为转发（forwarding）</li>
<li>另一个进程负责生成和更新路由表，<em>这正是路由算法发挥作用的地方</em></li>
</ul>
</li>
</ul>
<p><strong>路由算法</strong></p>
<p>路由涉及以下问题：</p>
<ul>
<li>在将数据包转发给路由器 K 时，路由器应该使用哪条线路</li>
<li>目标：确定通过网络从源到目的地的“好”路径（路由器序列）</li>
</ul>
<p>路由算法（routing algorithm）是网络层软件的一部分，它负责确定一个入境数据包应该被发送到哪一条输出线路上</p>
<p>路由算法的特性</p>
<ul>
<li>正确性（correctness）、简单性（simplicity）</li>
<li>鲁棒性（robustness）<ul>
<li>一旦一个重要网络投入运行，它有可能需要连续运行数年而不能出现波及系统范围的失败，部分组件可能失败（链路、路由器）</li>
<li>路由算法应该能够处理各种各样的硬件和软件发生故障，还有拓扑结构和流量方面的各种变化，而且不能要求所有主机都停止所有的工作</li>
</ul>
</li>
<li>稳定性（stability）<ul>
<li>一个稳定的路由算法能达到平衡，并且保持平衡状态。因此它应该迅速收敛，在路由器算法到达平衡之前，通信可能无法正常运行</li>
</ul>
</li>
<li>公平性（fairness）、有效性（efficiency）<ul>
<li>时常是矛盾的</li>
</ul>
</li>
</ul>
<p><strong>路由算法分类</strong></p>
<p>非自适应算法（nonadaptive algorithm）</p>
<ul>
<li>不会根据当前测量或者估计的流量和拓扑结构，来调整路由决策</li>
<li>使用的路由选择是预先在离线情况下计算好，并在网络启动时被下载到路由器中的。有时也称为静态路由（static routing）</li>
<li>无法响应故障，所以静态路由对于路由选择已经清楚的场合非常有用</li>
</ul>
<p>自适应算法（adaptive algorithm）</p>
<ul>
<li>使用动态信息（当前流量、拓补结构、延迟等）来选择路由</li>
<li>改变路由决策以便反映出拓扑结构的变化，通常也会反映出流量的变化情况</li>
<li>在多个方面有所不同<ul>
<li>获取信息的来源（本地，相邻路由器，所有路由器）</li>
<li>改变路径的时间（每当拓扑发生变化时，每隔△t秒随负载变化）</li>
<li>路由优化度量（距离，跳数，估计的传输时间）</li>
</ul>
</li>
</ul>
<h2 id="优化原则（optimality-principle）"><a href="#优化原则（optimality-principle）" class="headerlink" title="优化原则（optimality principle）"></a>优化原则（optimality principle）</h2><p>如果路由器 J 在从路由器 I 到路由器 K 的最优路径上，那么从 J 到 K 的最优路径也必定遵循同样的路由</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-7.png" width="65%">


<h3 id="汇集树"><a href="#汇集树" class="headerlink" title="汇集树"></a>汇集树</h3><p>作为优化原则的一个直接结果，从所有的源到一个制定目标的最优路径的集合构成了一棵以目标节点为根的汇集树（sink tree）</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-8.png" width="65%">

<ul>
<li>图中的距离度量是跳数</li>
<li>所有路由算法的目标是为所有路由器找到这样的汇集树，并根据汇集树来转发数据包</li>
</ul>
<p>汇集树不一定是唯一的：有可能存在具有相同路径长度的其他汇集树</p>
<h3 id="图抽象"><a href="#图抽象" class="headerlink" title="图抽象"></a>图抽象</h3><p>由算法的图抽象：</p>
<ul>
<li>图中的每个节点代表一个路由器</li>
<li>图的每条边是代表一条通信线路或物理链路<ul>
<li>链路成本：延迟，成本，拥塞等级</li>
</ul>
</li>
<li>选择给定路由器对之间的路由：找到“好”路径<ul>
<li>通常意味着最小成本路径</li>
<li>其他可能的定义</li>
</ul>
</li>
</ul>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>常用，因为简单易懂</p>
<p>最短路径度量（路径长度）</p>
<ul>
<li>跳数（hop）</li>
<li>物理距离</li>
<li>平均排队和传输延迟</li>
<li>带宽</li>
<li>平均流量</li>
<li>通信成本</li>
</ul>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>这种算法能找出网络中一个源节点到全部目标节点的最短路径</p>
<p>迪杰斯特拉算法（或变体，SPF 最短路径优先算法）的基本思路是</p>
<ul>
<li>选择源，并将列表中连接到源的节点考虑进来</li>
<li>选择距离最近的节点</li>
</ul>
<h3 id="加权无向图上的算法"><a href="#加权无向图上的算法" class="headerlink" title="加权无向图上的算法"></a>加权无向图上的算法</h3><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-9.png" width="65%">


<h2 id="泛洪（flooding）"><a href="#泛洪（flooding）" class="headerlink" title="泛洪（flooding）"></a>泛洪（flooding）</h2><p>泛洪是孤立路由的一种形式，不选择特定的路线。将每一个入境数据包发送到除了该数据包到达的那条线路以外的每条出境线路</p>
<p>为了防止数据包永久循环，每个路由器递减包头中包含的跳计数器。只要跳计数器递减到零，路由器就丢弃该数据包</p>
<p>减少循环</p>
<ul>
<li>让每个源路由器在接收到来自数据的数据包时设置一个序号</li>
<li>每个路由器为每个源路由器准备一张表，记录已经观察到的来自源路由器的序号</li>
<li>如果入境数据包在这张表中，它就不能再被泛洪到其他路由器<ul>
<li>为防止表无限膨胀，每个表使用一个计数器 k 作为参数，表示直到 k 的所有序号都已经观察到了</li>
</ul>
</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>确保数据包能被传送到网络中的每个节点</p>
<ul>
<li>有效的广播手段，一些无线路由算法利用了这个特性</li>
</ul>
<p>泛洪途径的鲁棒性非常好</p>
<ul>
<li>即使路由器被炸成碎片（战争地区），泛洪也能找到一条路径（如果存在），使得数据包到达目的地</li>
</ul>
<p>泛洪需要的安装很少，路由器仅仅需要知道自己的邻居即可</p>
<ul>
<li>泛洪可以作为其他路由算法的基本构建</li>
<li>泛洪还可用作其它路由算法进行比较的性能度量</li>
</ul>
<p>发送路由更新，因为更新不能依赖路由器表的正确性</p>
<p>理论上选择所有的路径，选出最短的那条路径</p>
<h2 id="距离矢量路由"><a href="#距离矢量路由" class="headerlink" title="距离矢量路由"></a>距离矢量路由</h2><p>也被称为分布式 Bellman-Ford 路由算法，最初 APPANET 使用的路由算法，也曾被用于 Internet，相应的协议名为 RIP 协议</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>每个路由器维护一张表（即一个矢量），表中列出了当前已知的到每个目标的最佳距离，以及所使用的链路。这些表通过领居之间相互交换信息而不断被更新，最终每个路由器都了解到达每个目的地的最佳链路</li>
<li>每个路由器知道自己到邻居的距离（成本）<ul>
<li>跳数：1 跳</li>
<li>传播延迟：通过发送回应请求（ECHO request），返回加上时间戳的数据包</li>
</ul>
</li>
<li>路由器周期性地和邻居交换路由表</li>
<li>接收到路由表更新后，对表中的每个目的地<ul>
<li>用邻居表的值加上本地到邻居表的成本和本地的表比较</li>
<li>如果通过邻居的路径成本更低，那么路由器更新本地表以将数据包转发给邻居</li>
</ul>
</li>
</ul>
<h3 id="D-V-路由例子"><a href="#D-V-路由例子" class="headerlink" title="D-V 路由例子"></a>D-V 路由例子</h3><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-10.png" width="65%">


<h3 id="无穷计数问题"><a href="#无穷计数问题" class="headerlink" title="无穷计数问题"></a>无穷计数问题</h3><p>整个网络最佳路径的寻找过程称为收敛（convergence）</p>
<p>距离矢量路由总是能够收敛到正确的答案，但速度可能非常慢</p>
<ul>
<li>好消息传得快，坏消息传得慢（无穷计数问题）</li>
</ul>
<p>无穷计数问题（count-to-infinity）</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-11.png" width="65%">

<ul>
<li>（a）假定 A 最初处于停机状态，所有其他路由器都知道这一点；当 A 启动时，其他的路由器通过矢量交换知道了这一点<ul>
<li>如果一个网络中最长路径是 N 跳，那么经过 N 次交换后，每个路由器都将知道新恢复的链路和路由器</li>
</ul>
</li>
<li>（b）假定所有线路和路由器最初都是正常工作的；突然 A 停机了，或者 A 和 B 之间的链路断了</li>
</ul>
<p>没有一个路由器具有一个比它所有邻居的最小值还大于 1 的值，逐渐所有的路由器都会趋向无穷大，但是所需交换的次数依赖于代表无穷大的数值。由于这样的原因，明智的做法是将无穷大设置为最长的路径加 1</p>
<p>问题的核心</p>
<ul>
<li>当 X 告诉 Y 它有一条通往某个地方的路径，Y 无从知道自己是否已在这条路径上</li>
</ul>
<p>尝试解决</p>
<ul>
<li>带有染毒逆向的水平分裂法（Split horizon with poisoned reverse）RFC 1058</li>
</ul>
<h2 id="链路状态路由"><a href="#链路状态路由" class="headerlink" title="链路状态路由"></a>链路状态路由</h2><p>1979 年以前 APPANET 一直使用距离矢量路由算法，而在此之后则改为使用链路状态路由算法</p>
<p>距离矢量算法的问题</p>
<ul>
<li>当网络拓扑结构发生变化后距离矢量路由算法需要太长时间才能收敛到稳定状态（无穷计数问题）</li>
<li>高优先级路由更新数据包很大，对流量造成不利影响</li>
<li>网络适应拥塞的速度太慢，对小变化的反应太快</li>
<li>平均队列长度用于估计延迟<ul>
<li>仅当所有线路具有相同的容量（capacity）和传输延迟（propagation delay）时才有效</li>
<li>不考虑数据包大小的不同</li>
</ul>
</li>
</ul>
<p>每个路由器维护一个数据库，描述每个路由器之间的的拓扑结构和链路延迟。也就是说，每个路由器都会跟踪链接和节点的完整图形</p>
<ul>
<li>避免由于所有路由器获取其他路由器的信息而导致无穷计数问题<br>每个路由器都使用 SPF 算法根据数据库中的当前值计算最短路径</li>
<li>因为每个路由器都使用相同的信息进行计算，所以可以做出更好的路由决策</li>
</ul>
<p>每一个路由器必须完成以下事情，算法才能正常工作</p>
<ol>
<li>发现它的邻居节点，并了解其网络地址</li>
<li>设置到每个邻居节点的距离或者成本度量值</li>
<li>构造一个包含所有刚刚获知的链路信息包</li>
<li>将这个包发送给所有其他的路由器，并接收来自其他所有路由器的信息包</li>
<li>计算出到每个其他路由器的最短路径</li>
</ol>
<p>实际上，算法将完整的拓扑结构分发给了每一个路由器。然后每个路由器运行 Dijkstra 算法就可以找出从本地到每一个其他路由器的最短路径</p>
<h3 id="发现邻居"><a href="#发现邻居" class="headerlink" title="发现邻居"></a>发现邻居</h3><p>当一个路由器启动时，它的第一个任务是找出哪些路由器时它的邻居</p>
<ul>
<li>为了实现这个目标，它只需在每一条点到点线路上发送一个特殊的 HELLO 数据包</li>
</ul>
<p>线路另一端的路由器应该返回一个应答说明自己是谁，这些名字必须是全局唯一的</p>
<p>当两个或多个路由器通过一个广播链路（比如一个交换机、环或经典以太网）</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-12.png" width="65%">

<ul>
<li>（a）一个广播 LAN 直接与三个路由器 A、C、F 连接。每个路由器都连接到一个或多个其他的路由器上<ul>
<li>广播 LAN 为连接到其上的任何一对路由器提供了彼此的连通性</li>
<li>然而，把 LAN 建模成许多个点到点链路会增大拓扑结构，从而导致浪费消息</li>
</ul>
</li>
<li>（b）引入节点 N 和 A、C、F 连接，LAN 上的一个指定路由器（designated router）被选中替代 N 运行路由协议</li>
</ul>
<h3 id="设置链路成本"><a href="#设置链路成本" class="headerlink" title="设置链路成本"></a>设置链路成本</h3><p>到邻居的成本可自动设置或由网络运营商配置的度量</p>
<ul>
<li>一种常用的选择是使成本与链路带宽成反比</li>
<li>1Gbps-1，100Mbps-10</li>
</ul>
<p>如果网络在地理上分散，链路的延迟可以作为成本的组成部分，这样才能更好地选择较短链路上的路径</p>
<ul>
<li>确定这种延迟的最直接方法是通过线路给另一边发送一个特殊的 ECHO 数据包，要求对方立即发回</li>
<li>通过测量往返时间再除以 2，发送路由器可以得到一个合理的延迟估算值</li>
</ul>
<h3 id="构造链路状态包"><a href="#构造链路状态包" class="headerlink" title="构造链路状态包"></a>构造链路状态包</h3><p>数据包的内容：发送方的标识符（ID）、序号（Seq）、年龄（Age）、邻居列表</p>
<ul>
<li>对每个邻居，同时给出到这个邻居的延迟</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-13.png" width="65%">

<p>构造链路状态包很容易，难确定的是什么时候构造</p>
<ul>
<li>周期性地创建数据包</li>
<li>每当发生重要事情时才创建数据包<ul>
<li>比如当一条线路断掉或一个邻居节点停机</li>
</ul>
</li>
</ul>
<h3 id="分发链路状态包"><a href="#分发链路状态包" class="headerlink" title="分发链路状态包"></a>分发链路状态包</h3><p>基本思路是使用泛洪将链路状态数据包分发给所有路由器</p>
<ul>
<li>为了控制泛洪规模，每个数据包都包含一个序号，序号随着每一个新数据包发送而逐一递增</li>
<li>路由器记录下它所看到的所有（源路由器、序号）对。当一个新的链路状态数据包到达时，路由器检查这个新来的数据包是否已经出现在列表中<ul>
<li>如果是新数据包，则把它转发到除入境线路之外的所有其它线路上</li>
<li>如果是重复数据包，则把它丢弃</li>
<li>如果数据包的序号小于当前所有看到过的来自该源路由器的最大序号，则它将被当作过时数据包而拒绝接受，因为路由器已经有了更新的数据</li>
</ul>
</li>
</ul>
<h4 id="年龄（age）字段"><a href="#年龄（age）字段" class="headerlink" title="年龄（age）字段"></a>年龄（age）字段</h4><p>问题</p>
<ul>
<li>如果序号绕回，可能会产生混淆</li>
<li>如果一个路由器崩溃了，它将丢失所有的序号记录表</li>
<li>如果一个序号被破坏</li>
</ul>
<p>解决方案：</p>
<ul>
<li>在每个数据包的序号之后包含一个年龄（age）字段，并且每秒钟将年龄减 1 。当年龄字段的值被减到 0 时（路由器链路状态数据库），来自路由器的该信息将被丢弃</li>
<li>在初始泛洪过程中，每个路由器也要递减 age 字段，这样可以确保没有数据包丢失，也不会无限生存下去（如果一个数据包的 age 为 0，则被丢弃）</li>
</ul>
<p>改进</p>
<ul>
<li>当一个链路状态数据包被泛洪到一个路由器时，它并没有立即被排入队列等待传输。相反，它首先被放到一个保留区中等待一段时间，如果在这个数据包被转发出去之前，另一个来自于同一个源路由器的链路状态数据包也到来了，那么就比较它们的序号。<ul>
<li>如果两个数据包的序号相等，则丢弃重读数据包</li>
<li>如果两者不相等，则丢弃老的数据包</li>
</ul>
</li>
<li>为了防止线路产生错误导致丢包和错包，所有的链路状态数据包都要被确认</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-14.png" width="65%">

<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-15.png" width="65%">


<h3 id="计算新路由"><a href="#计算新路由" class="headerlink" title="计算新路由"></a>计算新路由</h3><p>一旦路由器已经积累了全部的链路状态数据包之后，它就可以构造出完整的网络图，因为每条链路都已经被表示出来了。事实上，每条链路被表示了两次，每个方向各表示一次。不同方向的链路可能有不同的成本。最短路径计算可找到从 A 到 B 与从 B 到 A 不同的路径</p>
<p>现在可以在路由器本地运行 Dijkstra 算法，以便构建出从本地出发到所有可能目标的最短路径。这个算法的运行结果告诉路由器到达每个目的地能够走哪条链路。这个信息被安装在路由表中，而且恢复正常操作</p>
<h3 id="链路状态路由总结"><a href="#链路状态路由总结" class="headerlink" title="链路状态路由总结"></a>链路状态路由总结</h3><ul>
<li>需要更多的内存和计算<ul>
<li>在大型网络中运行这个算法依然是个问题</li>
</ul>
</li>
<li>没有慢收敛问题<ul>
<li>在许多实际场合，链路状态路由算法工作地很好</li>
</ul>
</li>
</ul>
<p>应用</p>
<ul>
<li>许多 ISP 使用中间系统到中间系统（IS-IS, Intermediate System-Intermediate System）链路状态协议</li>
<li>开放最短路径优先（OSPF, Open Shortest Path First）</li>
</ul>
<h2 id="层次路由（hierarchical-hierarchy）"><a href="#层次路由（hierarchical-hierarchy）" class="headerlink" title="层次路由（hierarchical/hierarchy）"></a>层次路由（hierarchical/hierarchy）</h2><p>区域（reigon）-簇（cluster）-区（zone）-群（group）-…</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-16.png" width="65%">


<h2 id="广播路由（broadcast）"><a href="#广播路由（broadcast）" class="headerlink" title="广播路由（broadcast）"></a>广播路由（broadcast）</h2><p>同时给全部目标地址发送一个数据包称为广播（braodcasting）</p>
<p>实现广播</p>
<ul>
<li>广播网络<ul>
<li>设置一个特殊的地址作为“所有主机地址”</li>
</ul>
</li>
<li>非广播网络<ul>
<li>给每个目标地址单独发送数据包（单播unicast）<ul>
<li>浪费带宽</li>
</ul>
</li>
<li>泛洪<ul>
<li>产生太多数据包，浪费带宽</li>
</ul>
</li>
<li>多目标路由（multidestination outing）</li>
<li>生成树（spanning tree）<ul>
<li>网络的一个子集，包含所有的路由器，但没有任何环路</li>
<li>汇集树是生成树的一种</li>
</ul>
</li>
<li>逆向路径转发（RPF, reverse path forwarding）</li>
</ul>
</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-17.png" width="65%">


<h2 id="组播路由（multicast）"><a href="#组播路由（multicast）" class="headerlink" title="组播路由（multicast）"></a>组播路由（multicast）</h2><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-18.png" width="65%">


<p>距离矢量组播路由协议（DVMRP）</p>
<ul>
<li>基于核心树（core-based trees）的技术</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-19.png" width="65%">


<h2 id="任播路由（anycast）"><a href="#任播路由（anycast）" class="headerlink" title="任播路由（anycast）"></a>任播路由（anycast）</h2><p>也叫选播</p>
<h2 id="移动主机路由（mobile-host）"><a href="#移动主机路由（mobile-host）" class="headerlink" title="移动主机路由（mobile host）"></a>移动主机路由（mobile host）</h2><ul>
<li>家乡位置（home location）</li>
<li>家乡地址（home address）</li>
<li>家乡代理（home agent）</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-20.png" width="65%">


<h2 id="自组织网络路由（ad-hoc-network）"><a href="#自组织网络路由（ad-hoc-network）" class="headerlink" title="自组织网络路由（ad hoc network）"></a>自组织网络路由（ad hoc network）</h2><p>Ad hoc 按需距离矢量路由算法（AODV）</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-21.png" width="65%">


<h1 id="网络互联（internetwork）"><a href="#网络互联（internetwork）" class="headerlink" title="网络互联（internetwork）"></a>网络互联（internetwork）</h1><p>internet</p>
<ul>
<li>将两个或多个网络连接起来</li>
</ul>
<p>Internet</p>
<ul>
<li>更通用的术语，由不同硬件和协议组成</li>
</ul>
<p>存在着许多不同的网络</p>
<ul>
<li>PAN、LAN、MAN、WAN<ul>
<li>以太网（Ethernet）、802.11、802.16、固定和移动电话网络</li>
</ul>
</li>
</ul>
<p>梅特卡夫定律（Metcalfe）</p>
<ul>
<li>一个具有 $N$ 个结点的网络的价值等于节点之间的连接数，或者 $N^2$</li>
<li>这意味着大型网络比小型网络更有价值，因为它们允许更多的连接，所以始终有将小型网络联结起来的激励</li>
</ul>
<h2 id="网络如何不同"><a href="#网络如何不同" class="headerlink" title="网络如何不同"></a>网络如何不同</h2><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-22.png" width="65%">


<h2 id="何以连接网络"><a href="#何以连接网络" class="headerlink" title="何以连接网络"></a>何以连接网络</h2><p>两种基本选择</p>
<ul>
<li>可以制造设备，它能将每种网络的数据包翻译或转换成每个其他类别网络的数据包</li>
<li>尝试在不同网络的上面加一个间接层，并且构造一个公共层来解决这个问题<br>两种情况下，新设备被放置在网络之间的边界上</li>
</ul>
<p>Cerf 和 Kahn 提出用一个公共层来隐藏所有网络的差异</p>
<ul>
<li>IP 提供了一种通用的数据包格式，所有路由器都认识这种数据包，因而这种数据包几乎可以通过所有的网络传递<ul>
<li>计算机网络、电话（telephone）网络、传感器（sensor）网络</li>
</ul>
</li>
</ul>
<p>连接网络的不同设备</p>
<ol>
<li>中继器（repeater）、集线器（hub） —— 物理层</li>
</ol>
<ul>
<li>只是将比特从一根导线移动到另一根导线，它们大多是模拟设备</li>
</ul>
<ol start="2">
<li>网桥（bridge）、交换机（switch） —— 数据链路层</li>
</ol>
<ul>
<li>可以被用来构建网络，只能处理轻微的协议转换<ul>
<li>例如，在 10、100、1000 Mbps 以太网交换机之间传递帧</li>
</ul>
</li>
</ul>
<ol start="3">
<li>路由器（router） —— 网络层</li>
</ol>
<ul>
<li>能够连接两个网络</li>
</ul>
<p>用一个公共的网络层来互连不同的网络</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-23.png" width="65%">


<p>帧结构</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-24.png" width="65%">


<p>网络协议操作</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-25.png" width="65%">


<p>路由情况和交换（或桥接）的本质区别</p>
<ul>
<li>在路由器上，数据包被从帧中提取出来，数据包中的网络地址被用来决定把它转发到哪里<ul>
<li>路由器不必了解交换机所使用的链路层协议</li>
</ul>
</li>
<li>在交换机（或网桥）上，整个帧是根据其MAC地址传送的<ul>
<li>交换机不必了解正在被交换的数据包所采用的网络层协议</li>
</ul>
</li>
</ul>
<p>引入网桥的目的就是用它们将不同类型的网络连接起来，或者至少把不同类型的局域网连接在一起</p>
<ul>
<li>把一个LAN的帧翻译成另一个LAN的帧，这样工作并不理想</li>
</ul>
<p>现在，网桥主要用于在数据链路层连接相同类型的网络<br>路由器在网络层连接不同的网络</p>
<p>仅当有一个公共网络层时，网络互联才能工作</p>
<ul>
<li>IP、IPX、SNA、AppleTalk</li>
<li>IPv4、IPv6</li>
</ul>
<p>可以处理多个网络协议的路由器称为多协议路由器（multipeotocol router）</p>
<ul>
<li>但是具有不同网络协议的网络很难在两者之间进行转换</li>
<li>隧道是一个常见的特例</li>
</ul>
<h2 id="隧道（tunneling）"><a href="#隧道（tunneling）" class="headerlink" title="隧道（tunneling）"></a>隧道（tunneling）</h2><p>源主机和目标主机所在的网络类型完全相同，但中间却隔着一个不同类型的网络</p>
<ul>
<li>整个数据包被封装在中间不同类型的网络协议中，之后在另一侧被恢复</li>
<li>避免了翻译数据包</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-26.png" width="65%">


<p>隧道类比</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-27.png" width="65%">


<p>隧道被广泛用于连接那些因使用其他网络而被隔离的主机和网络。结果生成的网络就是所谓的覆盖（overlay）网络，因为它有效地覆盖在基础网络之上</p>
<p>隧道的缺点是无法到达位于隧道之下网络的主机，因为数据包无法送隧道中间逃生</p>
<ul>
<li>这个限制变成了虚拟专用网络（VPN, Virtual Private Networks）的优势</li>
<li>VPN 就是一个提供安全措施的简单覆盖网络</li>
</ul>
<h2 id="互联网路由"><a href="#互联网路由" class="headerlink" title="互联网路由"></a>互联网路由</h2><p>互联网络的路由所面临的问题</p>
<ul>
<li>内部网络可能使用不同的路由算法</li>
<li>网络由不同的运营商运行，运营商对于什么是通过网络的好路径有不同的想法</li>
<li>一个运营商甚至可能不希望另一个运营商了解它网络的路径细节</li>
<li>互联网络可能比构成它的任何一个网络都大。因此它或许需要采用层次结构的扩展性较好的路由算法，即使没有一个网络需要使用层次结构路由</li>
</ul>
<p>两级路由算法</p>
<ul>
<li>在每个网络中，使用一个域内（intradomain）或内部网关协议（interior gateway protocol）进行路由<ul>
<li>链路状态路由、距离矢量路由</li>
</ul>
</li>
<li>为了让数据包跨越构成互联网的网络，就需要用到域间（interdomain）或外部网关协议（exterior protocol），边界网关路由协议（BGP, Border Gateway Protocol）<br>网络可能全部使用不同的域内协议，但必须使用相同的域间协议</li>
</ul>
<p>自治系统 AS（Autonomous System）</p>
<ul>
<li>每个网络独立于所有其他网络运营，因此这样的网络通常称为一个自治系统 AS（Autonomous System）</li>
<li>AS 的良好默认模型是 ISP 网络<ul>
<li>事实上，一个 ISP 网络或许由多个 AS 组成</li>
</ul>
</li>
</ul>
<p>路由策略（routing policy）</p>
<ul>
<li>在 Internet 上，一大决定因素是 ISP 之间的商业安排<ul>
<li>每个 ISP 可能因替其他 ISP 承载流量而收取或接收相应的费用</li>
</ul>
</li>
<li>另一个因素在于，如果国际互联网络的路由需要跨越国界<ul>
<li>各国的法律可能会突然开始发挥作用</li>
</ul>
</li>
<li>所有这些非技术因素都包裹在一个路由策略概念中，控制着自治网络自主选择所用的路由</li>
</ul>
<h2 id="数据包分段"><a href="#数据包分段" class="headerlink" title="数据包分段"></a>数据包分段</h2><p>每个网络或者链路都会限制其数据包的最大长度，这种限制来自多方面的原因</p>
<ol>
<li>硬件（比如以太网帧的长度限制）</li>
<li>操作系统（比如所有的缓冲区都是 512 字节）</li>
<li>协议（比如数据包长度字段中的位数）</li>
<li>遵从某个国家（或国际）标准</li>
<li>期望将错误引入的重传次数减少到某种程度</li>
<li>期望防止数据包占用信道时间太长</li>
</ol>
<h3 id="路径-MTU"><a href="#路径-MTU" class="headerlink" title="路径 MTU"></a>路径 MTU</h3><p>路径上的最大的数据包大小称为路径最大传输单元（MTU, Path Maximun Transmission Unit）</p>
<ul>
<li>源端通常不知道数据包通过网络到达接收方的路径，因此也不知道路径 MTU 的大小</li>
<li>即使源端知道路径 MTU，数据包在无连接网络中也是独立路由的，比如 Internet。这种路由意味着路径可能会突然改变，因而意外地更改路径 MTU</li>
</ul>
<h3 id="分段（Fragment）"><a href="#分段（Fragment）" class="headerlink" title="分段（Fragment）"></a>分段（Fragment）</h3><p>允许路由器将数据包拆分成段，将每个段作为一个独立的网络层数据包发送</p>
<p>数据包交换网络把段重新整合起来非常麻烦</p>
<ul>
<li>两种对立策略<ul>
<li>透明分段（non-Transparent Fragment）</li>
<li>非透明分段（Transparent Fragment）</li>
</ul>
</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-28.png" width="65%">

<h4 id="透明分段"><a href="#透明分段" class="headerlink" title="透明分段"></a>透明分段</h4><p>从该网络一直到最终的目标途中的每个网络都感觉不到曾经发生过分段</p>
<p>一个网络中，进入路由器对一个数据包进行分段，同一网络中的出口路由器将这些分段重新组装成原始数据包</p>
<p>问题</p>
<ul>
<li>出口路由器必须知道什么时候它已经接收到了全部的段<ul>
<li>每个分段中必须提供一个计数字段 / 结束标志位</li>
</ul>
</li>
<li>所有的数据包必须经过同一个出口路由器才能进行重组<ul>
<li>路由收到了限制</li>
</ul>
</li>
<li>需要缓冲</li>
<li>开销（当一个数据包需要通过一系列的小数据包网络时，需要多次被分段和重组）</li>
</ul>
<h4 id="非透明分段"><a href="#非透明分段" class="headerlink" title="非透明分段"></a>非透明分段</h4><p>避免在任何一个中间路由器上重新组合分段。一旦一个数据包已经被分段，则每个段都被当做原始的数据包一样来对待，重组过程只在目标主机上进行</p>
<p>路由器所做的工作比较少，IP 就是以这种方式工作的</p>
<p>缺点</p>
<ul>
<li>要求每个主机都能够重新组装</li>
<li>携带小片段的开销直到目的地（因为每个片段都必须有一个头）</li>
<li>如果丢失了任何一个分片，整个包都将丢失</li>
</ul>
<p>一个完整的设计要求分段可以重新构建原数据流的方式编号</p>
<ul>
<li>IP 采用的设计思想是<ul>
<li>给每一个段一个数据包序号（所有的数据包都携带）、一个数据包内的绝对字节偏移量、和一个指明是否到达数据包末尾的标志位</li>
</ul>
</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-29.png" width="65%">

<ul>
<li>段到达目的地后可以被放置在一个缓冲区中以便重组，即使这些分段到达的顺序凌乱不堪</li>
<li>当段要穿过一个 MTU 更小的网络时，还可以被路由器再次进行分段</li>
<li>数据包的重传（如果所有的段都没有收到）可以被分割成不同的段</li>
<li>段可以任意大小，最小的段是一个字节加上数据包头</li>
<li>在所有情况下，接收方只需简单地使用数据包的序号和段偏移量即可把数据放置在合适的位置，并利用数据包结束标志位来确定何时有了一个完整的数据包</li>
</ul>
<p>问题</p>
<ul>
<li>因为段的存在，开销可能比透明分段高</li>
<li>分段不利于性能，因为除了增加头开销，数据包的丢失概率也增加了；任何一个段的丢失都将导致整个数据包的丢失；而且对于主机而言，分比不分带来了更大的突发</li>
</ul>
<h3 id="路径-MTU-发现（path-MTU-discovery）"><a href="#路径-MTU-发现（path-MTU-discovery）" class="headerlink" title="路径 MTU 发现（path MTU discovery）"></a>路径 MTU 发现（path MTU discovery）</h3><p>工作原理</p>
<ul>
<li>每个 IP 数据包发出时在它的头设置一个比特，指示不允许对该数据包实施分段操作</li>
<li>如果一个路由器接收的数据包太大，它就生成一个报错数据包并发给源端，然后丢弃该数据包<ul>
<li>ICMP [Type 3, Code 4] 消息包含了 MTU</li>
</ul>
</li>
<li>当源端收到报错数据包它就使用报错数据包携带的信息重新将出错数据包分段，每个段足够小到报错路由器能够处理</li>
<li>如果沿着路径前进又遇到一个 MTU 更小的路由器，那么重复上述过程<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-30.png" width="65%">

</li>
</ul>
<p>路径 MTU 发现的优点是源端知道应该发送多长的数据包了</p>
<ul>
<li>如果路由器和路径 MTU 发生改变，新的报错数据包将被触发返回，因而源端将适应新的路径。然而，仍然需要在源端和接收方之间实施分段，除非更高层次的协议了解路径 MTU，并把适量的数据传给IP。TCP 和 IP 通常是一起实现的，因而能够传递这类信息。即使其他协议不是这样实现，仍然可以把分段移出网络，让主机承担</li>
</ul>
<p>缺点是有可能增加发送数据包的启动延迟</p>
<ul>
<li>在任何数据被传递到目的地之前，探讨路径并且找出该路径 MTU 所花的时间可能需要不止一个往返延迟<ul>
<li>更好的设计：每个路由器把那些超出其 MTU 的数据包简单地拦腰截断，这样一来将确保接收方尽可能快地了解MTU（从传递过来的数据量），同时接收到了部分数据</li>
</ul>
</li>
</ul>
<h1 id="Internet-的网络层"><a href="#Internet-的网络层" class="headerlink" title="Internet 的网络层"></a>Internet 的网络层</h1><p>10 大原则 RFC 1958</p>
<ol>
<li>保证工作（make sure it works）</li>
<li>保持简单（keep it simple）</li>
<li>明智选择（make clear choices）</li>
<li>模块开发（exploit modularity）</li>
<li>期望异构性（expect heterogeneity）</li>
<li>避免静态选项和参数（avoid static options and parameters）</li>
<li>寻找好的而不是完美的设计（look for a good design; it need not be perfect）</li>
<li>严格发送，宽容接收（be strict when sending and tolerant when receiving）</li>
<li>考虑可扩展性（think about scalability）</li>
<li>考虑性能和成本（consider performance and cost）</li>
</ol>
<hr>
<p>在网络层，可以把 Internet 看作是一种相互关联的网络或自治域（自治系统）集合。没有真正的结构，但存在几个主要骨干网。这些都是由高带宽线路和快速路由器组成。这些骨干网中最大的一个称为一级网络（Tier 1 networks），每个骨干网都与它连接，进而到达其他骨干网。连接到骨干网上的是 Internet 服务提供商（ISP, Internet Service Provider），它为家庭和企业、数据中心和服务器托管设施，以及区域（中级）网络提供 Internet 接入服务。</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-31.png" width="65%">

<p>将整个 Internet 黏合在一起的正是网络层协议，即 Internet 协议（IP, Internet Protocol）</p>
<ul>
<li>IP 在设计之初就把网络互联作为目标</li>
<li>IP 的任务是提供一种尽力而为（best-effort）地把数据包从源端传输到接收方的方法（即不提供任何保证），无须考虑这些机器是否在同一个网络，也不必担心它们之间是否还有其他网络</li>
</ul>
<p>Internet 中的通信过程</p>
<ul>
<li>传输层获取数据流，并且将数据流拆分成段，以便作为IP数据包发送<ul>
<li>理论上，每个数据包最多可容纳 64 KB ，但实际上，数据包通常不超过 1500 字节（以太网帧）</li>
</ul>
</li>
<li>IP 路由器转发每个数据包穿过 Internet ，沿着一条路径把数据包从一个路由器转发到下一个路由器，直到数据包到达目的地</li>
<li>当所有的数据段最终都抵达目标机器，它们被网络层重新组装还原成最初的数据报</li>
<li>然后该数据报被网络层传给传输层<ul>
<li>在接收方，网络层将数据交给应用层，再由传输层交给接收进程</li>
</ul>
</li>
</ul>
<p>TCP/IP 协议栈</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-32.png" width="65%">


<p>Internet 体系结构沙漏</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-33.png" width="65%">


<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-34.png" width="65%">


<p>协议数据单元封装</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-35.png" width="65%">


<p><strong>网络字节序</strong></p>
<p>经常出现的一个问题是不同的机器以不同的方式表示整数</p>
<ul>
<li>大端序（Big Endian），最高有效字节在最低地址处（左边）</li>
<li>小端序（Little Endian），最高有效字节在最高地址处</li>
</ul>
<p>与所有网络协议一样，标准指定每个字段中所有位的含义，根据字节和位的顺序</p>
<p>Internet 定义大端序为标准字节序，用于指向 Internet 数据报的字段</p>
<h2 id="IPv4-协议"><a href="#IPv4-协议" class="headerlink" title="IPv4 协议"></a>IPv4 协议</h2><p>每个 IP 数据报包含两个部分：一个头和一个正文（有效载荷）</p>
<p>头由一个 20 字节的定长部分和一个可选的变长部分组成</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-36.png" width="65%">

<ol>
<li>4 bit 版本（version）</li>
</ol>
<ul>
<li>记录了数据报属于协议哪个版本，IPv4 / IPv6</li>
</ul>
<ol start="2">
<li>4 bit IHL</li>
</ol>
<ul>
<li>指明了头到底有多长（以 32 位字长度为单位）</li>
<li>最小值为 5，表明没有可选项；最大值为 15，把头的长度限制为最大 60 字节</li>
<li>实际用来指出数据的起始部分</li>
</ul>
<ol start="3">
<li>8 bit 区分服务（differentiated services）</li>
</ol>
<ul>
<li>前 6 位用来标记数据包的服务类别，后2位用来携带显式拥塞通知信息（数据包是否经历拥塞）</li>
</ul>
<ol start="4">
<li>16 bit 总长度（total length）</li>
</ol>
<ul>
<li>包含了该数据报中的所有内容，即头和数据</li>
<li>最大长度是 65535 个字节</li>
</ul>
<ol start="5">
<li>16 bit 标识（identification）</li>
</ol>
<ul>
<li>让目标主机确定一个新到达的分段属于哪一个数据报</li>
<li>同一个数据报的所有段包含同样的标识（分段）</li>
</ul>
<ol start="6">
<li>1 bit 未使用</li>
<li>1 bit DF （Don’t Fragment）</li>
</ol>
<ul>
<li>不允许路由器分割该数据报</li>
<li>路径 MTU（完整到达/返回报错消息）</li>
</ul>
<ol start="8">
<li>1 bit MF （More Fragment）</li>
</ol>
<ul>
<li>代表更多的段，除了最后一个段以外，其他所有的段都必须设置这一位</li>
<li>接收方可以知道什么时候一个数据报的所有分段都已经到达了</li>
</ul>
<ol start="9">
<li>13 bit 分段偏移量（fragment offset）</li>
</ol>
<ul>
<li>指明了该段在当前数据报中的位置</li>
<li>除了数据报的最后一个段以外，其他所有段的长度必须是 8 字节的倍数</li>
<li>每个数据报最多有 $2^{13} = 8192$ 个段，支持 <code>total length</code> 字段限制的最大数据包</li>
<li>identification、MF、fragemnt offset 协同工作，实现分段操作</li>
</ul>
<ol start="10">
<li>8 bit 生存期（TTL, time to live）</li>
</ol>
<ul>
<li>限制数据包生存期的计数器（跳计数器）</li>
<li>避免数据包永远滞留在网络中</li>
</ul>
<ol start="11">
<li>8 bit 协议（protocol）</li>
</ol>
<ul>
<li>指明了将数据包交给哪个传输进程</li>
<li>ICMP:1     <code>00000001</code></li>
<li>IGMP:2     <code>00000010</code></li>
<li>TCP :6     <code>00000110</code></li>
<li>UDP :17    <code>00010001</code></li>
<li>OSPF:89    <code>01011001</code></li>
</ul>
<ol start="12">
<li>16 bit 头检验和（header checksum）</li>
</ol>
<ul>
<li>校验保护</li>
<li>每一跳必须重新计算校验和字段，以内至少有个字段总是不断在改变（TTL）</li>
</ul>
<ol start="13">
<li>32 bit 源地址（source address）</li>
<li>32 bit 目标地址（destination address）</li>
</ol>
<ul>
<li>表示源网络接口和目标网络接口的 IP 地址</li>
</ul>
<ol start="15">
<li>0~40*8 选项（options）</li>
</ol>
<ul>
<li>选项字段的设计意图是提供一种途径，允许后续版本协议包含一些原设计中没有出现的信息，以便实验人员尝试新的想法、避免为那些不常使用的信息分配头字段</li>
<li>选项字段用来将整个选项长度填充到4字节的倍数</li>
<li>每个选项字段的第一个字节是一个标识码，标明了该选项类别。有的选项后面跟着 1 字节的选项长度字段，然后是一个或多个数据字节</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-37.png" width="65%">


<p>IP 嵌入式数据报包含源发送端（不是转发网关）和目标的唯一地址</p>
<h3 id="分段举例"><a href="#分段举例" class="headerlink" title="分段举例"></a>分段举例</h3><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-38.png" width="65%">

<h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><p>IPv4 的一个明确特征是它的 32 位地址</p>
<p>Internet 上的每台主机和每个路由器都有一个 IP 地址，可用在 IP 数据包的 <code>source address</code> 和 <code>destination address</code> 字段</p>
<p>一个 IP 地址并不真正指向一台主机，而是指向一个网络接口</p>
<p>每个 IP 地址都是唯一的</p>
<ul>
<li>地址由 32 位标识符组成</li>
<li>Internet 软件将地址转换成名字，将名字转换成地址；低层协议通常使用地址而不是名字</li>
<li>地址编码其网络地址和主机号，这种组合是唯一的：原则上，Internet 中没有两台机器具有相同的 IP 地址</li>
</ul>
<p>IPv4 地址举例</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-39.png" width="65%">


<h3 id="前缀（prefix）"><a href="#前缀（prefix）" class="headerlink" title="前缀（prefix）"></a>前缀（prefix）</h3><p>点分十进制表示法（dotted decimal notation）</p>
<ul>
<li>4 个字节中的每个写成十进制，取值范围从 0 到 255</li>
<li>32 位 16 进制地址 <code>80D00297</code> 写成 <code>128.208.2.151</code></li>
<li>最低 IP 地址为 <code>0.0.0.0</code>，最高 IP 地址为 <code>255.255.255.255</code></li>
</ul>
<p>前缀</p>
<ul>
<li>每个 32 位地址由高位的可变长网络和低位的主机两部分数据组成</li>
<li>同一网络上（比如以太局域网）的所有主机，其地址的网络值是相同的，这意味着一个网络对应一块连续的IP地址空间，这块地址空间就称为地址的前缀（prefix）</li>
<li>前缀的书写给出了块的最低 IP 地址和块的大小<ul>
<li>块大小由网络部分的位数决定；地址中主机部分的剩余位数可以有所变化</li>
<li>这意味着，块的大小必须是 2 的幂次方</li>
</ul>
</li>
</ul>
<p>按照惯例，网络地址的书写格式是前缀IP地址后跟一个斜线，斜线后是网络部分的位长度</p>
<ul>
<li>如果前缀包含 $2^8$ 个地址，留下了 24 位用于网络部分，写成 <code>128.208.0.0/24</code></li>
<li>斜线读作 slash</li>
<li>因为前缀长度仅从 IP 地址无法判断出来，路由协议必须把前缀携带给路由器</li>
<li>前缀长度相当于网络部分中 1 的二进制掩码，以这格式书写时称为子网掩码（subnet mask），它可以与一个 IP 地址进行 AND 操作，以便提取出该 IP 地址的网络部分</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-40.png" width="65%">

<ul>
<li>IP 前缀为 <code>128.208.0.0/24</code></li>
<li>子网掩码为 <code>255.255.55.0</code></li>
</ul>
<h3 id="层次化地址"><a href="#层次化地址" class="headerlink" title="层次化地址"></a>层次化地址</h3><p>优点</p>
<ul>
<li>路由器仅仅根据地址的网络部分即可转发数据包，只要每个网络都有一个唯一的地址块<ul>
<li>对路由器来说网络地址的主机部分并不重要，因为同一网络上的所有主机都在同一个方向，只有当数据包到达它们的目的地网络后才被转发到正确的主机</li>
<li>需要维护的路由表的大小减少</li>
</ul>
</li>
</ul>
<p>缺点</p>
<ul>
<li>一个主机的 IP 地址取决于它位于网络上的位置<ul>
<li>以太网地址可用于世界上任何地方，但每个 IP 地址属于一个特定的网络，路由器只能传递注定要到该网络上某个地址的数据包。比如移动IP这样的设计必须支持主机在网络之间移动，但同时保持相同的 IP 地址</li>
</ul>
</li>
<li>层次结构浪费了地址，除非精心管理地址空间<ul>
<li>如果给网络分配大块的地址，将有很多被分配但不会使用</li>
</ul>
</li>
</ul>
<h3 id="子网（subnet）"><a href="#子网（subnet）" class="headerlink" title="子网（subnet）"></a>子网（subnet）</h3><p>地址分配</p>
<ul>
<li>为了避免冲突，网络地址的管理由一个称为Internet域名和地址分配机构（ICANN, Internet Corporation for Assigned Names and Number）的非营利性公司负责</li>
<li>ICANN 一次把部分地址空间授权给各区域机构，这些机构再把 IP 地址发放给 ISP 和其他公司</li>
</ul>
<p>子网划分（subnetting）</p>
<ul>
<li>在内部将一个网络块分成几个部分供多个内部网络使用，但对外部世界仍然像单个网络一样</li>
<li>分割一个大型网络得到的一系列结果网络（比如以太网）称为子网（subnet）</li>
</ul>
<p>子网划分例子</p>
<ul>
<li>一个/16地址空间被分割成几片</li>
<li>这种分割并不要求均匀，但每片必须对齐以便可以把较低的任何位用作地址的主机部分</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-41.png" width="65%">

<ul>
<li>块的一半（/17）分配给了艺术系</li>
<li>四分之一（/18）分配给了电机工程学系</li>
<li>八分之一（/19）分配给了艺术系</li>
</ul>
<p>子网成分（properties）</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-42.png" width="65%">


<p>路由器决定将数据包转发到哪个子网</p>
<ul>
<li>当数据报到达时，路由器会查看该数据包的目标地址，并检查它属于哪个子网<ul>
<li>路由器把数据包的目标地址与每个子网的掩码进行 AND 操作，看结果是否对应于某个前缀</li>
</ul>
</li>
</ul>
<p>决定入境数据包</p>
<ul>
<li>哪个子网</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-43.png" width="65%">


<p>例子</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-44.png" width="65%">

<p>在网络外面，子网的划分是不可见的，因此分配一个新的子网不需要联系ICANN或者改变任何外部数据库</p>
<p>决定出境数据包</p>
<ul>
<li>本地（local）还是远端（remote）网络</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-45.png" width="65%">


<h3 id="CIDR-——-无类域间路由"><a href="#CIDR-——-无类域间路由" class="headerlink" title="CIDR —— 无类域间路由"></a>CIDR —— 无类域间路由</h3><p>路由表爆炸</p>
<ul>
<li>ISP 和骨干路由器之间的路由必须知道通过哪些方式可到达每个网络，这里没有简单的默认路由可用。这些核心路由器处在一个 Internet 默认自由区（default-free zone）<br>Internet 包含上百万的网络，产生一个巨大的路由表</li>
<li>此外，路由算法要求每个路由器与其他路由器交换有关它能到达的地址信息。表越大，需要通信和处理的信息量也越大</li>
</ul>
<p>路由聚合（aggregation）</p>
<ul>
<li>减小路由表的大小</li>
<li>不同的路由器可以知道一个给定 IP 地址的不同大小前缀</li>
<li>把多个小前缀的地址块合并成一个大前缀的地址块，这个合并过程称为路由聚合</li>
<li>由此产生的较大前缀地址块有时称为超网（supernet），以便有别于地址块的分割</li>
</ul>
<p>无类域间路由（CIDR） RFC 4632</p>
<ul>
<li>有了地址聚合，IP 地址可包含大小不等的前缀，同样一个 IP 地址，一台路由器把它当做 <code>/22</code> 的一部分对待（其中包含 $2^{10}$ 个地址），另一台路由器把它当做一个更大的 <code>/20</code> 一部分对待（其中包含 $2^{12}$ 个地址）。这是因为每个路由器有相应的前缀信息，这个设计和子网划分协同工作，统称为无类域间路由（CIDR, Classless Inter-Domain Routing）</li>
</ul>
<p>工作原理</p>
<ul>
<li>路由表由（IP 地址, 子网掩码, 出境线路）的三元组组成<ul>
<li>当一个数据包到达时，路由器扫描路由表以便确定目的地是否在前缀的地址块内</li>
</ul>
</li>
<li>当一个数据包到达时，首先提取其目标 IP 地址。然后（在概念上）路由表按照条目进行扫描，对目标地址作掩码操作并与路由表条目进行比较以寻找匹配<ul>
<li>真正一个表项一个表项地扫描表，将会相当冗长乏味</li>
<li>人们设计了复杂的算法来加快地址匹配过程（Ruiz-Sanchez）；商用路由器使用了定制的 VLSI。这些算法被嵌入到了硬件中</li>
</ul>
</li>
<li>有可能多个具有不同前缀的表项得到匹配，在这种情况下，使用具有最长前缀的表项（最长匹配前缀）</li>
<li>因此，如果有一个匹配 <code>/20</code> 掩码的表项，同时还有一个匹配 <code>/24</code> 掩码的表项，则使用 <code>/24</code> 表项来查询数据包的出境线路</li>
</ul>
<p>例子</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-46.png" width="65%">


<p>伦敦路由器示意图</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-47.png" width="65%">

<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-48.png" width="65%">


<p>最长匹配前缀（longest matching prefix）</p>
<ul>
<li>前缀允许重叠，规则是数据包按最具体路由器的方向发送，即具有最少IP地址的最长匹配前缀（longest matching prefix）</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-49.png" width="65%">


<h3 id="分配和特殊寻址"><a href="#分配和特殊寻址" class="headerlink" title="分配和特殊寻址"></a>分配和特殊寻址</h3><p>分类寻址</p>
<ul>
<li>IP 被分为 5 个类别，这种分配称为分类寻址（classful addressing）</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-50.png" width="65%">

<ul>
<li>A 类地址：128 个网络，每个网络 1600 万台主机</li>
<li>B 类地址：16384 个网络，每个网络 65536 台主机</li>
<li>C 类地址：200 万个网络，每个网络多达 256 台主机（不过有些地址是特殊的）</li>
<li>D 类地址：支持 Internet 组播，即数据包被直接发送给多台主机</li>
<li>E 类地址：111 开头的保留地址，以备将来使用</li>
</ul>
<p>层次化设计，但与 CIDR 不同：地址块的大小是固定的，因此有很多地址的浪费</p>
<ul>
<li>引入了子网，以便在一个组织内部灵活分配地址快</li>
<li>引入 CIDR 技术来减小全局路由表的大小</li>
</ul>
<p>特殊 IP 地址</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-51.png" width="65%">

<ul>
<li><code>0.0.0.0</code> 最低的地址，代表本机，指的是当前网络</li>
<li><code>255.255.255.255</code> 最高的地址，用来标识指定网络中的所有主机，允许在本地网络上广播，通常是局域网</li>
<li><code>127.xx.yy.zz</code> 保留给回环测试用，测试网络软件</li>
</ul>
<h2 id="NAT-——-网络地址转换"><a href="#NAT-——-网络地址转换" class="headerlink" title="NAT —— 网络地址转换"></a>NAT —— 网络地址转换</h2><h3 id="动态-IP-地址"><a href="#动态-IP-地址" class="headerlink" title="动态 IP 地址"></a>动态 IP 地址</h3><p>为一台连在网上并使用网络的计算机动态分配一个 IP 地址，而且在该主机不活跃时收回分配给它的 IP 地址；然后该 IP 地址可以被分配给另一台活跃的计算机</p>
<ul>
<li>对于使用拨号连接的家庭用户，解决 IP 地址问题的一个方法是在电话呼叫并登陆时动态分配 IP 地址，并在会话结束时将 IP 地址返还<ul>
<li>客户希望持续在线</li>
<li>ADSL 或线缆上的 Internet 服务（永久 IP 地址和月租费）</li>
</ul>
</li>
</ul>
<h3 id="网络地址转换-NAT（RFC-3022）"><a href="#网络地址转换-NAT（RFC-3022）" class="headerlink" title="网络地址转换 NAT（RFC 3022）"></a>网络地址转换 NAT（RFC 3022）</h3><p>NAT 的基本思想是 ISP 为每个家庭或每个公司分配一个或少量 IP 地址，用这个 IP 地址来传输 Internet 流量</p>
<ul>
<li>在客户网络内部，每台计算机有唯一的 IP 地址，该地址主要用来路由内部流量</li>
<li>当一个数据包需要离开客户网络，发向其他 ISP 时，它必须执行一个地址转换，把唯一的内部 IP 地址转换成那个共享的公共 IP 地址</li>
</ul>
<h3 id="保留的-IP-地址（reserved）"><a href="#保留的-IP-地址（reserved）" class="headerlink" title="保留的 IP 地址（reserved）"></a>保留的 IP 地址（reserved）</h3><p>地址转换使用了 IP 地址的三个范围，这些地址已经被声明为私有化。任何网络可以在内部随意地使用这些地址。仅有的规则是不允许包含这些地址的数据包出现在 Internet 上</p>
<table>
<thead>
<tr>
<th>ip</th>
<th>hosts</th>
</tr>
</thead>
<tbody><tr>
<td>1.0.0.0        – 10.255.255.255 /8</td>
<td>16,777,216 hosts</td>
</tr>
<tr>
<td>172.16.0.0      – 172.31.255.255 /12</td>
<td>1,048,576 hosts</td>
</tr>
<tr>
<td>192.168.0.0     – 192.168.255.255/16</td>
<td>65,536 hosts</td>
</tr>
</tbody></table>
<h3 id="NAT-操作过程"><a href="#NAT-操作过程" class="headerlink" title="NAT 操作过程"></a>NAT 操作过程</h3><p>每台机器都有一个形如 <code>10.x.y.z</code> 的地址</p>
<p>当一个数据包离开客户端时，它首先要通过一个 NAT 盒子（NAT box）</p>
<ul>
<li>NAT 盒子将内部的IP源地址转换成该客户所拥有的真实IP地址</li>
<li>NAT 盒子通常与防火墙组合成一个单一设备，防火墙提供了一种安全机制（仔细地控制着进出客户网络的流量）</li>
<li>NAT 盒子还有可能集成到路由器或者 ADSL 调制解调器中</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-52.png" width="65%">


<h3 id="NAT-应答问题"><a href="#NAT-应答问题" class="headerlink" title="NAT 应答问题"></a>NAT 应答问题</h3><p>当应答数据包返回时，NAT盒子如何知道该用哪一个地址来替代？</p>
<ul>
<li>TCP/UDP 端口（port）<ul>
<li>大多数 IP 数据包携带 TCP/UDP 有效载荷</li>
<li>两个协议的头都包含了一个源端口和一个目标端口字段</li>
<li>端口是 16 位整数，指示 TCP 连接从哪里开始以及到哪里结束</li>
<li>这些端口字段为 NAT 提供了工作所需的字段</li>
</ul>
</li>
</ul>
<h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><p>当一个进程希望与另一个远程进程建立 TCP 连接时，它把自己绑定到一个本地机器尚未使用的 TCP 端口上</p>
<ul>
<li>该端口称为源端口（source port），它告诉 TCP 代码凡是属于该连接的入境数据包都应该发送给该端口。</li>
</ul>
<p>这个进程还要提供一个目标端口（destination port），以指明数据包传输到远程机器上之后应该交给谁处理</p>
<p>0~1023 之间的端口都是保留端口，用于一些知名服务</p>
<ul>
<li>比如端口 80 是 Web 服务器使用的端口，所以远程客户能找到 Web 服务器进程</li>
</ul>
<p>每个出境 TCP 消息都包含一个源端口和一个目标端口</p>
<ul>
<li>这两个端口合起来标识了客户机和服务器两端正在使用该连接的一对进程</li>
</ul>
<h3 id="映射源端口"><a href="#映射源端口" class="headerlink" title="映射源端口"></a>映射源端口</h3><p>利用源端口（source port）字段，可以解决映射问题。任何时候当出境数据包进入 NAT 盒子，其源地址 <code>10.x.y.z</code> 被客户的真实IP地址所取代，而且 TCP 的源端口字段被一个索引值取代，该索引值指向 NAT 盒子的地址转换表中的 65536 个表项之一</p>
<p>该表项包含了原来的IP地址和原来的源端口</p>
<p>最后，NAT 盒子重新计算 IP 头和 TCP 头的校验和，并将校验和插入到数据包中<br>之所以要替换 <code>source port</code> 域，是因为来自机器 <code>10.0.0.1</code> 和 <code>10.0.0.2</code> 连接可能碰巧使用了同一个端口，比如都使用了 5000，所以仅使用 <code>source port</code> 还不足以唯一性地标识发送进程</p>
<p>当一个数据包从 ISP 到达 NAT 盒子时，<code>source port</code> 从TCP头中提取出来，并被用作为索引值查找 NAT 盒子的映射表。找到对应的表项后，从该表项提取出内部 IP 地址和原来的TCP <code>source port</code>，并将它们插入到数据包中。然后重新计算 IP 和 TCP 校验和，并插入到数据包中。最后将该数据包传递给客户内部的路由器，它使用 <code>10.x.y.z</code> 地址进行正常的路由。</p>
<p><em>类比为电话和接线员</em></p>
<h3 id="NAT-问题"><a href="#NAT-问题" class="headerlink" title="NAT 问题"></a>NAT 问题</h3><ol>
<li>NAT 违反了 IP 的结构模型</li>
<li>NAT 打破了 Internet 的端-端的连接模型，即任何一个主机可在任何时间给任何一台其他主机发送数据包</li>
<li>NAT 将 Internet 从一个无连接网络改变成一个面向连接网络特有的形式</li>
<li>NAT 违反了最基本的协议分层规则：第 $k$ 层不应该对第 $k+1$ 层在本层的有效载荷字段中放什么作任何假设</li>
<li>Internet 上的进程并不一定必须使用 TCP 或 UDP</li>
<li>有些应用以规定的方式使用多个 TCP/IP 连接或者 UDP 端口</li>
</ol>
<ul>
<li>标准的文件传输协议（FTP, File Transfer Protocol）在数据包正文插入 IP 地址，接收方正文中提取出这些地址，并使用它们。NAT 对此一无所知</li>
</ul>
<ol start="7">
<li>由于 TCP <code>source port</code> 字段 16 位长，至多只有 65536 台机器可以被映射到同一个 IP 地址上（前 4096 个端口被保留用作特殊的用途）</li>
</ol>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>目标</p>
<ol>
<li>即使地址空间的分配效率不高，也能支持几十亿台主机（Support billions of hosts, even with inefficient address allocation）</li>
<li>降低路由表大小（Reduce the size of the routing tables）</li>
<li>简化协议，使路由器更快速地处理数据包（Simplify the protocol, to allow routers to process packets faster）</li>
<li>提供更好的安全（认证和隐私）（Provide better security （authentication and privacy））</li>
<li>更加关注服务类型，特别是针对实时数据（Pay more attention to the type of service, particularly for real-time data）</li>
<li>辅助指定范围内的组播（Aid multicasting by allowing scopes to be specified）</li>
<li>主机漫游时无需改变地址（Make it possible for a host to roam without changing its address）</li>
<li>允许协议向未来演进（Allow the protocol to evolve in the future）</li>
<li>允许新老协议共存多年（Permit the old and new protocols to coexist for years）</li>
</ol>
<h3 id="主要的-IPv6-头"><a href="#主要的-IPv6-头" class="headerlink" title="主要的 IPv6 头"></a>主要的 IPv6 头</h3><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-53.png" width="65%">

<ul>
<li>4 bit 版本（Version）：IPv6 是 6 （<code>0110</code>），IPv4 是 4</li>
<li>8 bit 区分服务（Differentiated services）</li>
<li>20 bit 流标签（Flow label）: 最初创建用于提供实时应用程序特殊服务</li>
<li>16 bit 有效载荷长度（Payload length）</li>
<li>8 bit 下一个头（Next header）</li>
<li>8 bit 跳数限制（Hop limit）: IPv4 的 TTL</li>
<li>128 bit 源地址（Source address）</li>
<li>128 bit 目标地址（Destination address）</li>
</ul>
<h3 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h3><p>16 个字节被分成 8 组 4 个十六进制数字，组之间用冒号隔开</p>
<ul>
<li><code>8000:0000:0000:0000:0123:4567:89AB:CDEF</code></li>
<li>十六进制不区分大小写</li>
</ul>
<p>优化方法：</p>
<ul>
<li>在一个组内可以省略前导 0，0123 可以写成 123</li>
<li>16 个 0 构成的一个或多个组可以用一对冒号来代替，但 <code>::</code> 只能出现一次，<code>8000:123:4567:89AB:CDEF</code></li>
<li>IPv4 地址现在可以写成一对冒号再加上老式的点分十进制数，比如 <code>::192.31.20.46</code></li>
</ul>
<h4 id="扩展头"><a href="#扩展头" class="headerlink" title="扩展头"></a>扩展头</h4><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-54.png" width="65%">


<p>用于大型数据报（巨型报）的逐跳扩展头</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-55.png" width="65%">


<p>路由扩展头</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-56.png" width="65%">


<h3 id="IPv4-和-IPv6-的转换"><a href="#IPv4-和-IPv6-的转换" class="headerlink" title="IPv4 和 IPv6 的转换"></a>IPv4 和 IPv6 的转换</h3><ul>
<li>双栈路由器（dual stack）</li>
<li>隧道（tunelling）</li>
</ul>
<h2 id="Internet-控制协议"><a href="#Internet-控制协议" class="headerlink" title="Internet 控制协议"></a>Internet 控制协议</h2><p>IP 协议依靠多种辅助协议来实现必要的控制和路由功能：</p>
<ul>
<li>控制功能 ICMP</li>
<li>组管理 IGMP</li>
<li>设置路由表 RIP, OSPF, BGP, PIM, …</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-57.png" width="65%">

<h3 id="ICMP-——-Internet-控制消息协议"><a href="#ICMP-——-Internet-控制消息协议" class="headerlink" title="ICMP —— Internet 控制消息协议"></a>ICMP —— Internet 控制消息协议</h3><p>Internet Control Message Protocol</p>
<p>路由器严密监视 Internet 操作，当路由器在处理一个数据包的过程中发生了意外，可通过 ICMP 向数据包的源端报告有关时间</p>
<p>ICMP 还可以用来测试 Internet</p>
<p>每一种 ICMP 消息类型都被封装在一个 IP 数据包中</p>
<p>ICMP 的目标</p>
<ul>
<li>错误报告</li>
<li>简单请求</li>
</ul>
<p>分层</p>
<ul>
<li>从分层的角度来看，ICMP 是一种独立的协议，位于 IP 之上并使用 IP 传输消息</li>
<li>实际上，ICMP 是 IP 的组成部分，所有 IP 模块必须支持 ICMP 协议</li>
<li>ICMP 数据报封装在 IP 数据报中，IP 按照与 TCP 和 UDP 数据报相同的方式处理 ICMP</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-58.png" width="65%">


<p>消息封装</p>
<ul>
<li>ICMP 消息被封装为 IP 数据报</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-59.png" width="45%">


<p>ICMP 消息格式</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-60.png" width="65%">

<p>4 byte 头（header）</p>
<ul>
<li>1 byte  类型（Type）: ICMP 消息的类型</li>
<li>1 byte  码（Code）: ICMP 的子类型</li>
<li>2 bytes 校验和（Checksum）: 和 IP 头校验和类似，校验和计算整个 ICMP 消息<ul>
<li>如果没有格外的数据，4 bytes 将被设置为 0</li>
<li>每个 ICMP 消息至少 8 bytes 长</li>
</ul>
</li>
</ul>
<p>ICMP 消息类型</p>
<ul>
<li>信息消息，发送方向另一台机器（主机或网关）发送请求并且期待回答<ul>
<li>例如，主机可能想知道网关是否还活着</li>
</ul>
</li>
<li>错误指示消息，主机或网关上的IP软件在处理 IP 数据报时遇到问题<ul>
<li>例如，它可能无法将数据报路由到其目的地，或者可能不得不丢弃一个帧</li>
</ul>
</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-61.png" width="65%">


<p>ICMP 请求消息</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-62.png" width="65%">

<ul>
<li>Request 主机发送给路由或另一个主机</li>
<li>Reply 返回给发送请求的主机</li>
</ul>
<p>ICMP 请求举例</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-63.png" width="65%">

<h4 id="ICMP-的请求-响应目的"><a href="#ICMP-的请求-响应目的" class="headerlink" title="ICMP 的请求 / 响应目的"></a>ICMP 的请求 / 响应目的</h4><p>ICMP请求回显（echo request）和回显响应（echo reply）对网络调试很有用</p>
<ul>
<li>如果机器 A 向机器 B 发送请求回显消息，机器 B 需要用回显响应来响应请求</li>
<li>大多数系统提供发送和接收 ICMP 回显消息的应用程序</li>
<li>在 UNIX 中，<code>ping</code> 允许用户检查机器是否可达并正常工作</li>
<li>因为 ICMP 消息与其他 IP 数据报一样处理，ICMP 回显消息测试任何主机的可达性。另外，因为 ICMP 是 IP 的组成部分，所有主机和网关必须实现 ICMP</li>
</ul>
<p>请求举例 —— Echo</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-64.png" width="65%">

<ul>
<li><code>ping</code> 由内核直接处理</li>
<li>每个 <code>ping</code> 都被转换成 ICMP Echo Request</li>
<li>每个被 <code>ping</code> 的主机都回应一个 ICMP Echo Reply</li>
</ul>
<h4 id="时间戳消息"><a href="#时间戳消息" class="headerlink" title="时间戳消息"></a>时间戳消息</h4><p>ICMP 时间戳消息用于估计机器之间的传输延迟并同步时钟</p>
<ul>
<li>包括接受和发送时间戳允许发送主机确定发送和处理请求的事件比例</li>
<li>通过对几条消息的测量值进行平均，发送方可以估计本地时钟和远程机器之间的偏移量</li>
<li>注意：将局域网内所有机器的时钟同步到几毫秒以内是完全 ok 的</li>
<li>测量网络的性能</li>
</ul>
<p>请求举例 —— 时间戳</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-65.png" width="65%">

<ul>
<li>系统（主机或路由器）询问另一个系统当前时间</li>
<li>时间以当天凌晨UTC（协调世界时）后的毫秒为单位测量</li>
<li>发送方发送请求（request），接收方响应回应（reply）</li>
</ul>
<p>消息格式</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-66.png" width="65%">


<p>错误消息</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-67.png" width="65%">

<ul>
<li>ICMP错误消息报告错误状况</li>
<li>通常在丢其数据报时发送</li>
<li>错误消息通常从ICMP传递到应用程序</li>
</ul>
<p>消息格式</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-68.png" width="65%">

<ul>
<li>ICMP 错误消息包含整个 IP 头和有效载荷的前 8 个字节（通常为 UDP/TCP ）</li>
</ul>
<p>经常使用的 ICMP 错误消息</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-69.png" width="65%">


<p>目的不可达的子类型</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-70.png" width="65%">


<p>错误消息举例 —— 端口不可达</p>
<p>RFC 792：如果在目标主机中，IP 模块由于指定的协议模块或进程端口未处于活动状态而无法传送数据报，目标主机可能会向源主机发送目标不可达消息</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-71.png" width="65%">


<p>Windows控制台命令 —— <code>tracert</code></p>
<ul>
<li>TTL 递增，发现从主机到目的地的路径上的 IP 地址</li>
<li>路由器返回超时消息</li>
</ul>
<h3 id="ARP-——-地址解析协议"><a href="#ARP-——-地址解析协议" class="headerlink" title="ARP —— 地址解析协议"></a>ARP —— 地址解析协议</h3><p>Address Resolution Protocol</p>
<p>每一块网络接口卡（NIC）在出厂时配置了一个唯一的 48 位以太网地址</p>
<p>协议数据单元封装</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-72.png" width="65%">


<p>以太网II 中的 TCP/IP 数据包</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-73.png" width="65%">

<h4 id="ARP-与-RARP"><a href="#ARP-与-RARP" class="headerlink" title="ARP 与 RARP"></a>ARP 与 RARP</h4><ul>
<li>Internet 基于 IP</li>
<li>数据链路协议（以太网，FDDI，ATM）可能有不同的（MAC）地址</li>
</ul>
<p>ARP 和 RARP 协议执行 IP 地址和 MAC 地址之间的转换</p>
<p>讨论广播 LAN 的 ARP，特别是以太网 LAN</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-74.png" width="65%">


<h4 id="映射问题"><a href="#映射问题" class="headerlink" title="映射问题"></a>映射问题</h4><p>将 Internet 地址映射到物理地址的问题称为地址解析问题</p>
<ul>
<li>每个以太网设备有自己唯一号码，更换网卡就更换了物理地址</li>
<li>物理地址 6 bytes 长，太大而无法在 Internet 地址内复用</li>
<li>可以在不中断服务的情况下降新机器添加到网络中</li>
<li>但是，添加主机不应该要求现有重新配置现有主机以通知新机器的加入</li>
</ul>
<h4 id="ARP-地址转换"><a href="#ARP-地址转换" class="headerlink" title="ARP 地址转换"></a>ARP 地址转换</h4><p>ARP 请求（Request）</p>
<ul>
<li>广播询问哪个路由137的硬件地址</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-75.png" width="65%">


<p>ARP 回应（Reply）</p>
<ul>
<li>路由137响应请求，返回的数据中包含自己的硬件地址</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-76.png" width="65%">


<h4 id="ARP-包格式"><a href="#ARP-包格式" class="headerlink" title="ARP 包格式"></a>ARP 包格式</h4><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-77.png" width="65%">


<h4 id="ARP-举例"><a href="#ARP-举例" class="headerlink" title="ARP 举例"></a>ARP 举例</h4><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-78.png" width="65%">

<p>ARP 缓存</p>
<ul>
<li>由于为每个 IP 数据报发送 ARP 请求/回应效率低下，主机维护当前 ARP 缓存，20 分钟后过期</li>
</ul>
<p>ARP 代理</p>
<ul>
<li>主机或路由器响应从连接的另一个网络上的主机的 ARP 请求</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-79.png" width="65%">


<p>关于 ARP</p>
<ul>
<li>一些系统（包括Linux）上，主机定期根据 ARP 缓存发送 ARP 请求，刷新 ARP 缓存内容，但也增加了流量</li>
</ul>
<p>免费 ARP（gratuitous ARP）: 一个主机发送一个 ARP 请求自己的 IP 地址</p>
<ul>
<li>网络上应该不会有任何应答，这个广播数据包的副作用是其他主机在 ARP 缓存中加入一个映射表项</li>
<li>如果意外地收到了一个应答，说明两台机器被分配了相同的 IP 地址</li>
<li>检测 IP 地址是否已经被分配</li>
</ul>
<p>ARP 的脆弱性</p>
<ol>
<li>由于 ARP 没有对请求或响应进行认证，因此可以伪造 ARP 请求和响应</li>
<li>ARP 是无状态的：可以在没有相应的 ARP 请求的情况下发送 ARP 响应</li>
<li>根据 ARP 协议规范，接收 ARP 数据包的节点（请求或响应）必须使用源字段中的信息更新其本地 ARP 缓存，如果接收节点已在其ARP缓存中具有源IP地址的条目。（适用于 ARP 请求数据包和 ARP 响应数据包）<br>利用</li>
</ol>
<ul>
<li>一个伪造的 ARP 请求或响应可以用来更新伪造远程系统中的 ARP 缓存条目（ARP Poisoning 中毒）</li>
<li>可以用来将 IP 流量重定向到其他主机</li>
</ul>
<p>分层：不同的视角</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-80.png" width="65%">


<p>Windows控制台命令 —— <code>arp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a   显示所有ARP缓存</span><br><span class="line">-d * 删除所有ARP缓存</span><br><span class="line">-s   加入一条静态条目</span><br></pre></td></tr></table></figure>

<h3 id="DHCP-——-动态主机配置协议"><a href="#DHCP-——-动态主机配置协议" class="headerlink" title="DHCP —— 动态主机配置协议"></a>DHCP —— 动态主机配置协议</h3><p>Dynamic Host Configuration Protocol</p>
<p>采用 DHCP 时，每个网络必须有一个 DHCP 服务器负责地址配置</p>
<h4 id="手动配置-TCP-IP-的问题"><a href="#手动配置-TCP-IP-的问题" class="headerlink" title="手动配置 TCP/IP 的问题"></a>手动配置 TCP/IP 的问题</h4><p>管理开销</p>
<ul>
<li>需要跟踪所有 IP 分配</li>
<li>需要手动输入 IP 设置</li>
</ul>
<p>坏的或重复的 IP 地址</p>
<ul>
<li>将出现错误</li>
</ul>
<p>在子网间移动</p>
<ul>
<li>需要手动更改 IP 设置</li>
</ul>
<h4 id="用-DHCP-来配置-TCP-IP"><a href="#用-DHCP-来配置-TCP-IP" class="headerlink" title="用 DHCP 来配置 TCP/IP"></a>用 DHCP 来配置 TCP/IP</h4><p>DHCP 的好处</p>
<ul>
<li>集中管理</li>
<li>自动为客户端提供地址信息</li>
<li>更容易排查故障</li>
</ul>
<p>DHCP 可以提供的设置</p>
<ul>
<li>网络适配器的IP地址</li>
<li>子网掩码</li>
<li>默认网关</li>
<li>其他参数 —— DNS, WINS, …</li>
</ul>
<h4 id="BOOTP-RFC-951-1048-1084"><a href="#BOOTP-RFC-951-1048-1084" class="headerlink" title="BOOTP RFC 951/1048/1084"></a>BOOTP RFC 951/1048/1084</h4><p>bootstrap 协议（BOOTP）</p>
<ul>
<li>从 1985 年起</li>
<li>主机可以在启动时配置其 IP 参数</li>
<li>3 个服务<ul>
<li>IP 地址分配</li>
<li>检测服务器的 IP 地址</li>
<li>由客户机加载和执行的文件的名称（启动文件名）</li>
</ul>
</li>
</ul>
<p>不仅分配 IP 地址，还分配默认路由器、网络掩码等<br>作为 UDP 消息发送（UDP 端口 67（服务器）和 68（主机））</p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>动态主机配置协议</p>
<ul>
<li>从 1993 年起</li>
<li>BOOTP 的扩展</li>
<li>使用和 BOOTP 相同的的端口</li>
<li>扩展<ul>
<li>支持 IP 地址的临时分配（租赁lease）</li>
<li>DHCP 客户端可以获取操作所需的所有的 IP 配置参数</li>
</ul>
</li>
<li>DHCP 是动态分配 IP 地址的首选机制</li>
<li>DHCP 可以与 BOOTP 客户端进行互操作</li>
</ul>
<p>路由器的 DHCP 中继</p>
<ul>
<li>DHCP 利用了 BOOTP 定义的消息协议和配置技术，包括分配 IP 地址的能力</li>
<li>这种相似性允许现有路由器在子网之间中继 DHCP 消息 / BOOTP 消息</li>
<li>因为这个，单个 DHCP 服务器可以处理多个子网的 IP 寻址</li>
</ul>
<p>BOOTP 交互</p>
<ul>
<li>BOOTP 可以用来从无盘工作站下载内存映像（memory image）</li>
<li>分配给主机的 IP 地址是静态的</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-81.png" width="65%">


<p>简化的 DHCP 交互</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-82.png" width="65%">


<h4 id="BOOTP-DHCP-消息格式"><a href="#BOOTP-DHCP-消息格式" class="headerlink" title="BOOTP/DHCP 消息格式"></a>BOOTP/DHCP 消息格式</h4><p>许多 DHCP 信息是以选项的形式被发送的</p>
<ul>
<li>子网掩码、名称服务器，路由器，主机名，域名，转发开/关，默认 IP TTL，广播地址，静态路由，以太网封装，DHCP 消息类型，DHCP 更新时间，DHCP 重新绑定，时间 SMTP 服务器，SMTP 服务器，…</li>
</ul>
<p>DHCP 选项域格式</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-83.png" width="65%">


<p>客户机-服务器通信</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-84.png" width="65%">


<p>IP 租赁</p>
<ul>
<li>发现（Discover）和提供（Offer）</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-85.png" width="65%">


<p>当没有 DHCP 服务器在线时</p>
<ul>
<li>客户机等待 1 秒钟</li>
<li>客户机在第 9,3,16 秒重新广播，之后随机间隔广播</li>
<li>客户机每 5 分钟重试一次</li>
</ul>
<p>IP 租赁更新</p>
<ul>
<li>客户机广播 DHCP REQUEST 消息<ul>
<li>当租赁期过了 50% 的时候</li>
</ul>
</li>
<li>DHCP 服务器返回 DHCP ACK</li>
<li>当客户机尝试租先前的 IP 地址时，就会出现 DHCP ACK<ul>
<li>IP 地址不再可用</li>
<li>客户机移动到另一个子网</li>
<li>如果收到了一个 DHCP ACK，客户机就进入请求 IP 租赁的过程</li>
</ul>
</li>
</ul>
<p>IP 租赁释放</p>
<ul>
<li>由客户端发起释放（RELEASE）</li>
</ul>
<p>分层视角</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-86.png" width="45%">

<ul>
<li>确定配置选项</li>
<li>IP 地址和掩码始终是 IP 配置的一部分</li>
<li>其他选项包括<ul>
<li>默认网关</li>
<li>域名系统（DNS）服务器</li>
<li>Windows Internet 名称（WINS）服务器</li>
<li>基于 TCP/IP 名称解析的 NetBIOS</li>
</ul>
</li>
</ul>
<p>Windows命令行 —— <code>ipconfig</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;?           Display help message</span><br><span class="line">&#x2F;all         Display full configuration information</span><br><span class="line">&#x2F;release     Release the IP address for the specified adapter</span><br><span class="line">&#x2F;renew       Renew the IP address for the specified adapter</span><br><span class="line">&#x2F;flushdns    Purges the DNS Resolver cache</span><br><span class="line">&#x2F;registerdns Refreshes all DHCP leases and re-registers DNS names</span><br><span class="line">&#x2F;displaydns  Display the contents of the DNS Resolver Cache.</span><br></pre></td></tr></table></figure>

<h2 id="标签交换和-MPLS"><a href="#标签交换和-MPLS" class="headerlink" title="标签交换和 MPLS *"></a>标签交换和 MPLS *</h2><p>ISP 用来在它们的网络之间移动 Internet 流量</p>
<p>多协议标签交换（MPLS）在每个数据包前面增加一个标签，路由器根据数据包标签而不是数据包目的地址实施转发</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-87.png" width="65%">


<h3 id="2-5-层协议"><a href="#2-5-层协议" class="headerlink" title="2.5 层协议"></a>2.5 层协议</h3><p>MPLS 介于 IP 网络层协议和 PPP 链路层协议之间</p>
<ul>
<li>不是一个真正的第 3 层协议，因为它依赖 IP 或其他网络层地址来建立标签路径</li>
<li>不是一个真正的第 2 层协议，因为它既可以在多跳之间转发数据包，也不是一条单一链路</li>
</ul>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-88.png" width="65%">

<ul>
<li>标签交换路由器（LSR, Label Switched Router）</li>
<li>标签边缘路由器（LER, Label Edge Router）</li>
<li>转发等价类（FEC, Forwarding Equivalence Class）</li>
</ul>
<h2 id="OSPF-——-内部网关路由协议"><a href="#OSPF-——-内部网关路由协议" class="headerlink" title="OSPF —— 内部网关路由协议"></a>OSPF —— 内部网关路由协议</h2><p>域内路由（intradomain routing） - 内部网关协议（IGP, interior gateway protocol）</p>
<p>域间路由（interdomain routing） - 外部网关协议（EGP, exterior gateway protocol）</p>
<h3 id="Internet-上的内部网关协议"><a href="#Internet-上的内部网关协议" class="headerlink" title="Internet 上的内部网关协议"></a>Internet 上的内部网关协议</h3><p>RIP 路由信息协议（Routing Information Protocol）</p>
<ul>
<li>采用距离矢量的设计思想，基于分布式 Bellman-Ford 算法，继承自 APPANET</li>
<li>在小型网络中运作良好</li>
<li>无穷计数问题，收敛速度较慢</li>
</ul>
<p>OSPF 开放最短路径优先（Open Shortest Path First）</p>
<ul>
<li>一个链路状态协议，1990 年成为标准，IETF</li>
<li>借鉴了 IS-IS （中间系统到中间系统，已成为 ISO 标准）</li>
</ul>
<h3 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h3><ol>
<li>算法必须发表在公开文献中</li>
<li>新的协议必须支持多种距离度量，包括物理距离、延迟等</li>
<li>必须是一个动态算法，能够自动而且快速地适应网络拓扑变化</li>
<li>必须支持基于服务类型的路由。新的协议必须能够区分实时流量和其他流量，并使用不同的路由方法</li>
<li>必须实现负载均衡，即把负载分散到多条线路上</li>
<li>必须支持层次化系统，不要求路由器知道完整的拓扑结构也能很好地工作</li>
<li>要求提供适度的安全性</li>
<li>对于那些通过隧道连接到Internet的路由器，新协议也必须能够对它们进行处理</li>
</ol>
<p>OSPF 支持 3 种网络</p>
<ul>
<li>两个路由器间的点到点链路（如 SONET）</li>
<li>多路访问广播网络（大多数局域网）</li>
<li>多路访问网络（包交换的广域网）（multiaccess）</li>
</ul>
<p><em>这里的多路访问网络是一个拥有多个路由器的网络，每个路由器都可以直接与其他路由器通信，这是一种常见的 LAN/WAN 属性</em></p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-89.png" width="75%">

<ul>
<li>OSPF 的工作方式本质上是对一张图进行操作：将一组实际网络、路由器和线路抽象到一个有向图中，图中的每条弧有一个权值（距离、延迟）</li>
<li>两台路由器之间的点到点连接可以用一对弧来标识，每个方向上一个，两个方向上的权值可以不同。广播（multiaccess）网络用一个节点表示，加上网络上每台路由器用一个节点表示</li>
</ul>
<p>等价成本多路径（ECMP, Equal Cost MultiPath）</p>
<ul>
<li>有可能协议会发现多个同样短的路径，OSPF 记住最短路径集合，并在报文转发期间把流量分摊到这些路径上</li>
</ul>
<p>OSPF 区域（area）</p>
<ul>
<li>将庞大的 AS 划分成编号的区域</li>
<li>每个区域是一个网络，或者一组互连的网络</li>
<li>区域不能重叠，但是也不必面面俱到，也就是说有些路由器可能不属于任何一个区域</li>
<li>全部属于一个区域的路由器称为内部路由器（internal router）</li>
<li>区域是单个网络的一种泛化形式，在区域外部能见到的是它的目的地而不是拓扑结构</li>
</ul>
<p>OSPF 骨干区域（backbone area）</p>
<ul>
<li>每个 AS 有一个骨干区域，称为 0 号区域</li>
<li>该区域中的路由器称为骨干路由器（backbone router）</li>
<li>所有的区域都必须连接到骨干区域，连接方式有可能会通过隧道进行</li>
<li>每个连接到两个或更多区域的路由器称为区域边界路由器（border router），它必须是骨干区域的一部分<ul>
<li>区域边界路由器的工作任务：概括本区域的目的地信息并注入到与自己连接的其他区域。这种概括包括成本信息，但不包括区域内部的所有拓扑细节</li>
<li>传递成本信息可以使得其他区域内的主机找到进入本区域的最好区域边界路由器</li>
<li>不传递拓扑信息可以减少流量和简化其他区域路由器的最短路径计算</li>
</ul>
</li>
</ul>
<p>存根区域（stub area）</p>
<ul>
<li>如果只有一个边界路由器通往区域外，甚至路由信息概要都不需要传递</li>
<li>通往该区域外部目的地的路由总是被指令“前往边界路由器”，这类区域称为存根区域（stub area）</li>
</ul>
<p>AS - Autonomous system 自治域</p>
<p>AS 边界路由器（AS boundary router）</p>
<ul>
<li>把通往其它 AS 的外部路由注入到本区域</li>
<li>然后外部路由就可呈现为可以通过 AS 边界路由器可达的目的地，该路由器当然会有某种成本</li>
<li>外部路由可以注入一个或更多个 AS 边界路由器</li>
</ul>
<p>自治域、区域和各种路由器之间的关系</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-90.png" width="65%">


<p>链路状态算法</p>
<ul>
<li>每个区域内的路由器由相同的链路状态数据库，并运行相同的最短路径算法<ul>
<li>其主要工作是计算从自身出发到每个其他路由器和整个AS内网络的最短路径</li>
<li>根据距离或其他属性进行计算</li>
</ul>
</li>
</ul>
<p>OSPF 路由</p>
<ul>
<li>区域内（intra-area）</li>
<li>区域间（inter-area）<ul>
<li>从源所在区域到骨干区域</li>
<li>穿过骨干区域到目标区域</li>
<li>到达目的地</li>
</ul>
</li>
<li>跨域（inter-AS）</li>
</ul>
<p>OSPF 路由步骤：</p>
<ol>
<li>当一台路由器启动时，它在所有点到点线路上发送 <code>HELLO</code> 消息，并且通过 LAN 将 <code>HELLO</code> 消息组播到一个包含所有其他路由器的组。每台路由器从应答消息中得知谁是自己的邻居。同一个 LAN 上的路由器都是邻居</li>
<li>在邻接的路由器之间相互交换信息</li>
</ol>
<ul>
<li>OSPF 要求从每个 LAN 中选举一台路由器作为指定路由器（designated router）</li>
<li>指定路由器与本 LAN 上的所有其他路由器都是邻接的，并且与它们交换信息</li>
<li>实际上，它就是一个代表本 LAN 的单个节点</li>
</ul>
<ol start="3">
<li>路由状态更新</li>
</ol>
<ul>
<li>每台路由器周期性地泛洪 <code>LINK STATE UPDATE</code> 消息到它的每台邻接路由器<ul>
<li>这些消息给出了它的状态信息，并提供了拓扑数据库用到的成本信息</li>
</ul>
</li>
<li>这些泛洪消息需要被确认，以保证它们的传输可靠性<ul>
<li>每条消息都有一个序号，路由器据此判断一条入境 <code>LINK STATE UPDATE</code> 消息的新旧</li>
</ul>
</li>
<li>当一条线路启用、停止或其成本发生改变时，路由器也要发送 <code>LINK STATE UPDATE</code> 消息</li>
<li>所有这些消息都是以 IP 数据包的形式直接被发送出去</li>
</ul>
<ol start="4">
<li>通过泛洪法，每个路由器把它与其他路由器和网络的链路以及链路成本告诉给它所在区域中的所有其他路由器。这些信息使得每台路由器都可以构建出它所在区域的拓扑图，并计算最短路径</li>
</ol>
<ul>
<li>骨干区域也是这样工作的</li>
<li>而且，为了计算出从每个骨干路由器到每个其他路由器的最佳路由，路由器还要接受来自每个区域边界路由器的信息。最佳路由信息又被传回到区域边界路由器，区域边界路由器再将这些信息在本区域内广播。利用这些信息，内部路由器可以选择通往区域外目的地的最优路由，包括通往骨干区域的最佳出口路由</li>
</ul>
<p>OSPF 数据包的头格式</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-91.png" width="65%">


<p>OSPF 的 5 类消息</p>
<img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-92.png" width="65%">


<h2 id="BGP-——-边界网关路由协议"><a href="#BGP-——-边界网关路由协议" class="headerlink" title="BGP —— 边界网关路由协议*"></a>BGP —— 边界网关路由协议*</h2><p>在一个 AS 内部，推荐使用的路由协议是 OSPF 和 IS-IS</p>
<p>在 AS 之间，则可以使用 BGP（Border Gateway Protocol, 边界网关协议）</p>
<ul>
<li>在自治域之间路由（interdomain routing）</li>
<li>BGP 考虑政治、安全和经济因素</li>
</ul>
<h3 id="BGP-政策"><a href="#BGP-政策" class="headerlink" title="BGP 政策"></a>BGP 政策</h3><p>政策通常被手动配置到每个 BGP 路由器中（或包含某种脚本）。它们不是协议本身的一部分<br>可能的路由限制</p>
<ol>
<li>教育网路不承载商业流量</li>
<li>五角大楼发出的流量永远不要走经过伊拉克的路径</li>
<li>使用 TeliaSonera 而不用 Verizon，因为前者更便宜</li>
<li>不要使用澳大利亚的 AT&amp;T，因为它的性能太差</li>
<li>起止于苹果的流量不应该经过谷歌中转</li>
</ol>
<h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-93.png" width="65%">


<h3 id="BGP-基础"><a href="#BGP-基础" class="headerlink" title="BGP 基础"></a>BGP 基础</h3><p>BGP 是距离矢量协议的一种形式，但它与域内距离矢量协议（如 RIP ）有很大的不同</p>
<ul>
<li>用策略而不是最小距离来选择使用哪些路由</li>
<li>BGP 不仅维护到每个目的地的成本，而且每个 BGP 路由器还跟踪所使用的路径<ul>
<li>路径由下一跳路由器和一系列 AS 或 AS 路径组成，这些自治系统或者相应的路径序列是该路由器必须遵守的</li>
<li>这种方法称为路径矢量协议（path vector protocol）</li>
</ul>
</li>
</ul>
<p>一对 BGP 路由器通过建立 TCP 连接而相互通信</p>
<ul>
<li>这种方法既提供了可靠的通信，也隐藏了正在穿越的网络细节</li>
</ul>
<h3 id="BGP-路由通告的传播"><a href="#BGP-路由通告的传播" class="headerlink" title="BGP 路由通告的传播"></a>BGP 路由通告的传播</h3><img src="https://media.githubusercontent.com/media/jckling/Assets/master/computer%20networks/5/5-94.png" width="65%">

<ul>
<li>中间的 ISP 为左右两个 ISP 提供中转服务</li>
</ul>
<h3 id="路由器如何为每个目的地选择使用哪条路由"><a href="#路由器如何为每个目的地选择使用哪条路由" class="headerlink" title="路由器如何为每个目的地选择使用哪条路由"></a>路由器如何为每个目的地选择使用哪条路由</h3><p>三种策略</p>
<ul>
<li>优先选择通过对等网络的路由，而不是通过中转提供商的路由</li>
<li>将“短路径更好”作为默认规则</li>
<li>优先选择具有 ISP 内最小成本的路由<ul>
<li>称为提前退出（early exit）或热土豆路由（hot-potato routing）</li>
<li>副作用是使得路由呈现不对称性</li>
</ul>
</li>
</ul>
<h2 id="Internet-组播"><a href="#Internet-组播" class="headerlink" title="Internet 组播*"></a>Internet 组播*</h2><p>IP 用 D 类 IP 地址来支持一对多通信，或组播（multicasting）</p>
<ul>
<li>每个 D 类地址标识了一组主机</li>
<li>总共有 28 位可用于标识组播组，因此网络中可同时并存 250 万个组</li>
<li>IP 地址 <code>224.0.0.0/24</code> 范围内的地址保留用作本地网络组播</li>
</ul>
<table>
<thead>
<tr>
<th>ip</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.1</td>
<td>All systems on a LAN</td>
</tr>
<tr>
<td>224.0.0.2</td>
<td>All routers on a LAN</td>
</tr>
<tr>
<td>224.0.0.5</td>
<td>All OSPF routers on a LAN</td>
</tr>
<tr>
<td>224.0.0.251</td>
<td>All DNS servers on a LAN</td>
</tr>
</tbody></table>
<h3 id="IGMP-RFC-3376"><a href="#IGMP-RFC-3376" class="headerlink" title="IGMP (RFC 3376)"></a>IGMP (RFC 3376)</h3><p>Internet 组管理协议（IGMP, Internet Group Management Protocol）</p>
<ul>
<li>一个进程要求它的主机加入到某个指定的组中，它也可以要求它的主机离开该组</li>
<li>每台主机跟踪记录当前它的哪些进程属于哪些组<ul>
<li>当一台主机上的最后一个进程离开一个组时，该主机就不再属于这个组</li>
</ul>
</li>
<li>大约每分钟一次，每个组播路由器向它所在LAN上的所有主机发送一个查询数据包（使用本地组播地址 <code>224.0.0.1</code> ），要求这些主机报告自己当前属于哪些组<ul>
<li>组播路由器可能与标准的路由器在同一台机器上，也可能分属两台机器</li>
</ul>
</li>
<li>每个主机收到查询消息后，返回一个响应包，其中包括了自己感兴趣的所有 D 类地址<ul>
<li>查询包和响应包都使用了 IGMP 协议</li>
</ul>
</li>
</ul>
<h3 id="PIM"><a href="#PIM" class="headerlink" title="PIM"></a>PIM</h3><p>协议独立组播协议（PIM, Protocol Independent Protocol）</p>
<ul>
<li>几个组播路由协议中的任何一个都可用于建立组播生成树，该树给出了一条从发送方到组内所有成员的路径</li>
<li>AS 内主要使用 PIM</li>
<li>密集模式 PIM<ul>
<li>修剪的逆向路径转发树</li>
<li>成员分布在网络各处，如数据中心把文件分发给多个服务器</li>
</ul>
</li>
<li>稀疏模式 PIM<ul>
<li>类似于核心树</li>
<li>内容提供商向它 IP 网络上的用户组播 TV</li>
<li>变体：特定源组播 PIM（Source-Specific Multicast PIM）可用来优化只有一个发送方的情况</li>
</ul>
</li>
</ul>
<h2 id="移动-IP"><a href="#移动-IP" class="headerlink" title="移动 IP *"></a>移动 IP *</h2><p>目标</p>
<ol>
<li>每台移动主机必须能在任何地方使用它的家乡 IP 地址</li>
<li>不允许修改固定主机的软件</li>
<li>不允许改动路由器软件和各类表</li>
<li>发给移动主机的大多数数据包不应该绕道而行</li>
<li>移动主机在家时不应该有任何开销</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jckling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jckling.github.io/2018/06/15/Notes/Computer%20Networks/The-Network-Layer/">https://jckling.github.io/2018/06/15/Notes/Computer Networks/The-Network-Layer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jckling.github.io" target="_blank">Jckling's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/Computer-Networks/">Computer Networks</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/jckling/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/jckling/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1035234274961147" data-ad-slot="3100725659" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/06/22/Notes/Computer%20Networks/The-Transport-Layer/"><img class="prev-cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" onerror="onerror=null;src='/img/jckling/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《计算机网络（英文版·第5版）》 The Transport Layer</div></div></a></div><div class="next-post pull-right"><a href="/2018/06/14/Notes/Computer%20Networks/The-Data-Link-Layer/"><img class="next-cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" onerror="onerror=null;src='/img/jckling/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《计算机网络（英文版·第5版）》 The Data Link Layer</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2018/06/25/Notes/Computer%20Networks/The-Application-Layer/" title="《计算机网络（英文版·第5版）》 The Application Layer"><img class="cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-25</div><div class="title">《计算机网络（英文版·第5版）》 The Application Layer</div></div></a></div><div><a href="/2018/06/14/Notes/Computer%20Networks/The-Data-Link-Layer/" title="《计算机网络（英文版·第5版）》 The Data Link Layer"><img class="cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-14</div><div class="title">《计算机网络（英文版·第5版）》 The Data Link Layer</div></div></a></div><div><a href="/2018/06/13/Notes/Computer%20Networks/The-Introduction/" title="《计算机网络（英文版·第5版）》 The Introduction"><img class="cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-13</div><div class="title">《计算机网络（英文版·第5版）》 The Introduction</div></div></a></div><div><a href="/2018/06/14/Notes/Computer%20Networks/The-Medium-Access-Control-Sublayer/" title="《计算机网络（英文版·第5版）》 The Medium Access Control Sublayer"><img class="cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-14</div><div class="title">《计算机网络（英文版·第5版）》 The Medium Access Control Sublayer</div></div></a></div><div><a href="/2018/06/13/Notes/Computer%20Networks/The-Physical-Layer/" title="《计算机网络（英文版·第5版）》 The Physical Layer"><img class="cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-13</div><div class="title">《计算机网络（英文版·第5版）》 The Physical Layer</div></div></a></div><div><a href="/2018/06/22/Notes/Computer%20Networks/The-Transport-Layer/" title="《计算机网络（英文版·第5版）》 The Transport Layer"><img class="cover" src="https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-22</div><div class="title">《计算机网络（英文版·第5版）》 The Transport Layer</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/jckling/avatar.jpg" onerror="this.onerror=null;this.src='/img/jckling/avatar_404.png'" alt="avatar"/></div><div class="author-info__name">Jckling</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jckling"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎访问本站 🥳 <br/>评论需要审核，请不要重复提交~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">网络层设计问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8-%E8%BD%AC%E5%8F%91%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">存储-转发数据包交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%BB%99%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">提供给传输层的服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">无连接服务的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">面向连接服务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2%EF%BC%88label-switching%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">标签交换（label switching）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.</span> <span class="toc-text">虚电路与数据报网络的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">路由算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99%EF%BC%88optimality-principle%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">优化原则（optimality principle）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E9%9B%86%E6%A0%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">汇集树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">图抽象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">Dijkstra 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%8A%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">加权无向图上的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E6%B4%AA%EF%BC%88flooding%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">泛洪（flooding）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">2.3.1.</span> <span class="toc-text">用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1"><span class="toc-number">2.4.</span> <span class="toc-text">距离矢量路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-V-%E8%B7%AF%E7%94%B1%E4%BE%8B%E5%AD%90"><span class="toc-number">2.4.2.</span> <span class="toc-text">D-V 路由例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%A9%B7%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">无穷计数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">2.5.</span> <span class="toc-text">链路状态路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E9%82%BB%E5%B1%85"><span class="toc-number">2.5.1.</span> <span class="toc-text">发现邻居</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%93%BE%E8%B7%AF%E6%88%90%E6%9C%AC"><span class="toc-number">2.5.2.</span> <span class="toc-text">设置链路成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E5%8C%85"><span class="toc-number">2.5.3.</span> <span class="toc-text">构造链路状态包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E5%8C%85"><span class="toc-number">2.5.4.</span> <span class="toc-text">分发链路状态包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B4%E9%BE%84%EF%BC%88age%EF%BC%89%E5%AD%97%E6%AE%B5"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">年龄（age）字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B0%E8%B7%AF%E7%94%B1"><span class="toc-number">2.5.5.</span> <span class="toc-text">计算新路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.6.</span> <span class="toc-text">链路状态路由总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1%EF%BC%88hierarchical-hierarchy%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">层次路由（hierarchical&#x2F;hierarchy）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E8%B7%AF%E7%94%B1%EF%BC%88broadcast%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">广播路由（broadcast）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%EF%BC%88multicast%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">组播路由（multicast）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%92%AD%E8%B7%AF%E7%94%B1%EF%BC%88anycast%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">任播路由（anycast）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E4%B8%BB%E6%9C%BA%E8%B7%AF%E7%94%B1%EF%BC%88mobile-host%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">移动主机路由（mobile host）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%BB%84%E7%BB%87%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1%EF%BC%88ad-hoc-network%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">自组织网络路由（ad hoc network）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%EF%BC%88internetwork%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">网络互联（internetwork）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">3.1.</span> <span class="toc-text">网络如何不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E4%BB%A5%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">3.2.</span> <span class="toc-text">何以连接网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%A7%E9%81%93%EF%BC%88tunneling%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">隧道（tunneling）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E8%B7%AF%E7%94%B1"><span class="toc-number">3.4.</span> <span class="toc-text">互联网路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%AE%B5"><span class="toc-number">3.5.</span> <span class="toc-text">数据包分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84-MTU"><span class="toc-number">3.5.1.</span> <span class="toc-text">路径 MTU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%EF%BC%88Fragment%EF%BC%89"><span class="toc-number">3.5.2.</span> <span class="toc-text">分段（Fragment）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%88%86%E6%AE%B5"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">透明分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%8F%E6%98%8E%E5%88%86%E6%AE%B5"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">非透明分段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84-MTU-%E5%8F%91%E7%8E%B0%EF%BC%88path-MTU-discovery%EF%BC%89"><span class="toc-number">3.5.3.</span> <span class="toc-text">路径 MTU 发现（path MTU discovery）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Internet-%E7%9A%84%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">Internet 的网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv4-%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">IPv4 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">分段举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text">IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%EF%BC%88prefix%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">前缀（prefix）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9C%B0%E5%9D%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">层次化地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%EF%BC%88subnet%EF%BC%89"><span class="toc-number">4.2.3.</span> <span class="toc-text">子网（subnet）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CIDR-%E2%80%94%E2%80%94-%E6%97%A0%E7%B1%BB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1"><span class="toc-number">4.2.4.</span> <span class="toc-text">CIDR —— 无类域间路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E7%89%B9%E6%AE%8A%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.5.</span> <span class="toc-text">分配和特殊寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NAT-%E2%80%94%E2%80%94-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">NAT —— 网络地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">4.3.1.</span> <span class="toc-text">动态 IP 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-NAT%EF%BC%88RFC-3022%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">网络地址转换 NAT（RFC 3022）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E7%9A%84-IP-%E5%9C%B0%E5%9D%80%EF%BC%88reserved%EF%BC%89"><span class="toc-number">4.3.3.</span> <span class="toc-text">保留的 IP 地址（reserved）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">NAT 操作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E5%BA%94%E7%AD%94%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.5.</span> <span class="toc-text">NAT 应答问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">4.3.6.</span> <span class="toc-text">TCP 连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%BA%90%E7%AB%AF%E5%8F%A3"><span class="toc-number">4.3.7.</span> <span class="toc-text">映射源端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.8.</span> <span class="toc-text">NAT 问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv6"><span class="toc-number">4.4.</span> <span class="toc-text">IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84-IPv6-%E5%A4%B4"><span class="toc-number">4.4.1.</span> <span class="toc-text">主要的 IPv6 头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6-%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.2.</span> <span class="toc-text">IPv6 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%A4%B4"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">扩展头</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4-%E5%92%8C-IPv6-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.4.3.</span> <span class="toc-text">IPv4 和 IPv6 的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Internet-%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.</span> <span class="toc-text">Internet 控制协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP-%E2%80%94%E2%80%94-Internet-%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.1.</span> <span class="toc-text">ICMP —— Internet 控制消息协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP-%E7%9A%84%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E7%9B%AE%E7%9A%84"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">ICMP 的请求 &#x2F; 响应目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E6%B6%88%E6%81%AF"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">时间戳消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP-%E2%80%94%E2%80%94-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.2.</span> <span class="toc-text">ARP —— 地址解析协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-%E4%B8%8E-RARP"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">ARP 与 RARP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">映射问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">ARP 地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.5.2.4.</span> <span class="toc-text">ARP 包格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.5.2.5.</span> <span class="toc-text">ARP 举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP-%E2%80%94%E2%80%94-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.5.3.</span> <span class="toc-text">DHCP —— 动态主机配置协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE-TCP-IP-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">手动配置 TCP&#x2F;IP 的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-DHCP-%E6%9D%A5%E9%85%8D%E7%BD%AE-TCP-IP"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">用 DHCP 来配置 TCP&#x2F;IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BOOTP-RFC-951-1048-1084"><span class="toc-number">4.5.3.3.</span> <span class="toc-text">BOOTP RFC 951&#x2F;1048&#x2F;1084</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHCP"><span class="toc-number">4.5.3.4.</span> <span class="toc-text">DHCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BOOTP-DHCP-%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.5.3.5.</span> <span class="toc-text">BOOTP&#x2F;DHCP 消息格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2%E5%92%8C-MPLS"><span class="toc-number">4.6.</span> <span class="toc-text">标签交换和 MPLS *</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.6.1.</span> <span class="toc-text">2.5 层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSPF-%E2%80%94%E2%80%94-%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.7.</span> <span class="toc-text">OSPF —— 内部网关路由协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Internet-%E4%B8%8A%E7%9A%84%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.7.1.</span> <span class="toc-text">Internet 上的内部网关协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82"><span class="toc-number">4.7.2.</span> <span class="toc-text">设计要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BGP-%E2%80%94%E2%80%94-%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.8.</span> <span class="toc-text">BGP —— 边界网关路由协议*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E6%94%BF%E7%AD%96"><span class="toc-number">4.8.1.</span> <span class="toc-text">BGP 政策</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5"><span class="toc-number">4.8.2.</span> <span class="toc-text">路由策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E5%9F%BA%E7%A1%80"><span class="toc-number">4.8.3.</span> <span class="toc-text">BGP 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP-%E8%B7%AF%E7%94%B1%E9%80%9A%E5%91%8A%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">4.8.4.</span> <span class="toc-text">BGP 路由通告的传播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%A6%82%E4%BD%95%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E6%9D%A1%E8%B7%AF%E7%94%B1"><span class="toc-number">4.8.5.</span> <span class="toc-text">路由器如何为每个目的地选择使用哪条路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Internet-%E7%BB%84%E6%92%AD"><span class="toc-number">4.9.</span> <span class="toc-text">Internet 组播*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-RFC-3376"><span class="toc-number">4.9.1.</span> <span class="toc-text">IGMP (RFC 3376)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PIM"><span class="toc-number">4.9.2.</span> <span class="toc-text">PIM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8-IP"><span class="toc-number">4.10.</span> <span class="toc-text">移动 IP *</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/" title="Datalog 引擎 Soufflé 指南"><img src="https://i.loli.net/2021/06/14/oSn9dxfYhEHClIe.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Datalog 引擎 Soufflé 指南"/></a><div class="content"><a class="title" href="/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/" title="Datalog 引擎 Soufflé 指南">Datalog 引擎 Soufflé 指南</a><time datetime="2021-11-22T11:01:43.000Z" title="发表于 2021-11-22 19:01:43">2021-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪"><img src="https://i.loli.net/2021/06/14/bk5UlhqE4DZJfYu.png" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="CVE-2020-12691 漏洞利用相关信息追踪"/></a><div class="content"><a class="title" href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪">CVE-2020-12691 漏洞利用相关信息追踪</a><time datetime="2021-11-05T07:25:15.000Z" title="发表于 2021-11-05 15:25:15">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/" title="LogiQL 入门"><img src="https://developer.logicblox.com/wp-content/uploads/2017/12/prod-bg-panelfour.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="LogiQL 入门"/></a><div class="content"><a class="title" href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/" title="LogiQL 入门">LogiQL 入门</a><time datetime="2021-10-26T08:15:05.000Z" title="发表于 2021-10-26 16:15:05">2021-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Gadget Inspector 源码解析"><img src="https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Gadget Inspector 源码解析"/></a><div class="content"><a class="title" href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Gadget Inspector 源码解析">Gadget Inspector 源码解析</a><time datetime="2021-10-12T03:41:30.000Z" title="发表于 2021-10-12 11:41:30">2021-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/" title="Python 爬取 twitter 数据"><img src="https://about.twitter.com/content/dam/about-twitter/en/brand-toolkit/brand-banner-desktop.jpg.twimg.1920.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Python 爬取 twitter 数据"/></a><div class="content"><a class="title" href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/" title="Python 爬取 twitter 数据">Python 爬取 twitter 数据</a><time datetime="2021-10-11T10:44:50.000Z" title="发表于 2021-10-11 18:44:50">2021-10-11</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1035234274961147" data-ad-slot="8787224657" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/06/14/z9KUc1FV7eaD8pi.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jckling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comments-puce.vercel.app',
      avatar: 'retro',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, {"emoji":"https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji"}))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>