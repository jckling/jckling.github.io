<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OpenStack Nova 架构及源码分析 | Jckling's Blog</title><meta name="keywords" content="Python"><meta name="author" content="Jckling"><meta name="copyright" content="Jckling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Victoria 版本 Nova 整体架构概览，源码阅读，启动流程分析">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenStack Nova 架构及源码分析">
<meta property="og:url" content="https://jckling.github.io/2021/05/23/OpenStack/OpenStack%20Nova/index.html">
<meta property="og:site_name" content="Jckling&#39;s Blog">
<meta property="og:description" content="Victoria 版本 Nova 整体架构概览，源码阅读，启动流程分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/14/NfcmdhT7uUx4pqo.jpg">
<meta property="article:published_time" content="2021-05-23T08:40:09.000Z">
<meta property="article:modified_time" content="2021-11-23T14:04:58.781Z">
<meta property="article:author" content="Jckling">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/14/NfcmdhT7uUx4pqo.jpg"><link rel="shortcut icon" href="/img/jckling/favicon.ico"><link rel="canonical" href="https://jckling.github.io/2021/05/23/OpenStack/OpenStack%20Nova/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google_site_verification" content="pZZt69mo0ndoxIJ1vjEe830lXbvD26aiVAZ-k0FWM5k"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?20b7797c0b5f4e821c1449cd4c6c98c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-164555720-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-164555720-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OpenStack Nova 架构及源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-23 22:04:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Jckling's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/jckling/avatar.jpg" onerror="onerror=null;src='/img/jckling/avatar_404.png'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/14/NfcmdhT7uUx4pqo.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jckling's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OpenStack Nova 架构及源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-05-23T08:40:09.000Z" title="undefined 2021-05-23 16:40:09">2021-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OpenStack/">OpenStack</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OpenStack Nova 架构及源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/05/23/OpenStack/OpenStack%20Nova/#post-comment"><span class="waline-comment-count" id="/2021/05/23/OpenStack/OpenStack%20Nova/"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><ul>
<li>nova 和其他组件之间的交互使用 HTTP 请求</li>
<li>内部组件之间使用 <a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 库实现 RPC 调用，这里还涉及消息队列 RabbitMQ ，遵循 AMQP 协议</li>
<li>大部分 nova 组件都可以运行在多个服务器上，然后使用一个管理器监听 RPC 消息</li>
<li>而 nova-compute 是运行在计算主机上的单进程，用于管理计算资源</li>
<li>nova 内部组件共享本地数据库，通过对象层访问，确保兼容性和安全性<ul>
<li>nova-compute 访问数据库由 nova-conductor 代理</li>
</ul>
</li>
</ul>
<img src="https://i.loli.net/2021/06/06/K51XMdUyPrRmupT.png">

<p>当用户发起一个新的请求时，该请求会先在 nova-api 中处理。nova-api 会对请求进行一系列检查，包括请求是否合法，配额是否足够等；当检查用过后，nova-api 就会为该请求分配一个唯一的虚拟机 ID ，并在数据库中新建对应的项来记录虚拟机的状态；然后，nova-api 会将请求发送给 nova-conductor 处理。</p>
<p>nova-conductor 主要管理服务之间的通信并进行任务处理。它在接收到请求之后，会为 nova-scheduler 创建一个 RequestSpec 对象用来包装与调度相关的所有请求信息，然后调用 nova-scheduler 服务的 select_destination 接口。</p>
<p>nova-scheduler 通过接收到的 RequestSpec 对象，首先将 RequestSpec  对象转换成 ResourceRequest 对象，并将该对象发送给 Placement 进行一次预筛选，然后会根据数据库中最新的系统状态做出调度决定，并告诉 nova-conductor 把该请求调度到合适的计算节点上。</p>
<p>nova-conductor 在得知调度决定后，会把请求发送给对应的 nova-compute 服务。</p>
<p>每个 nova-compute 服务都有独立的资源监视器（Resource Tracker）用来监视本地主机的资源使用情况。当计算节点接收到请求时，资源监视器能够检查主机是否有足够的资源。</p>
<ul>
<li>如果对应的资源足够，nova-compute 就会允许在当前主机中启动所要求的虚拟机，并在数据库中更新虚拟机状态，同时将最新的主机资源情况更新到数据库</li>
<li>如果当前主机不符合请求的资源要求，nova-compute 会拒绝启动虚拟机，并将请求重新发给 nova-conductor 服务，重试整个调度过程</li>
</ul>
<img src="https://i.loli.net/2021/06/06/DizGwcpYRQhWKqS.jpg">

<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><ol>
<li><p>nova-api</p>
<p>接受和响应用户的计算 API 调用</p>
</li>
<li><p>nova-api-metadata</p>
<p> 接受来自实例的元数据请求</p>
<p> <a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></p>
</li>
<li><p>nova-compute</p>
<p> 通过 hypervisor API 创建和终止虚拟机实例的守护进程。例如 KVM/QEMU 的 libvirt、VMware 的 VMwareAPI 。</p>
<p> 运行在它所管理的 hypervisor 机器上，管理与虚拟机管理程序和虚拟机的通信。</p>
</li>
<li><p>nova-scheduler</p>
<p> 从消息队列中获取虚拟机实例请求，并决定在哪个服务器上运行。</p>
</li>
<li><p>nova-conductor</p>
<p> 处理需要协调的请求（构建/调整）、充当数据库代理或处理对象转换。用于连接 nova-api、nova-scheduler、nova-compute 服务。</p>
</li>
<li><p>nova-novncproxy</p>
<p> 协调 nova-compute 服务和数据库之间的交互。避免 nova-compute 直接访问数据库，为了提供更好的 API 兼容性。建议不要部署在 nova-compute 服务所在的节点上。</p>
</li>
<li><p>nova-spicehtml5proxy</p>
<p> 提供通过 SPICE 连接访问运行实例的代理，支持基于浏览器的 HTML5 客户端。</p>
</li>
<li><p>The queue</p>
<p> 在守护进程之间传递消息的中央消息队列，通常使用 RabbitMQ 。</p>
</li>
<li><p>SQL database</p>
<p> 存储云基础设施的大多数构建时和运行时状态，包括：可用的实例类型、在使用的实例、可用的网络、项目。</p>
</li>
</ol>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>消息代理（RabbitMQ AMQP broker）允许 nova 内部组件以低耦合的方式进行通信，建立在发布/订阅（publish/subscribe）模式上</p>
<ul>
<li>解耦客户端和服务端</li>
<li>同步客户端和服务端</li>
<li>平衡远程调用</li>
</ul>
<p>nova 使用 AMQP 中的直连（direct）、扇型（fanout）、主题（topic）交换；</p>
<p>nova 使用适配器类（adapter）将消息封装和解封从而调用函数，实现了两种 RPC 调用</p>
<ul>
<li><code>rpc.call</code>：请求 + 响应，api 作为消费者（consumer）</li>
<li><code>rpc.cast</code>：单向，api 作为发布者（publisher）</li>
</ul>
<p>每个 nova 服务在初始化时创建两个队列</p>
<ul>
<li>接受路由键 <code>NODE-TYPE.NODE-ID</code>（例如，<code>compute.hostname</code>）：nova-api 需要重定向到特定节点</li>
<li>接受路由键 <code>NODE-TYPE</code>（例如，<code>compute</code>）：</li>
</ul>
<img src="https://i.loli.net/2021/06/06/ZvNb61tfPTlF9or.png">

<p>每个 nova 内部组件都连接到消息代理，根据不同的作用，把消息队列作为：</p>
<ul>
<li>调用者（Invoker）：nova-api、nova-scheduler；通过 <code>rpc.call</code> 和 <code>rpc.cast</code> 向消息队列发送消息</li>
<li>工作者（Worker）：nova-compute；从消息队列接收消息，根据 <code>rpc.call</code> 进行响应</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>主题发布者（Topic Publisher）</strong></p>
<p>执行 <code>rpc.call</code> 或 <code>rpc.cast</code> 操作将实例化一个主题发布者，用于将消息发送到消息队列。每个发布者总是连接到相同的主题交换机（topic-based exchange）；生命周期仅限于消息传递。</p>
<p><strong>直连消费者（Direct Consumer）</strong></p>
<p>执行 <code>rpc.call</code> 操作将实例化一个直连消费者，用于从消息队列接收响应消息。每个消费者连接到唯一的直连交换机（direct-based exchange）；生命周期仅限于消息传递。</p>
<p><strong>主题消费者（Topic Consumer）</strong></p>
<p>当工作者被实例化后将实例化一个主题消费者，并存在于工作者的整个生命周期；主题消费者用于从消息队列接收消息，并调用工作者定义的操作。主题消费者通过共享/排他队列（shared/exclusive queue）连接到相同的主体交换机。每个工作者都有两个主题消费者，一个处理 <code>rpc.cast</code>  ，连接到交换键是 <code>topic</code> 的共享队列；另一个处理 <code>rpc.call</code> ，连接到交换键是 <code>topic.host</code> 的独立队列。</p>
<p><strong>直连发布者（Direct Publisher）</strong></p>
<p>执行 <code>rpc.call</code> 操作将实例化一个直连发布者，用于返回请求/响应操作所需的消息，连接到直连交换机。</p>
<p><strong>主题交换机（Topic Exchange）</strong></p>
<p>存在于虚拟机上下文中的路由表；类型（主题/直连）决定了路由策略；对于 nova 中的每个主题，消息代理节点只有一个主题交换机。</p>
<p><strong>直连交换机（Direct Exchange）</strong></p>
<p>在 <code>rpc.call</code> 操作中创建的路由表，消息代理节点的生命周期中有许多该实例，对应每个 <code>rpc.call</code> 调用。</p>
<p><strong>队列元素（Queue Element）</strong></p>
<p>消息桶，消息一直保存在队列中，直到消费者（主题/直连）连接到队列获取消息。队列可以是共享的也可以是独立的；路由键是 <code>topic</code> 的队列在相同类型的工作者中共享。</p>
<h2 id="rpc-call"><a href="#rpc-call" class="headerlink" title="rpc.call"></a>rpc.call</h2><ol>
<li><p>实例化主题发布者，将请求发送到消息队列；在发布操作之前，实例化直连消费者等待响应信息</p>
</li>
<li><p>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic.host</code>）指定的主题消费者获取，并传递给负责该任务的工作者</p>
</li>
<li><p>任务完成后，将分配一个直连发布者将响应消息发送到消息队列</p>
</li>
<li><p>一旦消息被交换器分派，它就会被路由键（例如，<code>msg_id</code>）指定的直连消费者获取，并传递给调用者</p>
</li>
</ol>
<img src="https://i.loli.net/2021/06/06/ApK1vCySXhQE3mW.png">

<h2 id="rpc-cast"><a href="#rpc-cast" class="headerlink" title="rpc.cast"></a>rpc.cast</h2><ol>
<li><p> 实例化主题发布者，将请求发送到消息队列</p>
</li>
<li><p> 一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic</code>）指定的主题消费者获取，并传递给负责该任务的工作者</p>
</li>
</ol>
<img src="https://i.loli.net/2021/06/06/3nUaoMlKdHg9BQv.png">

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>从 github 下载 Victoria 版本的 Nova 源码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/openstack/nova.git --branch stable/victoria --single-branch</span><br></pre></td></tr></table></figure>

<p>nova/ 文件夹下的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">accelerator/    <span class="comment"># Cyborg 加速器</span></span><br><span class="line">api/            <span class="comment"># Nova API 服务</span></span><br><span class="line">cmd/            <span class="comment"># 各个 Nova 服务的入口程序</span></span><br><span class="line">compute/        <span class="comment"># Nova Compute 服务</span></span><br><span class="line">conductor/      <span class="comment"># Nova Conductor 服务</span></span><br><span class="line">conf/           <span class="comment"># 所有的配置选项</span></span><br><span class="line">console/        <span class="comment"># nova-console 服务</span></span><br><span class="line">db/             <span class="comment"># 封装数据库操作</span></span><br><span class="line">hacking/        <span class="comment"># 编码规范检查</span></span><br><span class="line">image/          <span class="comment"># 封装镜像操作，Glance 接口抽象</span></span><br><span class="line">keymgr/         <span class="comment"># 密钥管理器实现</span></span><br><span class="line">locale/         <span class="comment"># 国际化相关文件</span></span><br><span class="line">network/        <span class="comment"># nova-network 服务</span></span><br><span class="line">notifications/  <span class="comment"># 通知相关功能</span></span><br><span class="line">objects/        <span class="comment"># 封装实体对象的 CURD 操作</span></span><br><span class="line">pci/            <span class="comment"># PCI/SR-IOV 支持</span></span><br><span class="line">policies/       <span class="comment"># 所有 Policy 的默认规则</span></span><br><span class="line">privsep/        <span class="comment"># oslo_privsep 相关</span></span><br><span class="line">scheduler/      <span class="comment"># Nova Scheduler 服务</span></span><br><span class="line">servicegroup/   <span class="comment"># 成员服务（membership），服务组</span></span><br><span class="line">storage/        <span class="comment"># Ceph 存储支持</span></span><br><span class="line">tests/          <span class="comment"># 单元测试</span></span><br><span class="line">virt/           <span class="comment"># 支持的 hypervisor 驱动</span></span><br><span class="line">volume/         <span class="comment"># 封装卷访问接口，Cinder 接口抽象</span></span><br></pre></td></tr></table></figure>

<p>nova/ 文件夹下的 python 文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">availability_zones.py   <span class="comment"># 区域设置的工具函数</span></span><br><span class="line">baserpc.py              <span class="comment"># 基础 RPC 客户端/服务端实现</span></span><br><span class="line">block_device.py         <span class="comment"># 块设备映射</span></span><br><span class="line">cache_utils.py          <span class="comment"># oslo_cache 封装</span></span><br><span class="line">config.py               <span class="comment"># 解析命令行参数</span></span><br><span class="line">context.py              <span class="comment"># 贯穿 Nova 的所有请求的上下文</span></span><br><span class="line">crypto.py               <span class="comment"># 包装标准加密数据元素</span></span><br><span class="line">debugger.py             <span class="comment"># pydev 调试</span></span><br><span class="line">exception.py            <span class="comment"># 基础异常类</span></span><br><span class="line">exception_wrapper.py    <span class="comment"># 封装异常类</span></span><br><span class="line">filters.py              <span class="comment"># 基础过滤器</span></span><br><span class="line">i18n.py                 <span class="comment"># 集成 oslo_i18n</span></span><br><span class="line">loadables.py            <span class="comment"># 可加载类</span></span><br><span class="line">manager.py              <span class="comment"># 基础 Manager 类</span></span><br><span class="line">middleware.py           <span class="comment"># 更新 oslo_middleware 的默认配置选项</span></span><br><span class="line">monkey_patch.py         <span class="comment"># eventlet 猴子补丁</span></span><br><span class="line">policy.py               <span class="comment"># 策略引擎</span></span><br><span class="line">profiler.py             <span class="comment"># 调用 OSProfiler</span></span><br><span class="line">quota.py                <span class="comment"># 每个项目的资源配额</span></span><br><span class="line">rpc.py                  <span class="comment"># RPC 操作相关的工具函数</span></span><br><span class="line">safe_utils.py           <span class="comment"># 不会导致循环导入的工具函数</span></span><br><span class="line">service.py              <span class="comment"># 通用节点基类，用于在主机上运行的所有工作者</span></span><br><span class="line">service_auth.py         <span class="comment"># 身份认证插件</span></span><br><span class="line">test.py                 <span class="comment"># 单元测试基础类</span></span><br><span class="line">utils.py                <span class="comment"># 工具函数</span></span><br><span class="line">version.py              <span class="comment"># 版本号管理</span></span><br><span class="line">weights.py              <span class="comment"># 权重插件</span></span><br><span class="line">wsgi.py                 <span class="comment"># 管理 WSGI 应用的服务器类</span></span><br></pre></td></tr></table></figure>

<p>setup.cfg 配置文件，<code>[entry_points]</code> 小节指定了 nova 各个组件入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console_scripts &#x3D;</span><br><span class="line">    nova-api &#x3D; nova.cmd.api:main</span><br><span class="line">    nova-api-metadata &#x3D; nova.cmd.api_metadata:main</span><br><span class="line">    nova-api-os-compute &#x3D; nova.cmd.api_os_compute:main</span><br><span class="line">    nova-compute &#x3D; nova.cmd.compute:main</span><br><span class="line">    nova-conductor &#x3D; nova.cmd.conductor:main</span><br><span class="line">    nova-manage &#x3D; nova.cmd.manage:main</span><br><span class="line">    nova-novncproxy &#x3D; nova.cmd.novncproxy:main</span><br><span class="line">    nova-policy &#x3D; nova.cmd.policy:main</span><br><span class="line">    nova-rootwrap &#x3D; oslo_rootwrap.cmd:main</span><br><span class="line">    nova-rootwrap-daemon &#x3D; oslo_rootwrap.cmd:daemon</span><br><span class="line">    nova-scheduler &#x3D; nova.cmd.scheduler:main</span><br><span class="line">    nova-serialproxy &#x3D; nova.cmd.serialproxy:main</span><br><span class="line">    nova-spicehtml5proxy &#x3D; nova.cmd.spicehtml5proxy:main</span><br><span class="line">    nova-status &#x3D; nova.cmd.status:main</span><br><span class="line">wsgi_scripts &#x3D;</span><br><span class="line">    nova-api-wsgi &#x3D; nova.api.openstack.compute.wsgi:init_application</span><br><span class="line">    nova-metadata-wsgi &#x3D; nova.api.metadata.wsgi:init_application</span><br></pre></td></tr></table></figure>

<h2 id="nova-api"><a href="#nova-api" class="headerlink" title="nova-api"></a>nova-api</h2><p>nova-api 对外提供 RESTful API，没有对内的 RPC 。</p>
<p>nova/api/ 目录结构</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">auth.py             <span class="comment"># 身份认证中间件</span></span><br><span class="line">compute_req_id.py   <span class="comment"># x-compute-request-id 中间件（oslo_middleware）</span></span><br><span class="line">metadata/           <span class="comment"># Metadata API</span></span><br><span class="line">openstack/          <span class="comment"># Nova v2.1 API</span></span><br><span class="line">validation/         <span class="comment"># 请求体验证</span></span><br><span class="line">wsgi.py             <span class="comment"># WSGI 原语（请求、应用、中间件、路由、加载器）</span></span><br></pre></td></tr></table></figure>

<p>openstack 目录中包含 WSGI 基础架构的代码，一些 WSGI 中间件，以及如何解析请求与分发请求的核心代码。</p>
<p>nova/api/openstack/compute/ 包含 Controller 实现，Resource 对象将 API 映射到相应的 Controller 方法上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">api_version_request.py  <span class="comment"># 版本验证</span></span><br><span class="line">auth.py                 <span class="comment"># noauth 中间件</span></span><br><span class="line">common.py               <span class="comment"># 信息查询的工具函数</span></span><br><span class="line">compute/                <span class="comment"># 每个 API 的入口点</span></span><br><span class="line">identity.py             <span class="comment"># 验证项目是否存在</span></span><br><span class="line">requestlog.py           <span class="comment"># 请求日志中间件</span></span><br><span class="line">urlmap.py               <span class="comment"># url 映射</span></span><br><span class="line">versioned_method.py     <span class="comment"># 版本信息</span></span><br><span class="line">wsgi.py                 <span class="comment"># WSGI 相关抽象类</span></span><br><span class="line">wsgi_app.py             <span class="comment"># WSGI 应用程序初始化方法</span></span><br></pre></td></tr></table></figure>

<h3 id="API-请求路由"><a href="#API-请求路由" class="headerlink" title="API 请求路由"></a>API 请求路由</h3><p>nova-api 读取 etc/nova/api-paste.ini 并加载 WSGI 程序，最终 API 入口点都位于 nova.api.openstack.compute 中</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[composite:osapi_compute]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions                # version API</span><br><span class="line">/v2: oscomputeversion_legacy_v2     # v2 API</span><br><span class="line">/v2.1: oscomputeversion_v2          # v2.1 API</span><br><span class="line"><span class="comment"># v21 is an exactly feature match for v2, except it has more stringent</span></span><br><span class="line"><span class="comment"># input validation on the wsgi surface (prevents fuzzing early on the</span></span><br><span class="line"><span class="comment"># API). It also provides new features via API microversions which are</span></span><br><span class="line"><span class="comment"># opt into for clients. Unaware clients will receive the same frozen</span></span><br><span class="line"><span class="comment"># v2 API feature set, but with some relaxed validation</span></span><br><span class="line">/v2/+: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1/+: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[composite:openstack_compute_api_v21]</span></span><br><span class="line"><span class="attr">use</span> = call:nova.api.auth:pipeline_factory_v21       <span class="comment"># 加载中间件</span></span><br><span class="line"><span class="attr">keystone</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"><span class="comment"># DEPRECATED: The [api]auth_strategy conf option is deprecated and will be</span></span><br><span class="line"><span class="comment"># removed in a subsequent release, whereupon this pipeline will be unreachable.</span></span><br><span class="line"><span class="attr">noauth2</span> = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler noauth2 osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line"><span class="section">[app:osapi_compute_app_v21]</span></span><br><span class="line"><span class="attr">paste.app_factory</span> = nova.api.openstack.compute:APIRouterV21.factory  <span class="comment"># 入口</span></span><br></pre></td></tr></table></figure>

<p>nova/api/openstack/compute/routes.py 中的 APIRouterV21 主要用来完成路由规则的创建，其中 ROUTE_LIST 保存了 URL 与 Controller 之间的映射关系。</p>
<p>APIRouterV21 基于 ROUTE_LIST，使用 Routes 模块作为 URL 映射的工具，将各个模块所实现的 API 对应的 URL 注册到 mapper 中，并把每个资源都封装成 nova.api.openstack.wsgi.Resource 对象，当解析 URL 请求时，可以通过 URL 映射找到 API 对应的 Resource 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Router 类对 WSGI routes 模块进行了简单的封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIRouterV21</span>(<span class="params">base_wsgi.Router</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Routes requests on the OpenStack API to the appropriate controller</span></span><br><span class="line"><span class="string">    and method. The URL mapping based on the plain list `ROUTE_LIST` is built</span></span><br><span class="line"><span class="string">    at here.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, custom_routes=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;:param custom_routes: the additional routes can be added by this</span></span><br><span class="line"><span class="string">               parameter. This parameter is used to test on some fake routes</span></span><br><span class="line"><span class="string">               primarily.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(APIRouterV21, self).__init__(nova.api.openstack.ProjectMapper())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> custom_routes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            custom_routes = <span class="built_in">tuple</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> path, methods <span class="keyword">in</span> ROUTE_LIST + custom_routes:</span><br><span class="line">            <span class="comment"># NOTE(alex_xu): The variable &#x27;methods&#x27; is a dict in normal, since</span></span><br><span class="line">            <span class="comment"># the dict includes all the methods supported in the path. But</span></span><br><span class="line">            <span class="comment"># if the variable &#x27;method&#x27; is a string, it means a redirection.</span></span><br><span class="line">            <span class="comment"># For example, the request to the &#x27;&#x27; will be redirect to the &#x27;/&#x27; in</span></span><br><span class="line">            <span class="comment"># the Nova API. To indicate that, using the target path instead of</span></span><br><span class="line">            <span class="comment"># a dict. The route entry just writes as &quot;(&#x27;&#x27;, &#x27;/)&quot;.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(methods, six.string_types):</span><br><span class="line">                self.<span class="built_in">map</span>.redirect(path, methods)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> method, controller_info <span class="keyword">in</span> methods.items():</span><br><span class="line">                <span class="comment"># TODO(alex_xu): In the end, I want to create single controller</span></span><br><span class="line">                <span class="comment"># instance instead of create controller instance for each</span></span><br><span class="line">                <span class="comment"># route.</span></span><br><span class="line">                controller = controller_info[<span class="number">0</span>]()</span><br><span class="line">                action = controller_info[<span class="number">1</span>]</span><br><span class="line">                self.<span class="built_in">map</span>.create_route(path, method, controller, action)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factory</span>(<span class="params">cls, global_config, **local_config</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Simple paste factory, :class:`nova.wsgi.Router` doesn&#x27;t have one.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> cls()</span><br></pre></td></tr></table></figure>

<p>nova/api/wsgi.py 解析 URL 映射，通过 _dispatch 回调，调用 Resource 对象的 __call__ 方法，最终通过请求调用 API 对应的模块中的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路由</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;WSGI middleware that maps incoming requests to WSGI apps.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mapper</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a router for the given routes.Mapper.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Each route in `mapper` must specify a &#x27;controller&#x27;, which is a</span></span><br><span class="line"><span class="string">        WSGI app to call.  You&#x27;ll probably want to specify an &#x27;action&#x27; as</span></span><br><span class="line"><span class="string">        well and have your controller be an object that can route</span></span><br><span class="line"><span class="string">        the request to the action-specific method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">          mapper = routes.Mapper()</span></span><br><span class="line"><span class="string">          sc = ServerController()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Explicit mapping of one route to a controller+action</span></span><br><span class="line"><span class="string">          mapper.connect(None, &#x27;/svrlist&#x27;, controller=sc, action=&#x27;list&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Actions are all implicitly defined</span></span><br><span class="line"><span class="string">          mapper.resource(&#x27;server&#x27;, &#x27;servers&#x27;, controller=sc)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          # Pointing to an arbitrary WSGI app.  You can specify the</span></span><br><span class="line"><span class="string">          # &#123;path_info:.*&#125; parameter so the target app can be handed just that</span></span><br><span class="line"><span class="string">          # section of the URL.</span></span><br><span class="line"><span class="string">          mapper.connect(None, &#x27;/v1.0/&#123;path_info:.*&#125;&#x27;, controller=BlogApp())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">map</span> = mapper</span><br><span class="line">        <span class="comment"># 使用 routes 模块关联 mapper 和 _dispatch</span></span><br><span class="line">        <span class="comment"># routes.middleware.RoutesMiddleware 设置 environ 信息</span></span><br><span class="line">        self._router = routes.middleware.RoutesMiddleware(self._dispatch,</span><br><span class="line">                                                          self.<span class="built_in">map</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @webob.dec.wsgify(<span class="params">RequestClass=Request</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, req</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Route the incoming request to a controller based on self.map.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If no match, return a 404.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 根据 mapper 将请求路由到 WSGI 应用（资源）</span></span><br><span class="line">        <span class="comment"># 每个资源会在 __call__ 方法中根据 HTTP 请求的 URL 路由到对应 Controller 上的方法（Action）</span></span><br><span class="line">        <span class="keyword">return</span> self._router</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @webob.dec.wsgify(<span class="params">RequestClass=Request</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dispatch</span>(<span class="params">req</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Dispatch the request to the appropriate controller.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Called by self._router after matching the incoming request to a route</span></span><br><span class="line"><span class="string">        and putting the information into req.environ.  Either returns 404</span></span><br><span class="line"><span class="string">        or the routed WSGI app&#x27;s response.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 根据 HTTP 请求的 environ 信息找到 URL 对应的 Controller</span></span><br><span class="line">        match = req.environ[<span class="string">&#x27;wsgiorg.routing_args&#x27;</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:</span><br><span class="line">            <span class="keyword">return</span> webob.exc.HTTPNotFound()</span><br><span class="line">        app = match[<span class="string">&#x27;controller&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<h3 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a>API 实现</h3><p>nova/api/openstack/compute/ 目录包含每个 API 对应的 Controller 实现，Resource 对象将请求的 API 映射到相应的 Controller 方法上。</p>
<p>以 keypairs.py （密钥对管理扩展）为例，公共方法包含 create、delete、show、index，多个实现对应不同的 Microversion（使用 <code>@wsgi.Controller.api_version</code> 装饰器）</p>
<ul>
<li><code>@wsgi.expected_errors</code>：API 允许的错误返回码</li>
<li><code>@validation.query_schema</code>：请求对应的 json schema</li>
<li><code>@wsgi.response</code>：API 请求正常返回码</li>
<li><code>@wsgi.action</code>：注册 action</li>
</ul>
<p>Microversion 用于实现兼容性。</p>
<p>nova/api/openstack/compute/schemas 包含允许的 json schema，表示接受的键值对及其类型。</p>
<p>通过方法接口可以得到 webob.Request 对象，从 Request 对象中可以获取其他请求参数，用于执行对应的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeypairController</span>(<span class="params">wsgi.Controller</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Keypair API controller for the OpenStack API.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _view_builder_class = keypairs_view.ViewBuilder</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(KeypairController, self).__init__()</span><br><span class="line">        self.api = compute_api.KeypairAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wsgi.Controller.api_version(<span class="params"><span class="string">&quot;2.10&quot;</span></span>)</span></span><br><span class="line"><span class="meta">    @wsgi.response(<span class="params"><span class="number">201</span></span>)</span></span><br><span class="line"><span class="meta">    @wsgi.expected_errors(<span class="params">(<span class="params"><span class="number">400</span>, <span class="number">403</span>, <span class="number">409</span></span>)</span>)</span></span><br><span class="line"><span class="meta">    @validation.schema(<span class="params">keypairs.create_v210</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, req, body</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wsgi.Controller.api_version(<span class="params"><span class="string">&quot;2.2&quot;</span>, <span class="string">&quot;2.9&quot;</span></span>)  </span><span class="comment"># noqa</span></span><br><span class="line"><span class="meta">    @wsgi.response(<span class="params"><span class="number">201</span></span>)</span></span><br><span class="line"><span class="meta">    @wsgi.expected_errors(<span class="params">(<span class="params"><span class="number">400</span>, <span class="number">403</span>, <span class="number">409</span></span>)</span>)</span></span><br><span class="line"><span class="meta">    @validation.schema(<span class="params">keypairs.create_v22</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, req, body</span>):</span>  <span class="comment"># noqa</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h2 id="nova-conductor"><a href="#nova-conductor" class="headerlink" title="nova-conductor"></a>nova-conductor</h2><p>使用 RPC 的子组件通常包含以下文件：</p>
<ul>
<li>api.py 对 RPC 接口进行封装，类似提供 SDK</li>
<li>rpcapi.py 暴露给其他内部组件的 RPC 接口，RPC 客户端</li>
<li>manager.py 处理 RPC API 调用</li>
</ul>
<p>nova-compute 访问数据库的操作都要由 nova-conductor 代理，用 nova/conductor/manager.py 的 ConductorManager 类完成，出于安全性考虑，nova-conductor 和 nova-compute 不能部署在同一服务器上。</p>
<p>nova/objects 定义了 nova object，封装数据库 CURD 操作，每个类对应数据库中的一张表。</p>
<h2 id="nova-scheduler"><a href="#nova-scheduler" class="headerlink" title="nova-scheduler"></a>nova-scheduler</h2><p>nova-scheduler 执行调度决策，nova-compute 收集并更新主机数据，实时写入数据库（周期任务）。</p>
<p>nova/scheduler/filters 包含所有的过滤器实现，用于过滤不符合条件的主机；nova/scheduler/weights 包含所有的权重实现，用于计算权重并排序。</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p><strong>nova-api</strong> 启动入口 <code>nova.cmd.api:main</code></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    config.parse_args(sys.argv) <span class="comment"># 解析参数</span></span><br><span class="line">    logging.setup(CONF, <span class="string">&quot;nova&quot;</span>) <span class="comment"># 设置日志</span></span><br><span class="line">    objects.register_all()      <span class="comment"># 注册 nova object</span></span><br><span class="line">    gmr_opts.set_defaults(CONF) <span class="comment"># 设置 oslo_reports</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;osapi_compute&#x27;</span> <span class="keyword">in</span> CONF.enabled_apis:</span><br><span class="line">        <span class="comment"># NOTE(mriedem): This is needed for caching the nova-compute service</span></span><br><span class="line">        <span class="comment"># version.</span></span><br><span class="line">        objects.Service.enable_min_version_cache()</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成报告的机制 Guru Meditation Report (GMR)</span></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># oslo_service.ProcessLauncher</span></span><br><span class="line">    launcher = service.process_launcher()</span><br><span class="line">    started = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 根据 paste-ini 文件创建 WSGI 应用</span></span><br><span class="line">    <span class="keyword">for</span> api <span class="keyword">in</span> CONF.enabled_apis:</span><br><span class="line">        should_use_ssl = api <span class="keyword">in</span> CONF.enabled_ssl_apis</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># nova.service.WSGIService 初始化 WSGI 程序</span></span><br><span class="line">            server = service.WSGIService(api, use_ssl=should_use_ssl)</span><br><span class="line">            <span class="comment"># oslo_service.ProcessLauncher 创建子进程启动服务</span></span><br><span class="line">            launcher.launch_service(server, workers=server.workers <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line">            started += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> exception.PasteAppNotFound <span class="keyword">as</span> ex:</span><br><span class="line">            log.warning(<span class="string">&quot;%s. ``enabled_apis`` includes bad values. &quot;</span></span><br><span class="line">                        <span class="string">&quot;Fix to remove this warning.&quot;</span>, ex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> started == <span class="number">0</span>:</span><br><span class="line">        log.error(<span class="string">&#x27;No APIs were started. &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;Check the enabled_apis config option.&#x27;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子进程终止</span></span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure>

<p>nova.service.WSGIService 的初始化函数实例化 nova.wsgi.Server ，启动函数实际调用了 nova.wsgi.Server 的 start 方法。</p>
<p>其中的 self._socket 使用 <code>eventlet.listen</code> 创建，最后使用 utils 中封装的 spawn 函数启动 WSGI 程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>(<span class="params">service.ServiceBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Server class to manage a WSGI server, serving a WSGI application.&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start serving a WSGI application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :returns: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># The server socket object will be closed after server exits,</span></span><br><span class="line">        <span class="comment"># but the underlying file descriptor will remain open, and will</span></span><br><span class="line">        <span class="comment"># give bad file descriptor error. So duplicating the socket object,</span></span><br><span class="line">        <span class="comment"># to keep file descriptor usable.</span></span><br><span class="line"></span><br><span class="line">        dup_socket = self._socket.dup()</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># sockets can hang around forever without keepalive</span></span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_KEEPALIVE, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        self._server = utils.spawn(**wsgi_kwargs)</span><br></pre></td></tr></table></figure>

<p><strong>nova-conductor</strong> 启动入口 <code>nova.cmd.conductor:main</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, <span class="string">&quot;nova&quot;</span>)</span><br><span class="line">    objects.register_all()</span><br><span class="line">    gmr_opts.set_defaults(CONF)</span><br><span class="line">    objects.Service.enable_min_version_cache()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># nova.service.Service 实例化 Service 对象</span></span><br><span class="line">    server = service.Service.create(binary=<span class="string">&#x27;nova-conductor&#x27;</span>,</span><br><span class="line">                                    topic=rpcapi.RPC_TOPIC)</span><br><span class="line">    workers = CONF.conductor.workers <span class="keyword">or</span> processutils.get_worker_count()</span><br><span class="line">    <span class="comment"># oslo_service.launch 创建 launcher</span></span><br><span class="line">    service.serve(server, workers=workers)</span><br><span class="line">    <span class="comment"># 调用 launcher.wait 等待子进程终止</span></span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure>

<p>nova.service.Service 初始化函数接受 manager 对象，通过监听消息队列启用 RPC 服务；设置定期任务报告状态，并写入数据库。</p>
<ul>
<li>nova-compute</li>
<li>nova-conductor</li>
<li>nova-scheduler</li>
</ul>
<p>RPC 服务启动时创建 rpc_client 用于发送消息，创建 rpc_server 用于接收消息，分派执行。</p>
<p><strong>1. rpc_client</strong></p>
<p>nova/cmd/conductor.py 实际创建 Service 实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server = service.Service.create(binary=<span class="string">&#x27;nova-conductor&#x27;</span>,</span><br><span class="line">                                topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure>

<p>nova/service.py 初始化函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 _driver</span></span><br><span class="line">self.servicegroup_api = servicegroup.API()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态导入 manager 类</span></span><br><span class="line">manager_class = importutils.import_class(self.manager_class_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> objects_base.NovaObject.indirection_api:</span><br><span class="line">    <span class="comment"># 创建 RPCClient</span></span><br><span class="line">    conductor_api = conductor.API()</span><br><span class="line">    <span class="comment"># 等待 nova-conductor 启动</span></span><br><span class="line">    conductor_api.wait_until_ready(context.get_admin_context())</span><br></pre></td></tr></table></figure>

<p>nova/servicegroup/api.py 创建 _driver</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver_class = _driver_name_class_mapping[CONF.servicegroup_driver]</span><br><span class="line">self._driver = importutils.import_object(driver_class,</span><br><span class="line">                                         *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>nova/conductor/api.py 实际调用 rpcapi.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.conductor_rpcapi = rpcapi.ConductorAPI()</span><br><span class="line">    self.base_rpcapi = baserpc.BaseAPI(topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure>

<p>nova/conductor/rpcapi.py 设置 rpc_client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(ConductorAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=RPC_TOPIC, version=<span class="string">&#x27;3.0&#x27;</span>)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.conductor,</span><br><span class="line">                                           CONF.upgrade_levels.conductor)</span><br><span class="line">    serializer = objects_base.NovaObjectSerializer()</span><br><span class="line">    <span class="comment"># rpc client</span></span><br><span class="line">    self.client = rpc.get_client(target,</span><br><span class="line">                                 version_cap=version_cap,</span><br><span class="line">                                 serializer=serializer)</span><br></pre></td></tr></table></figure>

<p>nova/baserpc.py 设置 rpc_client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, topic</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(BaseAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=topic,</span><br><span class="line">                              namespace=_NAMESPACE,</span><br><span class="line">                              version=<span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.baseapi,</span><br><span class="line">                                           CONF.upgrade_levels.baseapi)</span><br><span class="line">    self.client = rpc.get_client(target, version_cap=version_cap)</span><br></pre></td></tr></table></figure>

<p><strong>2. rpc_server</strong></p>
<p>nova/cmd/conductor.py 使用 Service 实例启动服务</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># oslo_service.launch 创建 launcher</span></span><br><span class="line">service.serve(server, workers=workers)</span><br><span class="line"><span class="comment"># 调用 launcher.wait 等待子进程终止</span></span><br><span class="line">service.wait()</span><br></pre></td></tr></table></figure>

<p>nova/service.py 实际调用 <a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.service">oslo_service</a> 的 launch 函数，创建绿色线程（greenthread）或进程，最终调用 Service 实例的 start 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span>(<span class="params">server, workers=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> _launcher</span><br><span class="line">    <span class="keyword">if</span> _launcher:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_(<span class="string">&#x27;serve() can only be called once&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    _launcher = service.launch(CONF, server, workers=workers,</span><br><span class="line">                               restart_method=<span class="string">&#x27;mutate&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>nova/service.py Service 实例的 start 方法创建 rpc_server 和 dispatcher；设置周期任务</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 rpc server 以及 dispatcher</span></span><br><span class="line">self.rpcserver = rpc.get_server(target, endpoints, serializer)</span><br><span class="line">self.rpcserver.start()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.periodic_enable:</span><br><span class="line">    <span class="keyword">if</span> self.periodic_fuzzy_delay:</span><br><span class="line">        initial_delay = random.randint(<span class="number">0</span>, self.periodic_fuzzy_delay)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        initial_delay = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    self.tg.add_dynamic_timer(self.periodic_tasks,</span><br><span class="line">                             initial_delay=initial_delay,</span><br><span class="line">                             periodic_interval_max=</span><br><span class="line">                                self.periodic_interval_max)</span><br></pre></td></tr></table></figure>


<p>收到消息后主要由 <a target="_blank" rel="noopener" href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 进行解析和处理，核心是 oslo_messaging/rpc/dispatcher.py</p>
<p>incoming 是 AMQP 消息格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, incoming</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Dispatch an RPC message to the appropriate endpoint method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param incoming: incoming message</span></span><br><span class="line"><span class="string">    :type incoming: IncomingMessage</span></span><br><span class="line"><span class="string">    :raises: NoSuchMethod, UnsupportedVersion</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    message = incoming.message</span><br><span class="line">    ctxt = incoming.ctxt</span><br><span class="line"></span><br><span class="line">    method = message.get(<span class="string">&#x27;method&#x27;</span>)</span><br><span class="line">    args = message.get(<span class="string">&#x27;args&#x27;</span>, &#123;&#125;)</span><br><span class="line">    namespace = message.get(<span class="string">&#x27;namespace&#x27;</span>)</span><br><span class="line">    version = message.get(<span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># NOTE(danms): This event and watchdog thread are used to send</span></span><br><span class="line">    <span class="comment"># call-monitoring heartbeats for this message while the call</span></span><br><span class="line">    <span class="comment"># is executing if it runs for some time. The thread will wait</span></span><br><span class="line">    <span class="comment"># for the event to be signaled, which we do explicitly below</span></span><br><span class="line">    <span class="comment"># after dispatching the method call.</span></span><br><span class="line">    completion_event = eventletutils.Event()</span><br><span class="line">    watchdog_thread = threading.Thread(target=self._watchdog,</span><br><span class="line">                                       args=(completion_event, incoming))</span><br><span class="line">    <span class="keyword">if</span> incoming.client_timeout:</span><br><span class="line">        <span class="comment"># NOTE(danms): The client provided a timeout, so we start</span></span><br><span class="line">        <span class="comment"># the watchdog thread. If the client is old or didn&#x27;t send</span></span><br><span class="line">        <span class="comment"># a timeout, we just never start the watchdog thread.</span></span><br><span class="line">        watchdog_thread.start()</span><br><span class="line"></span><br><span class="line">    found_compatible = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> endpoint <span class="keyword">in</span> self.endpoints:</span><br><span class="line">        target = <span class="built_in">getattr</span>(endpoint, <span class="string">&#x27;target&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target:</span><br><span class="line">            target = self._default_target</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (self._is_namespace(target, namespace) <span class="keyword">and</span></span><br><span class="line">                self._is_compatible(target, version)):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(endpoint, method):</span><br><span class="line">            <span class="keyword">if</span> self.access_policy.is_allowed(endpoint, method):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 分派，调用函数</span></span><br><span class="line">                    <span class="keyword">return</span> self._do_dispatch(endpoint, method, ctxt, args)</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    completion_event.<span class="built_in">set</span>()</span><br><span class="line">                    <span class="keyword">if</span> incoming.client_timeout:</span><br><span class="line">                        watchdog_thread.join()</span><br><span class="line"></span><br><span class="line">        found_compatible = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> found_compatible:</span><br><span class="line">        <span class="keyword">raise</span> NoSuchMethod(method)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> UnsupportedVersion(version, method=method)</span><br></pre></td></tr></table></figure>

<p>oslo_messaging/rpc/dispatcher.py 调用函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_do_dispatch</span>(<span class="params">self, endpoint, method, ctxt, args</span>):</span></span><br><span class="line">    ctxt = self.serializer.deserialize_context(ctxt)</span><br><span class="line">    new_args = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> argname, arg <span class="keyword">in</span> args.items():</span><br><span class="line">        new_args[argname] = self.serializer.deserialize_entity(ctxt, arg)</span><br><span class="line">    func = <span class="built_in">getattr</span>(endpoint, method)</span><br><span class="line">    result = func(ctxt, **new_args)</span><br><span class="line">    <span class="keyword">return</span> self.serializer.serialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure>


<p>发送消息的实现都在 nova/conductor/rpcapi.py 中，cctxt.call 同步调用，cctxt.cast 异步调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">object_class_action_versions</span>(<span class="params">self, context, objname, objmethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 object_versions, args, kwargs</span>):</span></span><br><span class="line">    cctxt = self.client.prepare()</span><br><span class="line">    <span class="keyword">return</span> cctxt.call(context, <span class="string">&#x27;object_class_action_versions&#x27;</span>,</span><br><span class="line">                      objname=objname, objmethod=objmethod,</span><br><span class="line">                      object_versions=object_versions,</span><br><span class="line">                      args=args, kwargs=kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_images</span>(<span class="params">self, ctxt, aggregate, image_ids</span>):</span></span><br><span class="line">    version = <span class="string">&#x27;1.21&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.client.can_send_version(version):</span><br><span class="line">        <span class="keyword">raise</span> exception.NovaException(<span class="string">&#x27;Conductor RPC version pin does not &#x27;</span></span><br><span class="line">                                      <span class="string">&#x27;allow cache_images() to be called&#x27;</span>)</span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    cctxt.cast(ctxt, <span class="string">&#x27;cache_images&#x27;</span>, aggregate=aggregate,</span><br><span class="line">               image_ids=image_ids)</span><br></pre></td></tr></table></figure>

<p>由 oslo_messaging/rpc/client.py 实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cast</span>(<span class="params">self, ctxt, method, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Invoke a method and return immediately. See RPCClient.cast().&quot;&quot;&quot;</span></span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(<span class="string">&#x27;version&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                             retry=self.retry,</span><br><span class="line">                             transport_options=self.transport_options)</span><br><span class="line">    <span class="keyword">except</span> driver_base.TransportDriverError <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="keyword">raise</span> ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self, ctxt, method, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Invoke a method and wait for a reply. See RPCClient.call().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.target.fanout:</span><br><span class="line">        <span class="keyword">raise</span> exceptions.InvalidTarget(<span class="string">&#x27;A call cannot be used with fanout&#x27;</span>,</span><br><span class="line">                                       self.target)</span><br><span class="line"></span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    timeout = self.timeout</span><br><span class="line">    <span class="keyword">if</span> self.timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        timeout = self.conf.rpc_response_timeout</span><br><span class="line"></span><br><span class="line">    cm_timeout = self.call_monitor_timeout</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(<span class="string">&#x27;version&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = \</span><br><span class="line">            self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                                 wait_for_reply=<span class="literal">True</span>, timeout=timeout,</span><br><span class="line">                                 call_monitor_timeout=cm_timeout,</span><br><span class="line">                                 retry=self.retry,</span><br><span class="line">                                 transport_options=self.transport_options)</span><br><span class="line">    <span class="keyword">except</span> driver_base.TransportDriverError <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="keyword">raise</span> ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.serializer.deserialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure>


<p>关于周期任务，nova/scheduler/manager.py 中使用 <code>@periodic_task.periodic_task</code> 装饰的方法将会被周期调用，从 scheduler 的调试日志可以看到周期任务的运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">********************************************************************* log_opt_values /home/jck/.<span class="built_in">local</span>/lib/python3.6/site-packages/oslo_config/cfg.py:2591</span><br><span class="line">2021-05-18 05:53:17.030 3501 DEBUG oslo_service.periodic_task [req-66b43add-49c7-4f33-8f6b-1e33cb9f0123 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.<span class="built_in">local</span>/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">2021-05-18 05:53:39.072 3500 DEBUG oslo_service.periodic_task [req-8436b3e2-96d1-4f15-8ae8-b596cee05536 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.<span class="built_in">local</span>/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对应于 nova/scheduler/manager.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@periodic_task.periodic_task(<span class="params">spacing=CONF.scheduler.periodic_task_interval,</span></span></span><br><span class="line"><span class="meta"><span class="params">                             run_immediately=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_periodic_tasks</span>(<span class="params">self, context</span>):</span></span><br><span class="line">    self.driver.run_periodic_tasks(context)</span><br></pre></td></tr></table></figure>

<p>执行周期任务的有 nova-scheduler 和 nova-compute ，主要功能是计算节点 nova-compute 上报资源信息，nova-scheduler 读取数据库，更新资源信息缓存。</p>
<h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/user/architecture.html">Nova System Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/install/get-started-compute.html">Compute service overview</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/reference/rpc.html">AMQP and Nova</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/reference/scheduling.html">Scheduling</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/user/cellsv2-layout.html">Cells Layout (v2)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 Model Explained</a></li>
<li><a target="_blank" rel="noopener" href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">AMQP 0-9-1 简介</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jckling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jckling.github.io/2021/05/23/OpenStack/OpenStack%20Nova/">https://jckling.github.io/2021/05/23/OpenStack/OpenStack Nova/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jckling.github.io" target="_blank">Jckling's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/14/NfcmdhT7uUx4pqo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/jckling/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/jckling/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1035234274961147" data-ad-slot="3100725659" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/25/OpenStack/OSProfiler%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="prev-cover" src="https://i.loli.net/2021/06/14/NfcmdhT7uUx4pqo.jpg" onerror="onerror=null;src='/img/jckling/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OSProfiler 源码分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/13/OpenStack/Ubuntu18.04%20%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%20Nova%20(Victoria)/"><img class="next-cover" src="https://i.loli.net/2021/06/14/O6DgG2AzyvJfTso.jpg" onerror="onerror=null;src='/img/jckling/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ubuntu 18.04 源码安装 Placement + Nova (Victoria)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪"><img class="cover" src="https://i.loli.net/2021/06/14/bk5UlhqE4DZJfYu.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-05</div><div class="title">CVE-2020-12691 漏洞利用相关信息追踪</div></div></a></div><div><a href="/2021/05/10/Jaeger/Jaeger%20+%20Elasticsearch%20+%20Kibana/" title="使用 Docker 部署 Jaeger + Elasticsearch + Kibana"><img class="cover" src="https://i.loli.net/2021/06/14/bk5UlhqE4DZJfYu.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">使用 Docker 部署 Jaeger + Elasticsearch + Kibana</div></div></a></div><div><a href="/2021/07/28/Notes/Python%20%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/" title="Python 静态分析相关论文"><img class="cover" src="https://i.loli.net/2021/06/14/f3EiKbmVUTQyPSc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-28</div><div class="title">Python 静态分析相关论文</div></div></a></div><div><a href="/2020/12/25/OpenStack/CentOS7+OpenStack(Rocky)-0/" title="CentOS 7 安装 Openstack Rocky 版本 - 环境搭建"><img class="cover" src="https://i.loli.net/2021/06/14/Y3ljqCHn76RITPz.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-25</div><div class="title">CentOS 7 安装 Openstack Rocky 版本 - 环境搭建</div></div></a></div><div><a href="/2020/12/26/OpenStack/CentOS7+OpenStack(Rocky)-1/" title="CentOS 7 安装 Openstack Rocky 版本 - 身份认证服务（Keystone）"><img class="cover" src="https://i.loli.net/2021/06/14/Y3ljqCHn76RITPz.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-26</div><div class="title">CentOS 7 安装 Openstack Rocky 版本 - 身份认证服务（Keystone）</div></div></a></div><div><a href="/2020/12/26/OpenStack/CentOS7+OpenStack(Rocky)-2/" title="CentOS 7 安装 Openstack Rocky 版本 - 镜像服务（Glance）"><img class="cover" src="https://i.loli.net/2021/06/14/Y3ljqCHn76RITPz.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-26</div><div class="title">CentOS 7 安装 Openstack Rocky 版本 - 镜像服务（Glance）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/jckling/avatar.jpg" onerror="this.onerror=null;this.src='/img/jckling/avatar_404.png'" alt="avatar"/></div><div class="author-info__name">Jckling</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jckling"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎访问本站 🥳 <br/>评论需要审核，请不要重复提交~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.1.</span> <span class="toc-text">组成部分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC"><span class="toc-number">2.</span> <span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-call"><span class="toc-number">2.2.</span> <span class="toc-text">rpc.call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc-cast"><span class="toc-number">2.3.</span> <span class="toc-text">rpc.cast</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nova-api"><span class="toc-number">3.1.</span> <span class="toc-text">nova-api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="toc-number">3.1.1.</span> <span class="toc-text">API 请求路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">API 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nova-conductor"><span class="toc-number">3.2.</span> <span class="toc-text">nova-conductor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nova-scheduler"><span class="toc-number">3.3.</span> <span class="toc-text">nova-scheduler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E9%98%85"><span class="toc-number">5.</span> <span class="toc-text">参阅</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/" title="Datalog 引擎 Soufflé 指南"><img src="https://i.loli.net/2021/06/14/oSn9dxfYhEHClIe.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Datalog 引擎 Soufflé 指南"/></a><div class="content"><a class="title" href="/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/" title="Datalog 引擎 Soufflé 指南">Datalog 引擎 Soufflé 指南</a><time datetime="2021-11-22T11:01:43.000Z" title="发表于 2021-11-22 19:01:43">2021-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪"><img src="https://i.loli.net/2021/06/14/bk5UlhqE4DZJfYu.png" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="CVE-2020-12691 漏洞利用相关信息追踪"/></a><div class="content"><a class="title" href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪">CVE-2020-12691 漏洞利用相关信息追踪</a><time datetime="2021-11-05T07:25:15.000Z" title="发表于 2021-11-05 15:25:15">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/" title="LogiQL 入门"><img src="https://developer.logicblox.com/wp-content/uploads/2017/12/prod-bg-panelfour.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="LogiQL 入门"/></a><div class="content"><a class="title" href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/" title="LogiQL 入门">LogiQL 入门</a><time datetime="2021-10-26T08:15:05.000Z" title="发表于 2021-10-26 16:15:05">2021-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Gadget Inspector 源码解析"><img src="https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Gadget Inspector 源码解析"/></a><div class="content"><a class="title" href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Gadget Inspector 源码解析">Gadget Inspector 源码解析</a><time datetime="2021-10-12T03:41:30.000Z" title="发表于 2021-10-12 11:41:30">2021-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/" title="Python 爬取 twitter 数据"><img src="https://about.twitter.com/content/dam/about-twitter/en/brand-toolkit/brand-banner-desktop.jpg.twimg.1920.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Python 爬取 twitter 数据"/></a><div class="content"><a class="title" href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/" title="Python 爬取 twitter 数据">Python 爬取 twitter 数据</a><time datetime="2021-10-11T10:44:50.000Z" title="发表于 2021-10-11 18:44:50">2021-10-11</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1035234274961147" data-ad-slot="8787224657" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/06/14/NfcmdhT7uUx4pqo.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jckling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comments-puce.vercel.app',
      avatar: 'retro',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, {"emoji":"https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji"}))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>