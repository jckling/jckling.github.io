<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;zh-HK&quot;,&quot;zh-TW&quot;,&quot;default&quot;]" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Gadget Inspector 源码解析 | Jckling's Blog</title><meta name="keywords" content="Java"><meta name="author" content="Jckling"><meta name="copyright" content="Jckling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="感觉自己看了好久好久... 长文警告⚠️">
<meta property="og:type" content="article">
<meta property="og:title" content="Gadget Inspector 源码解析">
<meta property="og:url" content="https://jckling.github.io/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Jckling&#39;s Blog">
<meta property="og:description" content="感觉自己看了好久好久... 长文警告⚠️">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg">
<meta property="article:published_time" content="2021-10-12T03:41:30.000Z">
<meta property="article:modified_time" content="2021-11-23T07:11:29.000Z">
<meta property="article:author" content="Jckling">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg"><link rel="shortcut icon" href="/img/jckling/favicon.ico"><link rel="canonical" href="https://jckling.github.io/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google_site_verification" content="pZZt69mo0ndoxIJ1vjEe830lXbvD26aiVAZ-k0FWM5k"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?20b7797c0b5f4e821c1449cd4c6c98c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-164555720-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-164555720-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Gadget Inspector 源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-23 15:11:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Jckling's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/jckling/avatar.jpg" onerror="onerror=null;src='/img/jckling/avatar_404.png'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jckling's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Gadget Inspector 源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-10-12T03:41:30.000Z" title="undefined 2021-10-12 11:41:30">2021-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Security/">Security</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Gadget Inspector 源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#post-comment"><span class="waline-comment-count" id="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Netflix 工程师开发的 Gadget Inspector 是一个用于挖掘 Java 反序列化漏洞利用链的工具，网上有两个同名资料 Automated Discovery of Deserialization Gadget Chains：<a target="_blank" rel="noopener" href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf">论文</a>、<a target="_blank" rel="noopener" href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf">PPT</a>。看懂工作流程并不难，入口类非常清晰明了，主要是逆拓扑排序、JVM 模拟（本地变量表、操作数栈）的部分比较晦涩。鉴于我四舍五入算是零基础接触 Java，所以前面先补充一些相关知识，后面再详细解析 Gadget Inspector 的代码。</p>
<p>加了注释的源码：<a target="_blank" rel="noopener" href="https://github.com/jckling/gadgetinspector">jckling/gadgetinspector</a></p>
<h1 id="0x01-预备知识"><a href="#0x01-预备知识" class="headerlink" title="0x01 预备知识"></a>0x01 预备知识</h1><h2 id="1-1-Java-字节码"><a href="#1-1-Java-字节码" class="headerlink" title="1.1 Java 字节码"></a>1.1 Java 字节码</h2><p>看美团的 <a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a> 里面的介绍就够了，内容包括 java 的字节码、asm 框架、Javassist 框架以及 instrument 类库。</p>
<p><strong>限定名（qualified names）</strong>：名称、<code>.</code>、标识符，例如：demo.servlet.HelloServlet，有些地方用 <code>/</code> 代替点号</p>
<p><strong>简单名称（simple name）</strong>：单个标识符，例如：test</p>
<p><strong>完全限定名（fully qualified names）</strong>：每个原始类型、命名包、顶级类和顶级接口都有一个完全限定名，有的是简单名称有的是限定名，详见 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-6.html#jls-6.7">6.7. Fully Qualified Names and Canonical Names</a></p>
<p><strong>描述符（Descriptor）</strong></p>
<ol>
<li><p>字段（Field）描述符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FieldDescriptor:</span><br><span class="line">FieldType</span><br><span class="line"></span><br><span class="line">FieldType:</span><br><span class="line">    BaseType</span><br><span class="line">    ObjectType</span><br><span class="line">    ArrayType</span><br><span class="line">   </span><br><span class="line">BaseType:</span><br><span class="line">    B</span><br><span class="line">    C</span><br><span class="line">    D</span><br><span class="line">    F</span><br><span class="line">    I</span><br><span class="line">    J</span><br><span class="line">    S</span><br><span class="line">    Z</span><br><span class="line">   </span><br><span class="line">ObjectType:</span><br><span class="line">    L ClassName ;</span><br><span class="line"></span><br><span class="line">ArrayType:</span><br><span class="line">    [ ComponentType</span><br><span class="line"></span><br><span class="line">ComponentType:</span><br><span class="line">    FieldType</span><br></pre></td></tr></table></figure>

<p> 说明</p>
<table>
<thead>
<tr>
<th>BaseType Character</th>
<th>Type</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>signed byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character code point in the Basic Multilingual Plane,     encoded with UTF-16</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer</td>
</tr>
<tr>
<td>L</td>
<td>ClassName</td>
<td>;    reference    an instance of class ClassName</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false</td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension</td>
</tr>
</tbody></table>
</li>
<li><p>方法（Method）描述符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MethodDescriptor:</span><br><span class="line">    ( ParameterDescriptor* ) ReturnDescriptor</span><br><span class="line"></span><br><span class="line">ParameterDescriptor:</span><br><span class="line">    FieldType</span><br><span class="line"></span><br><span class="line">ReturnDescriptor:</span><br><span class="line">    FieldType</span><br><span class="line">    VoidDescriptor</span><br><span class="line"></span><br><span class="line">VoidDescriptor:</span><br><span class="line">    V</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="1-2-JVM"><a href="#1-2-JVM" class="headerlink" title="1.2 JVM"></a>1.2 JVM</h2><p>Gadget Inspector 的 <code>TaintTrackingMethodVisitor</code> 中模拟了 JVM 的本地变量表（Local Variable Table）和操作数栈（Operand Stack），用于进行污点分析。</p>
<p><strong>栈帧（Stack Frame）</strong> 是用于支持虚拟机进行方法调用和方法执行的数据结构，每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</p>
<p><strong>本地变量表（Local Variable Table）</strong> 存储了方法参数和方法内定义的局部变量，隐式传入实例对象本身 <code>this</code> 。</p>
<p><strong>操作数栈（Operand Stack）</strong> 由操作码控制元素的出/入栈，操作数栈中的元素可以是任意 Java 数据类型。</p>
<ul>
<li>入栈：本地变量表或对象实例的字段中的元素（常量/变量）</li>
<li>出栈：将栈中元素写入本地变量表或返回给方法调用者（返回栈顶）</li>
<li>栈中元素的长度可能为 0、1、2，这里一个单位为 32 位</li>
</ul>
<h2 id="1-3-ASM"><a href="#1-3-ASM" class="headerlink" title="1.3 ASM"></a>1.3 ASM</h2><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，<strong>在“访问”的过程中以回调形式在访问者中处理操作逻辑</strong>。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<h3 id="代码组织架构"><a href="#代码组织架构" class="headerlink" title="代码组织架构"></a>代码组织架构</h3><img src="https://i.loli.net/2021/10/14/KQyh94RWalubxLd.png" width="90%">

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.objectweb.asm			<span class="comment"># Core API，核心包</span></span><br><span class="line">org.objectweb.asm.commons		<span class="comment"># 基于 core 和 tree 的类适配器</span></span><br><span class="line">org.objectweb.asm.signature		<span class="comment"># 泛型定义的相关操作 API，核心包的扩充</span></span><br><span class="line">org.objectweb.asm.tree			<span class="comment"># Tree API，实现复杂的类转换</span></span><br><span class="line">org.objectweb.asm.tree.analysis	        <span class="comment"># 基于 tree 包提供的静态字节码分析框架</span></span><br><span class="line">org.objectweb.asm.util			<span class="comment"># 用于调试的类访问器和适配器</span></span><br><span class="line">org.objectweb.asm.xml			<span class="comment"># 弃用</span></span><br></pre></td></tr></table></figure>

<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p><code>ClassReader</code> 类解析 class 文件（事件生成）</p>
<ul>
<li>调用作为参数传递给 accept 方法的 <code>ClassVisitor</code> 实例上相应的 visitXxx 方法</li>
</ul>
</li>
<li><p><code>ClassVisitor</code> 类将所有方法调用委派给另一个 <code>ClassVisitor</code> 实例（事件过滤）</p>
</li>
<li><p><code>ClassWriter</code> 类是 <code>ClassVisitor</code> 抽象类的子类（事件消费）</p>
</li>
</ol>
<p>为了对类文件进行“观察”，需要继承和重写访问者（Visitor），然后调用 ClassReader.accept 方法执行访问，该方法将按顺序调用参数 ClassVisitor 中的方法，没有重写的则调用父类 ClassVisitor 默认的方法；观察到方法时，将按顺序调用 MethodVisitor 中的方法，没有重写的也调用默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> * 构造一个新的 ClassReader 对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classFile 要读取的 JVMS ClassFile 结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ClassReader​(<span class="keyword">byte</span>[] classFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的访问者访问传递给此 ClassReader 的构造函数的 JVMS ClassFile 结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classVisitor    访问者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parsingOptions  用于解析此类的选项（SKIP_CODE, SKIP_DEBUG, SKIP_FRAMES, EXPAND_FRAMES）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> accept​(ClassVisitor classVisitor, <span class="keyword">int</span> parsingOptions)</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/10/14/rAEhSn8x3DMLwtO.jpg">


<h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><h4 id="1-ClassVisitor"><a href="#1-ClassVisitor" class="headerlink" title="1. ClassVisitor"></a>1. ClassVisitor</h4><p>方法调用顺序（访问顺序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visit [ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ] ( visitAnnotation | visitTypeAnnotation | visitAttribute )* ( visitNestMember | [ * visitPermittedSubclass ] | visitInnerClass | visitRecordComponent | visitField | visitMethod )* visitEnd</span><br></pre></td></tr></table></figure>

<p>Gadget Inspector 中涉及的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	api     访问者实现的 ASM API 版本。必须是 Opcodes.ASM4、Opcodes.ASM5、Opcodes.ASM6、Opcodes.ASM7 之一。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ClassVisitor​(<span class="keyword">int</span> api)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问类的头部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	version		类版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	access		类的访问标志（Opcodes）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	name		类的内部名称（完全限定名）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	signature	类的签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	superName	父类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	interfaces	类接口的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, java.lang.String name, java.lang.String signature, java.lang.String superName, java.lang.String[] interfaces)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问类的外围类，当类具有外围类时自动调用此方法</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	owner		类的外围类的内部名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	name		包含类的方法的名称，如果类没有包含在其外围类的方法中，则为空</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	包含类的方法的描述符，如果类没有包含在其外围类的方法中，则为空</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(java.lang.String owner, java.lang.String name, java.lang.String descriptor)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问内部类，这个内部类不一定是被访问的类的成员</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	owner		内部类的内部名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	outerName	内部类所属的类的内部名称，对于非成员类可能为空</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	innerName	内部类在其外围类中的(简单)名称，对于匿名内部类可能为空</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	access		内部类最初在外围类中声明的访问标志</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(java.lang.String name, java.lang.String outerName, java.lang.String innerName, <span class="keyword">int</span> access)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问类的字段</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	access		字段的访问标志</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	name	    字段的名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	字段的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	signature	字段的签名</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	value       字段的初始值，仅针对静态字段</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FieldVisitor visitField​<span class="params">(<span class="keyword">int</span> access, java.lang.String name, java.lang.String descriptor, java.lang.String signature, java.lang.Object value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问类的一个方法（方法定义）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 这个方法在每次调用时必须返回一个新的 MethodVisitor 实例（或null）</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	access		方法的访问标志（Opcodes）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	name		方法的名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	方法的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	signature	方法的签名，如果方法参数、返回类型和异常不使用泛型类型，则可能为空</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	exceptions	方法异常类的内部名称，可能为空</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, java.lang.String name, java.lang.String descriptor, java.lang.String signature, java.lang.String[] exceptions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 该方法是最后一个被调用的方法，用于通知访问者该类的所有字段和方法已被访问</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>


<h4 id="2-MethodVisitor"><a href="#2-MethodVisitor" class="headerlink" title="2. MethodVisitor"></a>2. MethodVisitor</h4><p>方法调用顺序（访问顺序），<code>visit&lt;i&gt;X&lt;/i&gt;Insn</code> 按照字节码指令顺序调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( visitParameter )* [ visitAnnotationDefault ] ( visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation visitTypeAnnotation | visitAttribute )* [ visitCode ( visitFrame | visit&lt;i&gt;X&lt;&#x2F;i&gt;Insn | visitLabel | visitInsnAnnotation | visitTryCatchBlock | visitTryCatchAnnotation | visitLocalVariable | visitLocalVariableAnnotation | visitLineNumber )* visitMaxs ] visitEnd</span><br><span class="line"></span><br><span class="line">In addition, the visit&lt;i&gt;X&lt;&#x2F;i&gt;Insn and visitLabel methods must be called in the sequential order of the bytecode instructions of the visited code.</span><br></pre></td></tr></table></figure>

<p>Gadget Inspector 中涉及的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动对方法代码的访问，如果有的话（即非抽象方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问局部变量和操作数堆栈元素的当前状态</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	type		堆栈映射帧的类型（stack map frame）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	numLocal	被访问帧中的局部变量数量</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	local		被访问帧中的局部变量类型</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	numStack	被访问帧中的操作数堆栈元素个数</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	stack		被访问帧中的操作数堆栈元素类型</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFrame</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> numLocal, java.lang.Object[] local, <span class="keyword">int</span> numStack, java.lang.Object[] stack)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问零操作数的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode	要访问的指令的操作码</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问单个 int 类型操作数的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode	要访问的指令的操作码：BIPUSH、SIPUSH、NEWARRAY</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	operand	要访问的指令的操作数</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitIntInsn</span><span class="params">(<span class="keyword">int</span> opcode, <span class="keyword">int</span> operand)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问局部变量指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 局部变量指令是加载或存储局部变量值的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode	要访问的指令的操作码：ILOAD、LLOAD、FLOAD、DLOAD、ALOAD、ISTORE、LSTORE、FSTORE、DSTORE、ASTORE、RET</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	var		要访问的指令的操作数（局部变量的下标）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitVarInsn</span><span class="params">(<span class="keyword">int</span> opcode, <span class="keyword">int</span> <span class="keyword">var</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问类型指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 类型指令是以类的内部名称作为参数的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode	要访问的指令的操作码：NEW、ANEWARRAY、CHECKCAST、INSTANCEOF</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	type	要访问的指令的操作数（对象或数组类的内部名称）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitTypeInsn</span><span class="params">(<span class="keyword">int</span> opcode, java.lang.String type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问字段指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 字段指令是加载或存储对象字段值的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode		要访问的指令的操作码：GETSTATIC、PUTSTATIC、GETFIELD、PUTFIELD</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	owner		字段所有者类的内部名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	name		字段的名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	字段的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFieldInsn</span><span class="params">(<span class="keyword">int</span> opcode, java.lang.String owner, java.lang.String name, java.lang.String descriptor)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问方法指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 方法指令是调用方法的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode		要访问的指令的操作码：INVOKEVIRTUAL、INVOKESPECIAL、INVOKESTATIC、INVOKEINTERFACE</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	owner		方法所有者类的内部名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	name		方法的名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	方法的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	isInterface	方法的所有者类是否为接口</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, java.lang.String owner, java.lang.String name, java.lang.String descriptor, <span class="keyword">boolean</span> isInterface)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 invokedynamic 指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	name						方法的名称</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor					方法的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	bootstrapMethodHandle		引导方法</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	bootstrapMethodArguments	引导方法的常量参数</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInvokeDynamicInsn</span><span class="params">(java.lang.String name, java.lang.String descriptor, Handle bootstrapMethodHandle, java.lang.Object... bootstrapMethodArguments)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问跳转指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 跳转指令是可以跳转到另一条指令的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	opcode	要访问的指令的操作码：IFEQ、IFNE、IFLT、IFGE、IFGT、IFLE、IF_ICMPEQ、IF_ICMPNE、IF_ICMPLT、IF_ICMPGE、IF_ICMPGT、IF_ICMPLE、IF_ACMPEQ、IF_ACMPNE、GOTO、JSR、IFNULL、IFNONNULL</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	label	要访问的指令的操作数（标签，指定跳转指令可以跳转到的指令）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitJumpInsn</span><span class="params">(<span class="keyword">int</span> opcode, Label label)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问标签</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 标签指定紧随其后的指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	label	标签对象</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLabel</span><span class="params">(Label label)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 LDC 指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	value	要加载到堆栈上的常数</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLdcInsn</span><span class="params">(java.lang.Object value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 IINC 指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	value		要递增的局部变量的索引</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	increment	递增的数量</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitIincInsn</span><span class="params">(<span class="keyword">int</span> <span class="keyword">var</span>, <span class="keyword">int</span> increment)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 TABLESWITCH 指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	min		最小键值</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	max		最大键值</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	dflt	默认处理程序块的开始部分</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	labels	处理程序块的开始</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitTableSwitchInsn</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max, Label dflt, Label... labels)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 LOOKUPSWITCH 指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	dflt	默认处理程序块的开始部分</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	keys	键值</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	labels	处理程序块的开始</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLookupSwitchInsn</span><span class="params">(Label dflt, <span class="keyword">int</span>[] keys, Label[] labels)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 MULTIANEWARRAY 指令</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor		数组类型的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	numDimensions	要分配的数组的维数</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMultiANewArrayInsn</span><span class="params">(java.lang.String descriptor, <span class="keyword">int</span> numDimensions)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问指令上的注释</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 必须在带注释的指令之后调用此方法，对同一指令可以多次调用</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	typeRef		对注释类型的引用	</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	typePath	typeRef 中带注释的类型参数/通配符绑定/数组元素类型/静态内部类型的路径</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	注释类的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	visible		运行时是否可见</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitInsnAnnotation</span><span class="params">(<span class="keyword">int</span> typeRef, TypePath typePath, java.lang.String descriptor, <span class="keyword">boolean</span> visible)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问 try catch 块</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	start	异常处理程序范围的开始（包含）	</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	end		异常处理程序范围的结束（不包含）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	handler	异常处理程序代码的开头</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	type	由处理程序处理的异常类型的内部名称，或 null 来捕获任何异常（对 finally 块）</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitTryCatchBlock</span><span class="params">(Label start, Label end, Label handler, java.lang.String type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问异常处理程序类型上的注释</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 必须在 visitTryCatchBlock 之后调用，对同一个异常处理程序可以多次调用</span></span></span><br><span class="line"><span class="function"><span class="comment"> * </span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	typeRef		对注释类型的引用	</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	typePath	typeRef 中带注释的类型参数/通配符绑定/数组元素类型/静态内部类型的路径</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	descriptor	注释类的描述符</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	visible		运行时是否可见</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitTryCatchAnnotation</span><span class="params">(<span class="keyword">int</span> typeRef, TypePath typePath, java.lang.String descriptor, <span class="keyword">boolean</span> visible)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问方法的最大堆栈大小和最大局部变量数量</span></span></span><br><span class="line"><span class="function"><span class="comment"> * </span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	maxStack	方法的最大堆栈大小</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @param	maxLocals	方法的最大局部变量数</span></span></span><br><span class="line"><span class="function"><span class="comment"> * @return</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMaxs</span><span class="params">(<span class="keyword">int</span> maxStack, <span class="keyword">int</span> maxLocals)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 访问方法的末尾</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 该方法是最后一个被调用的方法，用于通知访问者该方法的所有注释和属性已经被访问</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>


<h4 id="3-FieldVisitor"><a href="#3-FieldVisitor" class="headerlink" title="3. FieldVisitor"></a>3. FieldVisitor</h4><p>方法调用顺序（访问顺序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( visitAnnotation | visitTypeAnnotation | visitAttribute )* visitEnd</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>JSRInlinerAdapter 用于简化代码分析，删除 JSR 指令并内联引用的子例程（没懂）</p>
<blockquote>
<p>A MethodVisitor that removes JSR instructions and inlines the referenced subroutines</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	methodVisitor   将生成的内联方法代码发送到的方法访问者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	access		    方法的访问标志（Opcodes）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	name		    方法的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	descriptor      方法的描述符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	signature	    方法的签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>	exceptions      方法异常类的内部名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> JSRInlinerAdapter​(MethodVisitor methodVisitor,</span><br><span class="line">                         <span class="keyword">int</span> access,</span><br><span class="line">                         java.lang.String name,</span><br><span class="line">                         java.lang.String descriptor,</span><br><span class="line">                         java.lang.String signature,</span><br><span class="line">                         java.lang.String[] exceptions)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="0x02-项目结构"><a href="#0x02-项目结构" class="headerlink" title="0x02 项目结构"></a>0x02 项目结构</h1><p>项目中包含三种检测实现，在以下三个目录下：javaserial 针对 Java 原生序列化，jackson 针对 Jackson（JSON 库），xstream 针对 XStream（XML 库），同时在 config 目录下实现了各自的配置接口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── config      <span class="comment"># 配置接口和具体实现</span></span><br><span class="line">│   ├── ConfigRepository.java</span><br><span class="line">│   ├── GIConfig.java</span><br><span class="line">│   ├── JacksonDeserializationConfig.java</span><br><span class="line">│   ├── JavaDeserializationConfig.java</span><br><span class="line">│   └── XstreamDeserializationConfig.java</span><br><span class="line">├── data        <span class="comment"># 数据的存储格式以及读取方法</span></span><br><span class="line">│   ├── ClassReference.java</span><br><span class="line">│   ├── DataFactory.java</span><br><span class="line">│   ├── DataLoader.java</span><br><span class="line">│   ├── GraphCall.java</span><br><span class="line">│   ├── InheritanceDeriver.java</span><br><span class="line">│   ├── InheritanceMap.java</span><br><span class="line">│   ├── MethodReference.java</span><br><span class="line">│   └── Source.java</span><br><span class="line">├── jackson     <span class="comment"># JSON 库</span></span><br><span class="line">│   ├── JacksonImplementationFinder.java</span><br><span class="line">│   ├── JacksonSerializableDecider.java</span><br><span class="line">│   └── JacksonSourceDiscovery.java</span><br><span class="line">├── javaserial  <span class="comment"># 原生序列化</span></span><br><span class="line">│   ├── SimpleImplementationFinder.java</span><br><span class="line">│   ├── SimpleSerializableDecider.java</span><br><span class="line">│   └── SimpleSourceDiscovery.java</span><br><span class="line">├── xstream     <span class="comment"># XML 库</span></span><br><span class="line">│   ├── CustomXstreamSerializableDecider.java</span><br><span class="line">│   └── XstreamSerializableDecider.java</span><br><span class="line">├── CallGraphDiscovery.java             <span class="comment"># 方法调用链中的污点参数传递关系</span></span><br><span class="line">├── ClassResourceEnumerator.java        <span class="comment"># 类枚举器</span></span><br><span class="line">├── GadgetChainDiscovery.java           <span class="comment"># 搜索利用链</span></span><br><span class="line">├── GadgetInspector.java                <span class="comment"># 主类，程序入口</span></span><br><span class="line">├── ImplementationFinder.java           <span class="comment"># 接口，获取目标方法的子类实现</span></span><br><span class="line">├── MethodDiscovery.java                <span class="comment"># 类信息、方法信息、继承信息</span></span><br><span class="line">├── PassthroughDiscovery.java           <span class="comment"># 方法的返回值与参数的关系</span></span><br><span class="line">├── SerializableDecider.java            <span class="comment"># 序列化决策者接口</span></span><br><span class="line">├── SourceDiscovery.java                <span class="comment"># 污点源信息</span></span><br><span class="line">├── TaintTrackingMethodVisitor.java     <span class="comment"># 方法访问者</span></span><br><span class="line">└── Util.java                           <span class="comment"># 工具函数</span></span><br></pre></td></tr></table></figure>

<h2 id="gadgetinspector-data"><a href="#gadgetinspector-data" class="headerlink" title="gadgetinspector/data"></a>gadgetinspector/data</h2><p>主要是数据格式的定义。</p>
<h3 id="1-DataLoader"><a href="#1-DataLoader" class="headerlink" title="1. DataLoader"></a>1. DataLoader</h3><p>定义了数据的读写方式，根据数据工厂方法（DataFactory）进行读写，<code>loadData</code> 返回的是动态数组，源码中多处调用进行数据遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据数据工厂接口解析数据到对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory  工厂方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;      类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadData</span><span class="params">(Path filePath, DataFactory&lt;T&gt; factory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; lines = Files.readLines(filePath.toFile(), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; values = <span class="keyword">new</span> ArrayList&lt;T&gt;(lines.size());</span><br><span class="line">    <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">        values.add(factory.parse(line.split(<span class="string">&quot;\t&quot;</span>, -<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据数据工厂接口将数据写入文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory  工厂方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values   待写入的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;      类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">saveData</span><span class="params">(Path filePath, DataFactory&lt;T&gt; factory, Collection&lt;T&gt; values)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedWriter writer = Files.newWriter(filePath.toFile(), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (T value : values) &#123;</span><br><span class="line">            <span class="keyword">final</span> String[] fields = factory.serialize(value);</span><br><span class="line">            <span class="keyword">if</span> (fields == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\t&quot;</span>).append(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(sb.substring(<span class="number">1</span>));</span><br><span class="line">            writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后利用上面的方法实现读取类信息（classes.dat）和方法信息（methods.dat），返回存储键值的 Map，源码中多次调用用于搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 classes.dat 加载类信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;ClassReference.Handle, ClassReference&gt; loadClasses() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ClassReference classReference : loadData(Paths.get(<span class="string">&quot;classes.dat&quot;</span>), <span class="keyword">new</span> ClassReference.Factory())) &#123;</span><br><span class="line">            classMap.put(classReference.getHandle(), classReference);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classMap;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 methods.dat 加载方法信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, MethodReference&gt; loadMethods() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MethodReference methodReference : loadData(Paths.get(<span class="string">&quot;methods.dat&quot;</span>), <span class="keyword">new</span> MethodReference.Factory())) &#123;</span><br><span class="line">            methodMap.put(methodReference.getHandle(), methodReference);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodMap;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-DataFactory"><a href="#2-DataFactory" class="headerlink" title="2. DataFactory"></a>2. DataFactory</h3><p>数据工厂接口，定义数据的存储格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">parse</span><span class="params">(String[] fields)</span></span>;</span><br><span class="line">    String[] serialize(T obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ClassReference"><a href="#3-ClassReference" class="headerlink" title="3. ClassReference"></a>3. ClassReference</h3><p>定义<strong>类信息</strong>的描述方式，这些信息具体都使用 asm 访问者记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;          <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String superClass;    <span class="comment">// 父类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] interfaces;  <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isInterface;  <span class="comment">// 是否为接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Member[] members;     <span class="comment">// 字段/属性/成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;                  <span class="comment">// 名称</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> modifiers;                <span class="comment">// 访问修饰符</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassReference.Handle type;   <span class="comment">// 所属类</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">(String name, <span class="keyword">int</span> modifiers, Handle type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.modifiers = modifiers;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> modifiers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Handle <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassReference</span><span class="params">(String name, String superClass, String[] interfaces, <span class="keyword">boolean</span> isInterface, Member[] members)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.superClass = superClass;</span><br><span class="line">        <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">        <span class="keyword">this</span>.isInterface = isInterface;</span><br><span class="line">        <span class="keyword">this</span>.members = members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> superClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getInterfaces() &#123;</span><br><span class="line">        <span class="keyword">return</span> interfaces;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Member[] getMembers() &#123;</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handle <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Handle(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;  <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handle</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            Handle handle = (Handle) o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(handle.name) : handle.name == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<strong>类信息</strong>的读写格式：<code>类名 父类名 接口A,接口B,接口C 是否为接口 字段1!字段1访问标志!字段1类型!字段2!字段2访问标志!字段2类型</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">DataFactory</span>&lt;<span class="title">ClassReference</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassReference <span class="title">parse</span><span class="params">(String[] fields)</span> </span>&#123;</span><br><span class="line">        String[] interfaces;</span><br><span class="line">        <span class="keyword">if</span> (fields[<span class="number">2</span>].equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interfaces = fields[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] memberEntries = fields[<span class="number">4</span>].split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        Member[] members = <span class="keyword">new</span> Member[memberEntries.length / <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; members.length; i++) &#123;</span><br><span class="line">            members[i] = <span class="keyword">new</span> Member(memberEntries[<span class="number">3</span> * i], Integer.parseInt(memberEntries[<span class="number">3</span> * i + <span class="number">1</span>]),</span><br><span class="line">                    <span class="keyword">new</span> ClassReference.Handle(memberEntries[<span class="number">3</span> * i + <span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassReference(</span><br><span class="line">                fields[<span class="number">0</span>],</span><br><span class="line">                fields[<span class="number">1</span>].equals(<span class="string">&quot;&quot;</span>) ? <span class="keyword">null</span> : fields[<span class="number">1</span>],</span><br><span class="line">                interfaces,</span><br><span class="line">                Boolean.parseBoolean(fields[<span class="number">3</span>]),</span><br><span class="line">                members);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(ClassReference obj) &#123;</span><br><span class="line">        String interfaces;</span><br><span class="line">        <span class="keyword">if</span> (obj.interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder interfacesSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (String iface : obj.interfaces) &#123;</span><br><span class="line">                interfacesSb.append(<span class="string">&quot;,&quot;</span>).append(iface);</span><br><span class="line">            &#125;</span><br><span class="line">            interfaces = interfacesSb.substring(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interfaces = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder members = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Member member : obj.members) &#123;</span><br><span class="line">            members.append(<span class="string">&quot;!&quot;</span>).append(member.getName())</span><br><span class="line">                    .append(<span class="string">&quot;!&quot;</span>).append(Integer.toString(member.getModifiers()))</span><br><span class="line">                    .append(<span class="string">&quot;!&quot;</span>).append(member.getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                obj.name,</span><br><span class="line">                obj.superClass,</span><br><span class="line">                interfaces,</span><br><span class="line">                Boolean.toString(obj.isInterface),</span><br><span class="line">                members.length() == <span class="number">0</span> ? <span class="keyword">null</span> : members.substring(<span class="number">1</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-MethodReference"><a href="#4-MethodReference" class="headerlink" title="4. MethodReference"></a>4. MethodReference</h3><p>定义<strong>方法信息</strong>的描述方式，同样使用 asm 访问者记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassReference.Handle classReference; <span class="comment">// 所属类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;                          <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;                          <span class="comment">// 描述符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isStatic;                     <span class="comment">// 是否为静态方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodReference</span><span class="params">(ClassReference.Handle classReference, String name, String desc, <span class="keyword">boolean</span> isStatic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classReference = classReference;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        <span class="keyword">this</span>.isStatic = isStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClassReference.<span class="function">Handle <span class="title">getClassReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isStatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handle <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Handle(classReference, name, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassReference.Handle classReference; <span class="comment">// 所属类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;                          <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String desc;                          <span class="comment">// 描述符</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handle</span><span class="params">(ClassReference.Handle classReference, String name, String desc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classReference = classReference;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ClassReference.<span class="function">Handle <span class="title">getClassReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> classReference;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            Handle handle = (Handle) o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classReference != <span class="keyword">null</span> ? !classReference.equals(handle.classReference) : handle.classReference != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (name != <span class="keyword">null</span> ? !name.equals(handle.name) : handle.name != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> desc != <span class="keyword">null</span> ? desc.equals(handle.desc) : handle.desc == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = classReference != <span class="keyword">null</span> ? classReference.hashCode() : <span class="number">0</span>;</span><br><span class="line">            result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">            result = <span class="number">31</span> * result + (desc != <span class="keyword">null</span> ? desc.hashCode() : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<strong>方法信息</strong>的读写格式：<code>类名 方法名 方法描述符 是否为静态方法</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">DataFactory</span>&lt;<span class="title">MethodReference</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodReference <span class="title">parse</span><span class="params">(String[] fields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodReference(</span><br><span class="line">                <span class="keyword">new</span> ClassReference.Handle(fields[<span class="number">0</span>]),</span><br><span class="line">                fields[<span class="number">1</span>],</span><br><span class="line">                fields[<span class="number">2</span>],</span><br><span class="line">                Boolean.parseBoolean(fields[<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(MethodReference obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;</span><br><span class="line">                obj.classReference.getName(),</span><br><span class="line">                obj.name,</span><br><span class="line">                obj.desc,</span><br><span class="line">                Boolean.toString(obj.isStatic),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-inheritanceMap"><a href="#5-inheritanceMap" class="headerlink" title="5. inheritanceMap"></a>5. inheritanceMap</h3><p>定义<strong>继承信息</strong>的描述方式，包括 <code>子类-&gt;父类集合</code>、<code>父类-&gt;子类集合</code> 两个 Map 类型变量，根据类信息得出，具体实现在 <code>InheritanceMap</code> 类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritanceMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap;    <span class="comment">// 子类-&gt;父类集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap;       <span class="comment">// 父类-&gt;子类集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，从 `子类-&gt;父类集合` 得出 `父类-&gt;子类集合`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inheritanceMap 继承关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InheritanceMap</span><span class="params">(Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        subClassMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : inheritanceMap.entrySet()) &#123;</span><br><span class="line">            ClassReference.Handle child = entry.getKey();</span><br><span class="line">            <span class="keyword">for</span> (ClassReference.Handle parent : entry.getValue()) &#123;</span><br><span class="line">                <span class="comment">// 如果 key 不存在，则创建，最后返回 value</span></span><br><span class="line">                subClassMap.computeIfAbsent(parent, k -&gt; <span class="keyword">new</span> HashSet&lt;&gt;()).add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> inheritanceMap.entrySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回父类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ClassReference.Handle&gt; getSuperClasses(ClassReference.Handle clazz) &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (parents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(parents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断目标父类是否为目标子类的父类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      目标子类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> superClass 目标父类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubclassOf</span><span class="params">(ClassReference.Handle clazz, ClassReference.Handle superClass)</span> </span>&#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (parents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parents.contains(superClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回子类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ClassReference.Handle&gt; getSubClasses(ClassReference.Handle clazz) &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; subClasses = subClassMap.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (subClasses == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(subClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储继承关系：子类-&gt;父类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// inheritanceMap.dat 数据格式：</span></span><br><span class="line">        <span class="comment">// 类名 父类或超类或接口类1 父类或超类或接口类2 父类或超类或接口类3 ...</span></span><br><span class="line">        DataLoader.saveData(Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>), <span class="keyword">new</span> InheritanceMapFactory(), inheritanceMap.entrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 inheritanceMap.dat 加载继承关系信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InheritanceMap <span class="title">load</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; inheritanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : DataLoader.loadData(</span><br><span class="line">                Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>), <span class="keyword">new</span> InheritanceMapFactory())) &#123;</span><br><span class="line">            inheritanceMap.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InheritanceMap(inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<strong>继承信息</strong>的读写格式（仅针对 <code>子类-&gt;父类集合</code>）：<code>类名 父类/超类/接口类</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritanceMapFactory</span> <span class="keyword">implements</span> <span class="title">DataFactory</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">ClassReference</span>.<span class="title">Handle</span>, <span class="title">Set</span>&lt;<span class="title">ClassReference</span>.<span class="title">Handle</span>&gt;&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; parse(String[] fields) &#123;</span><br><span class="line">        ClassReference.Handle clazz = <span class="keyword">new</span> ClassReference.Handle(fields[<span class="number">0</span>]);</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; superClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            superClasses.add(<span class="keyword">new</span> ClassReference.Handle(fields[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(clazz, superClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; obj) &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] fields = <span class="keyword">new</span> String[obj.getValue().size()+<span class="number">1</span>];</span><br><span class="line">        fields[<span class="number">0</span>] = obj.getKey().getName();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle handle : obj.getValue()) &#123;</span><br><span class="line">            fields[i++] = handle.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-InheritanceDeriver"><a href="#6-InheritanceDeriver" class="headerlink" title="6. InheritanceDeriver"></a>6. InheritanceDeriver</h3><p>实现<strong>继承信息</strong>和<strong>重写方法信息</strong>的收集，存储重写信息时以缩进表示重写方法，具体存储格式在 <code>GadgetChainDiscovery</code> 中给出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritanceDeriver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(InheritanceDeriver.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取继承信息：子类-&gt;父类集合、父类-&gt;子类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classMap 类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InheritanceMap <span class="title">derive</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap)</span> </span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;Calculating inheritance for &quot;</span> + (classMap.size()) + <span class="string">&quot; classes...&quot;</span>);</span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; implicitInheritance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有类</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference classReference : classMap.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (implicitInheritance.containsKey(classReference.getHandle())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Already derived implicit classes for &quot;</span> + classReference.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;ClassReference.Handle&gt; allParents = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 classReference 的所有父类、超类、接口类</span></span><br><span class="line">            getAllParents(classReference, classMap, allParents);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加缓存：类名-&gt;所有的父类、超类、接口类</span></span><br><span class="line">            implicitInheritance.put(classReference.getHandle(), allParents);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InheritanceMap(implicitInheritance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取目标类的所有父类、超类、接口类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classReference 目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classMap       类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> allParents     父类、超类、接口类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllParents</span><span class="params">(ClassReference classReference, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Set&lt;ClassReference.Handle&gt; allParents)</span> </span>&#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = <span class="keyword">new</span> HashSet&lt;&gt;();   <span class="comment">// 已知当前父类和接口</span></span><br><span class="line">        <span class="comment">// 把当前 classReference 类的所有父类添加到 parents</span></span><br><span class="line">        <span class="keyword">if</span> (classReference.getSuperClass() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parents.add(<span class="keyword">new</span> ClassReference.Handle(classReference.getSuperClass()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把当前 classReference 类实现的所有接口添加到 parents</span></span><br><span class="line">        <span class="keyword">for</span> (String iface : classReference.getInterfaces()) &#123;</span><br><span class="line">            parents.add(<span class="keyword">new</span> ClassReference.Handle(iface));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从类数据集合中，遍历找出 classReference 的直接父类/接口</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle immediateParent : parents) &#123; <span class="comment">// 查找直接父类信息</span></span><br><span class="line">            ClassReference parentClassReference = classMap.get(immediateParent);</span><br><span class="line">            <span class="keyword">if</span> (parentClassReference == <span class="keyword">null</span>) &#123;</span><br><span class="line">                LOGGER.debug(<span class="string">&quot;No class id for &quot;</span> + immediateParent.getName());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到 allParents 父类集合中</span></span><br><span class="line">            allParents.add(parentClassReference.getHandle());</span><br><span class="line">            <span class="comment">// 递归查找，直到把 classReference 类的所有父类、超类、接口类都添加到 allParents</span></span><br><span class="line">            getAllParents(parentClassReference, classMap, allParents);  <span class="comment">// 递归查找父类的父类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类的所有重写方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inheritanceMap 继承关系</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodMap      方法信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; getAllMethodImplementations(</span><br><span class="line">            InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, MethodReference&gt; methodMap) &#123;</span><br><span class="line">        <span class="comment">// 存储类的方法，类-&gt;方法集合</span></span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodsByClass = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历方法信息，获取类-&gt;方法集合</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            ClassReference.Handle classReference = method.getClassReference();  <span class="comment">// 获取类</span></span><br><span class="line">            <span class="keyword">if</span> (!methodsByClass.containsKey(classReference)) &#123;  <span class="comment">// 避免重复</span></span><br><span class="line">                Set&lt;MethodReference.Handle&gt; methods = <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">// 存储方法</span></span><br><span class="line">                methods.add(method);</span><br><span class="line">                methodsByClass.put(classReference, methods);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                methodsByClass.get(classReference).add(method); <span class="comment">// 添加方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储继承关系，父类-&gt;子类集合</span></span><br><span class="line">        Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; subClassMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; entry : inheritanceMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 从 子类-&gt;父类集合 中取出父类</span></span><br><span class="line">            <span class="keyword">for</span> (ClassReference.Handle parent : entry.getValue()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subClassMap.containsKey(parent)) &#123; <span class="comment">// 避免重复</span></span><br><span class="line">                    Set&lt;ClassReference.Handle&gt; subClasses = <span class="keyword">new</span> HashSet&lt;&gt;();    <span class="comment">// 存储子类</span></span><br><span class="line">                    subClasses.add(entry.getKey());</span><br><span class="line">                    subClassMap.put(parent, subClasses);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subClassMap.get(parent).add(entry.getKey());    <span class="comment">// 添加子类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找重写方法</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历方法集合</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference method : methodMap.values()) &#123;</span><br><span class="line">            <span class="comment">// Static methods cannot be overriden</span></span><br><span class="line">            <span class="keyword">if</span> (method.isStatic()) &#123;    <span class="comment">// 静态方法不能被重写</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储重写方法</span></span><br><span class="line">            Set&lt;MethodReference.Handle&gt; overridingMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            Set&lt;ClassReference.Handle&gt; subClasses = subClassMap.get(method.getClassReference());    <span class="comment">// 方法所属类的子类集合</span></span><br><span class="line">            <span class="keyword">if</span> (subClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历子类</span></span><br><span class="line">                <span class="keyword">for</span> (ClassReference.Handle subClass : subClasses) &#123;</span><br><span class="line">                    <span class="comment">// This class extends ours; see if it has a matching method</span></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; subClassMethods = methodsByClass.get(subClass); <span class="comment">// 类的方法集合</span></span><br><span class="line">                    <span class="keyword">if</span> (subClassMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (MethodReference.Handle subClassMethod : subClassMethods) &#123;</span><br><span class="line">                            <span class="comment">// 判断方法名称和描述符是否相等</span></span><br><span class="line">                            <span class="keyword">if</span> (subClassMethod.getName().equals(method.getName()) &amp;&amp; subClassMethod.getDesc().equals(method.getDesc())) &#123;</span><br><span class="line">                                overridingMethods.add(subClassMethod);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在重写方法，则保存到 methodImplMap 中</span></span><br><span class="line">            <span class="keyword">if</span> (overridingMethods.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                methodImplMap.put(method.getHandle(), overridingMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methodImplMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-GraphCall"><a href="#7-GraphCall" class="headerlink" title="7. GraphCall"></a>7. GraphCall</h3><p>定义污点在<strong>调用关系</strong>中的传递信息，指的是被调用方法的参数受调用者方法的参数影响，使用 asm 访问者记录，涉及模拟 JVM 的一些操作，具体实现在 <code>CallGraphDiscovery</code> 类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphCall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle callerMethod;  <span class="comment">// 调用者（方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle targetMethod;  <span class="comment">// 被调用者（方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> callerArgIndex;   <span class="comment">// 调用者（方法）的参数索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String callerArgPath; <span class="comment">// 参数对象的哪个字段被传递</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> targetArgIndex;   <span class="comment">// 被调用者（方法）的参数索引</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphCall</span><span class="params">(MethodReference.Handle callerMethod, MethodReference.Handle targetMethod, <span class="keyword">int</span> callerArgIndex, String callerArgPath, <span class="keyword">int</span> targetArgIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callerMethod = callerMethod;</span><br><span class="line">        <span class="keyword">this</span>.targetMethod = targetMethod;</span><br><span class="line">        <span class="keyword">this</span>.callerArgIndex = callerArgIndex;</span><br><span class="line">        <span class="keyword">this</span>.callerArgPath = callerArgPath;</span><br><span class="line">        <span class="keyword">this</span>.targetArgIndex = targetArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MethodReference.<span class="function">Handle <span class="title">getCallerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callerMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MethodReference.<span class="function">Handle <span class="title">getTargetMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> targetMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCallerArgIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callerArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCallerArgPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callerArgPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTargetArgIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> targetArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;   <span class="comment">// 比较方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        GraphCall graphCall = (GraphCall) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callerArgIndex != graphCall.callerArgIndex) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetArgIndex != graphCall.targetArgIndex) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (callerMethod != <span class="keyword">null</span> ? !callerMethod.equals(graphCall.callerMethod) : graphCall.callerMethod != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetMethod != <span class="keyword">null</span> ? !targetMethod.equals(graphCall.targetMethod) : graphCall.targetMethod != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> callerArgPath != <span class="keyword">null</span> ? callerArgPath.equals(graphCall.callerArgPath) : graphCall.callerArgPath == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="comment">// 存储到键值数据格式中调用的比较方法</span></span><br><span class="line">        <span class="keyword">int</span> result = callerMethod != <span class="keyword">null</span> ? callerMethod.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (targetMethod != <span class="keyword">null</span> ? targetMethod.hashCode() : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + callerArgIndex;</span><br><span class="line">        result = <span class="number">31</span> * result + (callerArgPath != <span class="keyword">null</span> ? callerArgPath.hashCode() : <span class="number">0</span>);</span><br><span class="line">        result = <span class="number">31</span> * result + targetArgIndex;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义读写格式：<code>父类，父方法，父方法描述符，子类，被调方法，被调方法描述，父方法参数索引，父方法参数名，被调方法参数索引</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">DataFactory</span>&lt;<span class="title">GraphCall</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GraphCall <span class="title">parse</span><span class="params">(String[] fields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GraphCall(</span><br><span class="line">                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(fields[<span class="number">0</span>]), fields[<span class="number">1</span>], fields[<span class="number">2</span>]),</span><br><span class="line">                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(fields[<span class="number">3</span>]), fields[<span class="number">4</span>], fields[<span class="number">5</span>]),</span><br><span class="line">                Integer.parseInt(fields[<span class="number">6</span>]),</span><br><span class="line">                fields[<span class="number">7</span>],</span><br><span class="line">                Integer.parseInt(fields[<span class="number">8</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(GraphCall obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                obj.callerMethod.getClassReference().getName(), obj.callerMethod.getName(), obj.callerMethod.getDesc(),</span><br><span class="line">                obj.targetMethod.getClassReference().getName(), obj.targetMethod.getName(), obj.targetMethod.getDesc(),</span><br><span class="line">                Integer.toString(obj.callerArgIndex),</span><br><span class="line">                obj.callerArgPath,</span><br><span class="line">                Integer.toString(obj.targetArgIndex),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-Source"><a href="#8-Source" class="headerlink" title="8. Source"></a>8. Source</h3><p>定义<strong>污点源信息</strong>的描述方式，由实现了抽象类 <code>SourceDiscovery</code> 的类搜索和记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle sourceMethod;  <span class="comment">// 所属方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> taintedArgIndex;                  <span class="comment">// 传递污点的参数索引</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Source</span><span class="params">(MethodReference.Handle sourceMethod, <span class="keyword">int</span> taintedArgIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sourceMethod = sourceMethod;</span><br><span class="line">        <span class="keyword">this</span>.taintedArgIndex = taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MethodReference.<span class="function">Handle <span class="title">getSourceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sourceMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTaintedArgIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<strong>污点源信息</strong>的读写格式：<code>类名 方法名 方法描述符 参数索引</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">DataFactory</span>&lt;<span class="title">Source</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Source <span class="title">parse</span><span class="params">(String[] fields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Source(</span><br><span class="line">                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(fields[<span class="number">0</span>]), fields[<span class="number">1</span>], fields[<span class="number">2</span>]),</span><br><span class="line">                Integer.parseInt(fields[<span class="number">3</span>])</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(Source obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                obj.sourceMethod.getClassReference().getName(), obj.sourceMethod.getName(), obj.sourceMethod.getDesc(),</span><br><span class="line">                Integer.toString(obj.taintedArgIndex),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gadgetinspector"><a href="#gadgetinspector" class="headerlink" title="gadgetinspector"></a>gadgetinspector</h2><p>实现检测需要实现的抽象类和接口，其他类的解析放到 <strong>0x03 工作流程</strong> 一节。</p>
<h3 id="1-SerializableDecider"><a href="#1-SerializableDecider" class="headerlink" title="1. SerializableDecider"></a>1. SerializableDecider</h3><p>序列化决策者接口，判断类是否可序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents logic to decide if a class is serializable. The simple case (implemented by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> SimpleSerializableDecider&#125;) just checks if the class implements serializable. Other use-cases may have more</span></span><br><span class="line"><span class="comment"> * complicated logic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializableDecider</span> <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">ClassReference</span>.<span class="title">Handle</span>, <span class="title">Boolean</span>&gt; </span>&#123; <span class="comment">// 序列化决策者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-ImplementationFinder"><a href="#2-ImplementationFinder" class="headerlink" title="2. ImplementationFinder"></a>2. ImplementationFinder</h3><p>接口，用于查找可序列化的重写方法，即判断方法所属类是否可序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImplementationFinder</span> </span>&#123;</span><br><span class="line">    Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target); <span class="comment">// 查找可序列化的重写方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-SourceDiscovery"><a href="#3-SourceDiscovery" class="headerlink" title="3. SourceDiscovery"></a>3. SourceDiscovery</h3><p>抽象类，实现了污点源信息的存储方法，子类需要实现污点源的具体查找方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceDiscovery</span> </span>&#123; <span class="comment">// 抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存找到的污点源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Source&gt; discoveredSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加污点源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 污点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDiscoveredSource</span><span class="params">(Source source)</span> </span>&#123;</span><br><span class="line">        discoveredSources.add(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找污点源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 加载类信息</span></span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        <span class="comment">// 加载函数信息</span></span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        <span class="comment">// 加载继承信息</span></span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用实现类的 discover 方法</span></span><br><span class="line">        discover(classMap, methodMap, inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法 -&gt; 具体实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classMap       类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodMap      方法信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inheritanceMap 继承信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  InheritanceMap inheritanceMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用工厂方法存储污点源信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataLoader.saveData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> Source.Factory(), discoveredSources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="gadgetinspector-config"><a href="#gadgetinspector-config" class="headerlink" title="gadgetinspector/config"></a>gadgetinspector/config</h2><p>定义配置。</p>
<h3 id="1-GIConfig"><a href="#1-GIConfig" class="headerlink" title="1. GIConfig"></a>1. GIConfig</h3><p>配置接口，所有检测实现都必须实现该接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GIConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化决策者</span></span><br><span class="line">    <span class="function">SerializableDecider <span class="title">getSerializableDecider</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找可序列化的重写方法</span></span><br><span class="line">    <span class="function">ImplementationFinder <span class="title">getImplementationFinder</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 InheritanceMap inheritanceMap)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找污点源</span></span><br><span class="line">    <span class="function">SourceDiscovery <span class="title">getSourceDiscovery</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-ConfigRepository"><a href="#2-ConfigRepository" class="headerlink" title="2. ConfigRepository"></a>2. ConfigRepository</h3><p>定义配置列表，用于返回配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigRepository</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 配置列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;GIConfig&gt; ALL_CONFIGS = Collections.unmodifiableList(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> JavaDeserializationConfig(),        <span class="comment">// Java 原生序列化</span></span><br><span class="line">            <span class="keyword">new</span> JacksonDeserializationConfig(),     <span class="comment">// Jackson（Json）</span></span><br><span class="line">            <span class="keyword">new</span> XstreamDeserializationConfig()));   <span class="comment">// XStream（XML）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 配置名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GIConfig <span class="title">getConfig</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (GIConfig config : ALL_CONFIGS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (config.getName().equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> config;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-GIConfig-接口实现"><a href="#3-GIConfig-接口实现" class="headerlink" title="3. GIConfig 接口实现"></a>3. GIConfig 接口实现</h3><p>JavaDeserializationConfig</p>
<ul>
<li>配置名称：<code>jserial</code></li>
<li>序列化决策者：gadgetinspector/javaserial/SimpleSerializableDecider</li>
<li>查找可序列化的重写方法：gadgetinspector/javaserial/SimpleImplementationFinder</li>
<li>查找污点源：gadgetinspector/javaserial/SimpleSourceDiscovery</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDeserializationConfig</span> <span class="keyword">implements</span> <span class="title">GIConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jserial&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SerializableDecider <span class="title">getSerializableDecider</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleSerializableDecider(inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImplementationFinder <span class="title">getImplementationFinder</span><span class="params">(Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleImplementationFinder(getSerializableDecider(methodMap, inheritanceMap), methodImplMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceDiscovery <span class="title">getSourceDiscovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleSourceDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JacksonDeserializationConfig</p>
<ul>
<li>配置名称：<code>jackson</code></li>
<li>序列化决策者：gadgetinspector/jackson/JacksonSerializableDecider</li>
<li>查找可序列化的重写方法：gadgetinspector/jackson/JacksonImplementationFinder</li>
<li>查找污点源：gadgetinspector/jackson/JacksonSourceDiscovery</li>
</ul>
<p>XstreamDeserializationConfig</p>
<ul>
<li>配置名称：<code>xstream</code></li>
<li>序列化决策者：gadgetinspector/xstream/XstreamSerializableDecider、gadgetinspector/xstream/CustomXstreamSerializableDecider</li>
<li>查找可序列化的重写方法：gadgetinspector/javaserial/SimpleImplementationFinder</li>
<li>查找污点源：gadgetinspector/javaserial/SimpleSourceDiscovery</li>
</ul>
<h2 id="gadgetinspector-javaserial"><a href="#gadgetinspector-javaserial" class="headerlink" title="gadgetinspector/javaserial"></a>gadgetinspector/javaserial</h2><p>针对 Java 原生序列化的反序列化利用链检测实现。</p>
<h3 id="1-SimpleSerializableDecider"><a href="#1-SimpleSerializableDecider" class="headerlink" title="1. SimpleSerializableDecider"></a>1. SimpleSerializableDecider</h3><p>实现 <code>SerializableDecider</code> 接口，判断类是否可序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSerializableDecider</span> <span class="keyword">implements</span> <span class="title">SerializableDecider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, Boolean&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// 缓存判断结果，类-&gt;是否可序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;    <span class="comment">// 继承信息</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleSerializableDecider</span><span class="params">(InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类是否可以序列化，并将判断结果添加到缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handle 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">apply</span><span class="params">(ClassReference.Handle handle)</span> </span>&#123;</span><br><span class="line">        Boolean cached = cache.get(handle);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Boolean result = applyNoCache(handle);</span><br><span class="line"></span><br><span class="line">        cache.put(handle, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类是否可以序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handle 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">applyNoCache</span><span class="params">(ClassReference.Handle handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断类是否在黑名单内</span></span><br><span class="line">        <span class="keyword">if</span> (isBlacklistedClass(handle)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有直接或间接实现 java/io/Serializable 序列化接口</span></span><br><span class="line">        <span class="keyword">if</span> (inheritanceMap.isSubclassOf(handle, <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;java/io/Serializable&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断类是否在黑名单内</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlacklistedClass</span><span class="params">(ClassReference.Handle clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz.getName().startsWith(<span class="string">&quot;com/google/common/collect/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Serialization of these classes has been disabled since clojure 1.9.0</span></span><br><span class="line">        <span class="comment">// https://github.com/clojure/clojure/commit/271674c9b484d798484d134a5ac40a6df15d3ac3</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.getName().equals(<span class="string">&quot;clojure/core/proxy$clojure/lang/APersistentMap$ff19274a&quot;</span>)</span><br><span class="line">                || clazz.getName().equals(<span class="string">&quot;clojure/inspector/proxy$javax/swing/table/AbstractTableModel$ff19274a&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SimpleImplementationFinder"><a href="#2-SimpleImplementationFinder" class="headerlink" title="2. SimpleImplementationFinder"></a>2. SimpleImplementationFinder</h3><p>实现 <code>ImplementationFinder</code> 接口，返回目标方法的可序列化重写方法（包括目标方法本身）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleImplementationFinder</span> <span class="keyword">implements</span> <span class="title">ImplementationFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;  <span class="comment">// 序列化决策者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap;   <span class="comment">// 重写方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleImplementationFinder</span><span class="params">(SerializableDecider serializableDecider, Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializableDecider = serializableDecider;</span><br><span class="line">        <span class="keyword">this</span>.methodImplMap = methodImplMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target) &#123;</span><br><span class="line">        <span class="comment">// 存储可序列化的重写方法</span></span><br><span class="line">        Set&lt;MethodReference.Handle&gt; allImpls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assume that the target method is always available, even if not serializable; the target may just be a local</span></span><br><span class="line">        <span class="comment">// instance rather than something an attacker can control.</span></span><br><span class="line">        allImpls.add(target);   <span class="comment">// 默认认为目标方法可序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历重写方法</span></span><br><span class="line">        Set&lt;MethodReference.Handle&gt; subClassImpls = methodImplMap.get(target);</span><br><span class="line">        <span class="keyword">if</span> (subClassImpls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodReference.Handle subClassImpl : subClassImpls) &#123;</span><br><span class="line">                <span class="comment">// 判断是否可序列化</span></span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(subClassImpl.getClassReference()))) &#123;</span><br><span class="line">                    allImpls.add(subClassImpl); <span class="comment">// 添加到 allImpls</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allImpls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-SimpleSourceDiscovery"><a href="#3-SimpleSourceDiscovery" class="headerlink" title="3. SimpleSourceDiscovery"></a>3. SimpleSourceDiscovery</h3><p>继承 <code>SourceDiscovery</code> 抽象类，实现具体的污点源查找方法 <code>discover</code>。遍历类信息和方法信息，根据定义的 5 条规则搜索污点源：</p>
<ul>
<li>方法所属类可以序列化，且方法为无参数 void 类型的 finalize 方法</li>
<li>方法所属类可以序列化，且方法为接受 ObjectInputStream 类型参数的 void 类型的 readObject 方法</li>
<li>类可以序列化，且为 InvocationHandler 的子类</li>
<li>方法所属类可以序列化，且方法为无参数 int 类型的 hashCode 方法或接受 Object 类型参数的 boolean 类型的 equals 方法</li>
<li>方法所属类可以序列化，且该类为 groovy Closure 的子类、方法为 call 或 doCall</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDiscovery</span> <span class="keyword">extends</span> <span class="title">SourceDiscovery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                         InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化决策者，用于判断类是否可序列化</span></span><br><span class="line">        <span class="keyword">final</span> SerializableDecider serializableDecider = <span class="keyword">new</span> SimpleSerializableDecider(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 判断所属类是否可序列化</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="comment">// 如果是 finalize 方法则认为是受污染的</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;finalize&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法，和上面的类似（可以合并）</span></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="comment">// 如果所属类实现了 readObject，则传入的 ObjectInputStream 参数被认为是受污染的</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;readObject&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/io/ObjectInputStream;)V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历类</span></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 判断类是否可序列化，且是否为 InvocationHandler 的子类</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>))) &#123;</span><br><span class="line">                <span class="comment">// 使用代理时，任何扩展 InvocationHandler 的类都被认为受污染</span></span><br><span class="line">                MethodReference.Handle method = <span class="keyword">new</span> MethodReference.Handle(</span><br><span class="line">                        clazz, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法，和上面的类似（可以合并）</span></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects</span></span><br><span class="line">        <span class="comment">// into a HashMap.</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="comment">// 如果是 hashCode 方法则认为是受污染的（注意描述符）</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;hashCode&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()I&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是 equals 方法则认为是受污染的（注意描述符）</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法，和上面的类似（可以合并）</span></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 使用比较器代理，可以跳转到任何 groovy Closure 的 call()/doCall() 方法，所有的参数都被污染</span></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;groovy/lang/Closure&quot;</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">&quot;call&quot;</span>) || method.getName().equals(<span class="string">&quot;doCall&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SourceDiscovery sourceDiscovery = <span class="keyword">new</span> SimpleSourceDiscovery();</span><br><span class="line">        sourceDiscovery.discover();</span><br><span class="line">        sourceDiscovery.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x03-工作流程"><a href="#0x03-工作流程" class="headerlink" title="0x03 工作流程"></a>0x03 工作流程</h1><ol>
<li>准备工作<ul>
<li>配置 log4j 向控制台输出日志</li>
<li>配置 config 为默认值 jserial（Java 反序列化）</li>
<li>接受参数：<code>--resume</code> 保留 .dat 文件、<code>--config</code> 指定分析类型</li>
<li>根据参数读取 war/jar 包路径，返回 URLClassLoader</li>
<li>初始化类枚举加载器 ClassResourceEnumerator</li>
</ul>
</li>
<li>MethodDiscovery：类信息、方法信息、继承信息<ul>
<li>classes.dat：类名、父类名、类接口名、是否为接口、类的所有字段（成员）</li>
<li>methods.dat：类名、方法名、描述符、是否为静态方法</li>
<li>inheritanceMap.dat：类名、父类/超类/接口类（直接/间接父类）</li>
</ul>
</li>
<li>PassthroughDiscovery：数据流信息，即方法参数是否能够影响其返回值<ul>
<li>如果存在方法将参数传递给被调方法时，需要先判断被调方法返回值与被调方法参数的关系。</li>
<li>passthrough.dat：类名、方法名、方法描述符、污点参数索引</li>
</ul>
</li>
<li>CallGraphDiscovery：方法调用关系信息<ul>
<li>callgraph.dat：方法所属类名，方法名，方法描述符，被调方法所属类名，被调方法名，被调方法描述，方法参数索引，方法参数对象的字段名称，被调方法参数索引</li>
</ul>
</li>
<li>SourceDiscovery：查找污点源<ul>
<li>sources.dat：类名，方法名，描述符，参数索引</li>
</ul>
</li>
<li>GadgetChainDiscovery：重写信息、利用链信息<ul>
<li>methodimpl.dat：类名，方法名，描述符</li>
<li>gadget-chains.txt：类名.方法名描述符 (参数索引)</li>
</ul>
</li>
</ol>
<h2 id="1-Util"><a href="#1-Util" class="headerlink" title="1. Util"></a>1. Util</h2><p>根据 java 包路径列表返回 URLClassLoader，后续用于读取相应的 java 包（war、jar）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Util.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 war 包路径列表，构造并返回 URLClassLoader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> warPath 包路径列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getWarClassLoader</span><span class="params">(Path warPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建临时文件夹</span></span><br><span class="line">        <span class="keyword">final</span> Path tmpDir = Files.createTempDirectory(<span class="string">&quot;exploded-war&quot;</span>);</span><br><span class="line">        <span class="comment">// Delete the temp directory at shutdown</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                deleteDirectory(tmpDir);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error cleaning up temp directory &quot;</span> + tmpDir.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制到临时文件夹</span></span><br><span class="line">        <span class="comment">// Extract to war to the temp directory</span></span><br><span class="line">        <span class="keyword">try</span> (JarInputStream jarInputStream = <span class="keyword">new</span> JarInputStream(Files.newInputStream(warPath))) &#123;</span><br><span class="line">            JarEntry jarEntry;</span><br><span class="line">            <span class="keyword">while</span> ((jarEntry = jarInputStream.getNextJarEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Path fullPath = tmpDir.resolve(jarEntry.getName());</span><br><span class="line">                <span class="keyword">if</span> (!jarEntry.isDirectory()) &#123;</span><br><span class="line">                    Path dirName = fullPath.getParent();</span><br><span class="line">                    <span class="keyword">if</span> (dirName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Parent of item is outside temp directory.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!Files.exists(dirName)) &#123;</span><br><span class="line">                        Files.createDirectories(dirName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> (OutputStream outputStream = Files.newOutputStream(fullPath)) &#123;</span><br><span class="line">                        copy(jarInputStream, outputStream);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储包路径</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;URL&gt; classPathUrls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        classPathUrls.add(tmpDir.resolve(<span class="string">&quot;WEB-INF/classes&quot;</span>).toUri().toURL());</span><br><span class="line">        Files.list(tmpDir.resolve(<span class="string">&quot;WEB-INF/lib&quot;</span>)).forEach(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classPathUrls.add(p.toUri().toURL());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(classPathUrls.toArray(<span class="keyword">new</span> URL[classPathUrls.size()]));</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 jar 包路径列表，构造并返回 URLClassLoader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jarPaths 包路径列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getJarClassLoader</span><span class="params">(Path... jarPaths)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 存储包路径</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;URL&gt; classPathUrls = <span class="keyword">new</span> ArrayList&lt;&gt;(jarPaths.length);</span><br><span class="line">        <span class="comment">// 遍历包路径列表</span></span><br><span class="line">        <span class="keyword">for</span> (Path jarPath : jarPaths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Files.exists(jarPath) || Files.isDirectory(jarPath)) &#123; <span class="comment">// 查找文件</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Path \&quot;&quot;</span> + jarPath + <span class="string">&quot;\&quot; is not a path to a file.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            classPathUrls.add(jarPath.toUri().toURL()); <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(classPathUrls.toArray(<span class="keyword">new</span> URL[classPathUrls.size()]));</span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recursively delete the directory root and all its contents</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root Root directory to be deleted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDirectory</span><span class="params">(Path root)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.walkFileTree(root, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(file);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Files.delete(dir);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy inputStream to outputStream. Neither stream is closed by this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(InputStream inputStream, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = inputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputStream.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-ClassResourceEnumerator"><a href="#2-ClassResourceEnumerator" class="headerlink" title="2. ClassResourceEnumerator"></a>2. ClassResourceEnumerator</h2><p>定义类资源接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;    <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类资源具体实现：</p>
<ul>
<li><code>PathClassResource</code>：直接从路径读取类文件，用于通过 JRT 文件系统读取路径下的类文件（运行时）</li>
<li><code>ClassLoaderClassResource</code>：使用已有的 ClassLoader 读取类文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从路径读取类文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassResource</span> <span class="keyword">implements</span> <span class="title">ClassResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PathClassResource</span><span class="params">(Path path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Files.newInputStream(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ClassLoader 读取类文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderClassResource</span> <span class="keyword">implements</span> <span class="title">ClassResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String resourceName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoaderClassResource</span><span class="params">(ClassLoader classLoader, String resourceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">        <span class="keyword">this</span>.resourceName = resourceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classLoader.getResourceAsStream(resourceName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回运行时的所有类和指定 java 包中的类，这里的运行时类指 JDK 中的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 java 运行时的类和指定的 java 包中的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;ClassResource&gt; <span class="title">getAllClasses</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 先加载运行时类（bootstrap classes）</span></span><br><span class="line">    Collection&lt;ClassResource&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(getRuntimeClasses());</span><br><span class="line">    <span class="comment">// 使用 ClassLoader 加载用户指定的 java 包</span></span><br><span class="line">    <span class="keyword">for</span> (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ClassLoaderClassResource(classLoader, classInfo.getResourceName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回运行时的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;ClassResource&gt; <span class="title">getRuntimeClasses</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Java8 及以前的运行时类可以通过读取 rt.jar 文件获取</span></span><br><span class="line">    <span class="comment">// A hacky way to get the current JRE&#x27;s rt.jar. Depending on the class loader, rt.jar may be in the</span></span><br><span class="line">    <span class="comment">// bootstrap classloader so all the JDK classes will be excluded from classpath scanning with this!</span></span><br><span class="line">    <span class="comment">// However, this only works up to Java 8, since after that Java uses some crazy module magic.</span></span><br><span class="line">    URL stringClassUrl = Object.class.getResource(<span class="string">&quot;String.class&quot;</span>);</span><br><span class="line">    URLConnection connection = stringClassUrl.openConnection();</span><br><span class="line">    Collection&lt;ClassResource&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">        URL runtimeUrl = ((JarURLConnection) connection).getJarFileURL();</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;runtimeUrl&#125;);</span><br><span class="line">        <span class="keyword">for</span> (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ClassLoaderClassResource(classLoader, classInfo.getResourceName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Java9 及以后的运行时类通过 JRT 文件系统读取路径下的类文件</span></span><br><span class="line">    <span class="comment">// https://stackoverflow.com/questions/1240387/where-are-the-java-system-packages-stored/53897006#53897006</span></span><br><span class="line">    <span class="comment">// Try finding all the JDK classes using the Java9+ modules method:</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileSystem fs = FileSystems.getFileSystem(URI.create(<span class="string">&quot;jrt:/&quot;</span>));</span><br><span class="line">        Files.walk(fs.getPath(<span class="string">&quot;/&quot;</span>)).forEach(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.toString().toLowerCase().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> PathClassResource(p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// Do nothing; this is expected on versions below Java9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-GadgetInspector"><a href="#3-GadgetInspector" class="headerlink" title="3. GadgetInspector"></a>3. GadgetInspector</h2><p>程序入口 <code>main</code>，先做一些准备工作，然后分 5 步走挖掘利用链。</p>
<p>首先判断参数是否为空，使用 Gadget Inspector 至少要指定一个待分析的 java 包，若参数为空则打印使用帮助。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">    printUsage();   <span class="comment">// 打印使用帮助</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置日志输出、.dat 文件保留、挖掘类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 log4j 用于输出日志</span></span><br><span class="line">configureLogging();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否保留所有的 .dat 文件</span></span><br><span class="line"><span class="keyword">boolean</span> resume = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖掘类型，默认为 java 原生序列化</span></span><br><span class="line">GIConfig config = ConfigRepository.getConfig(<span class="string">&quot;jserial&quot;</span>);    <span class="comment">// 实现 SerializableDecider、ImplementationFinder、SourceDiscovery</span></span><br></pre></td></tr></table></figure>

<p>解析参数，可选参数包括：</p>
<ul>
<li><code>--resume</code>：是否保留文件，默认不保留</li>
<li><code>--config xxx</code>：指定挖掘类型，默认 Java 原生序列化 <code>jserial</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (argIndex &lt; args.length) &#123;</span><br><span class="line">    String arg = args[argIndex];</span><br><span class="line">    <span class="keyword">if</span> (!arg.startsWith(<span class="string">&quot;--&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg.equals(<span class="string">&quot;--resume&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 保留 .dat 文件</span></span><br><span class="line">        resume = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">&quot;--config&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 指定挖掘类型</span></span><br><span class="line">        config = ConfigRepository.getConfig(args[++argIndex]);</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid config name: &quot;</span> + args[argIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected argument: &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据参数读取 war 包或 jar 包，可以指定 1 个 war 包或多个 jar 包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是 URLClassLoader</span></span><br><span class="line"><span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对指定文件根据 war、spring-boot jar、普通 jar 包的方式载入对于字节码文件，并返回 URLClassLoader</span></span><br><span class="line"><span class="keyword">if</span> (args.length == argIndex + <span class="number">1</span> &amp;&amp; args[argIndex].toLowerCase().endsWith(<span class="string">&quot;.war&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 构造 war 文件路径</span></span><br><span class="line">    Path path = Paths.get(args[argIndex]);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Using WAR classpath: &quot;</span> + path);</span><br><span class="line">    <span class="comment">// 实现为 URLClassLoader，加载 war 包下的 WEB-INF/lib 和 WEB-INF/classes</span></span><br><span class="line">    classLoader = Util.getWarClassLoader(path);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造 jar 文件路径，可配置多个</span></span><br><span class="line">    <span class="keyword">final</span> Path[] jarPaths = <span class="keyword">new</span> Path[args.length - argIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length - argIndex; i++) &#123;</span><br><span class="line">        Path path = Paths.get(args[argIndex + i]).toAbsolutePath();</span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(path)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid jar path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        jarPaths[i] = path;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Using classpath: &quot;</span> + Arrays.toString(jarPaths));</span><br><span class="line">    <span class="comment">// 实现为 URLClassLoader，加载所有指定的 jar</span></span><br><span class="line">    classLoader = Util.getJarClassLoader(jarPaths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面得到的 ClassLoader 初始化类枚举加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator = <span class="keyword">new</span> ClassResourceEnumerator(classLoader);</span><br></pre></td></tr></table></figure>

<p>根据 <code>resume</code> 变量的值决定是否删除 .dat 文件，挖掘到的利用链存储在 gadget-chains.txt 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!resume) &#123;</span><br><span class="line">    <span class="comment">// Delete all existing dat files</span></span><br><span class="line">    LOGGER.info(<span class="string">&quot;Deleting stale data...&quot;</span>);</span><br><span class="line">    <span class="comment">// 挖掘到的利用链存储在 gadget-chains.txt 中，不删除</span></span><br><span class="line">    <span class="keyword">for</span> (String datFile : Arrays.asList(<span class="string">&quot;classes.dat&quot;</span>, <span class="string">&quot;methods.dat&quot;</span>, <span class="string">&quot;inheritanceMap.dat&quot;</span>,</span><br><span class="line">            <span class="string">&quot;passthrough.dat&quot;</span>, <span class="string">&quot;callgraph.dat&quot;</span>, <span class="string">&quot;sources.dat&quot;</span>, <span class="string">&quot;methodimpl.dat&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Path path = Paths.get(datFile);</span><br><span class="line">        <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">            Files.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挖掘过程中判断是否存在 .dat 文件，核心步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perform the various discovery steps</span></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;classes.dat&quot;</span>)) || !Files.exists(Paths.get(<span class="string">&quot;methods.dat&quot;</span>))</span><br><span class="line">        || !Files.exists(Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Running method discovery...&quot;</span>);</span><br><span class="line">    MethodDiscovery methodDiscovery = <span class="keyword">new</span> MethodDiscovery();</span><br><span class="line">    methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">    methodDiscovery.save(); <span class="comment">// 保存类信息、方法信息、继承信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Analyzing methods for passthrough dataflow...&quot;</span>);</span><br><span class="line">    PassthroughDiscovery passthroughDiscovery = <span class="keyword">new</span> PassthroughDiscovery();</span><br><span class="line">    passthroughDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    passthroughDiscovery.save();    <span class="comment">// 保存数据流信息（方法参数和返回值的关系信息）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Analyzing methods in order to build a call graph...&quot;</span>);</span><br><span class="line">    CallGraphDiscovery callGraphDiscovery = <span class="keyword">new</span> CallGraphDiscovery();</span><br><span class="line">    callGraphDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    callGraphDiscovery.save();  <span class="comment">// 保存调用关系信息（调用者方法与被调方法之间的参数传递）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;sources.dat&quot;</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Discovering gadget chain source methods...&quot;</span>);</span><br><span class="line">    SourceDiscovery sourceDiscovery = config.getSourceDiscovery();</span><br><span class="line">    sourceDiscovery.discover();</span><br><span class="line">    sourceDiscovery.save(); <span class="comment">// 保存污点源信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Searching call graph for gadget chains...&quot;</span>);</span><br><span class="line">    GadgetChainDiscovery gadgetChainDiscovery = <span class="keyword">new</span> GadgetChainDiscovery(config);</span><br><span class="line">    gadgetChainDiscovery.discover();    <span class="comment">// 保存重写信息、利用链信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心步骤看起来有多简单实际实现就有多复杂（<del>不是</del>），下面就展开核心步骤的内容。</p>
<h2 id="4-MethodDiscovery"><a href="#4-MethodDiscovery" class="headerlink" title="4. MethodDiscovery"></a>4. MethodDiscovery</h2><p><code>discover</code> 方法主要完成的是读取类文件并利用 asm 的访问者记录类信息、方法信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用访问者记录类信息和方法信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有的类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123; <span class="comment">// 读取类文件</span></span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(in);   <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 继承 asm 的 ClassVisitor(MethodVisitor) 实现对类文件的观察，记录类信息和方法信息</span></span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitField -&gt; visitMethod -&gt; visitEnd</span></span><br><span class="line">                cr.accept(<span class="keyword">new</span> MethodDiscoveryClassVisitor(), ClassReader.EXPAND_FRAMES);    <span class="comment">// 以扩展格式访问堆栈映射帧</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Exception analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodDiscoveryClassVisitor</code> 类继承了 asm 中的 ClassVisitor，重写了四个访问者方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;            <span class="comment">// 类的内部名称</span></span><br><span class="line"><span class="keyword">private</span> String superName;       <span class="comment">// 父类的内部名称</span></span><br><span class="line"><span class="keyword">private</span> String[] interfaces;    <span class="comment">// 类接口的内部名称</span></span><br><span class="line"><span class="keyword">boolean</span> isInterface;            <span class="comment">// 是否为接口</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ClassReference.Member&gt; members;    <span class="comment">// 类的所有字段</span></span><br><span class="line"><span class="keyword">private</span> ClassReference.Handle classHandle;      <span class="comment">// 引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MethodDiscoveryClassVisitor</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Opcodes.ASM6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visit</code> 方法在类访问的开始时调用（即 <code>ClassReader.accept</code> 调用的第一个访问者方法），记录类名、父类名、接口名、是否为接口，创建动态数组用于在 <code>visitField</code> 中记录字段信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;  <span class="comment">// 类访问开始（调用的第一个方法）</span></span><br><span class="line">    <span class="comment">// 记录类信息</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.superName = superName;</span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="keyword">this</span>.isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.members = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">// 字段信息（成员）</span></span><br><span class="line">    <span class="keyword">this</span>.classHandle = <span class="keyword">new</span> ClassReference.Handle(name); <span class="comment">// 当前类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitField</code> 方法用于记录类的字段信息，包括名称、访问标志、类型，根据访问标志 <code>access</code> 判断是否为静态变量，因为静态变量不可控所以不当作可能的污点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,    // 访问字段</span></span></span><br><span class="line"><span class="function"><span class="params">                               String signature, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123; <span class="comment">// 跳过静态成员</span></span><br><span class="line">        Type type = Type.getType(desc); <span class="comment">// 类型</span></span><br><span class="line">        String typeName;</span><br><span class="line">        <span class="keyword">if</span> (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) &#123;    <span class="comment">// 对象或数组</span></span><br><span class="line">            typeName = type.getInternalName();  <span class="comment">// 内部名称</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeName = type.getDescriptor();    <span class="comment">// 描述符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录字段信息，保存到 members</span></span><br><span class="line">        members.add(<span class="keyword">new</span> ClassReference.Member(name, access, <span class="keyword">new</span> ClassReference.Handle(typeName)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitMethod</code> 方法用于记录方法信息，包括所属类名、方法名、描述符、是否为静态方法，同样根据访问标志判断是否为静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123; <span class="comment">// 访问方法</span></span><br><span class="line">    <span class="keyword">boolean</span> isStatic = (access &amp; Opcodes.ACC_STATIC) != <span class="number">0</span>;  <span class="comment">// 是否为静态方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录方法信息，保存到 discoveredMethods</span></span><br><span class="line">    discoveredMethods.add(<span class="keyword">new</span> MethodReference(</span><br><span class="line">            classHandle,    <span class="comment">// 所属类</span></span><br><span class="line">            name,</span><br><span class="line">            desc,</span><br><span class="line">            isStatic));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitEnd</code> 方法在类访问结束时调用，（即 <code>ClassReader.accept</code> 调用的最后一个访问者方法），此时类的字段信息已经记录完毕，可以记录下完整的类信息，包括类名、父类名、接口名、是否为接口、字段信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;    <span class="comment">// 类访问结束（调用的最后一个方法）</span></span><br><span class="line">    ClassReference classReference = <span class="keyword">new</span> ClassReference(</span><br><span class="line">            name,</span><br><span class="line">            superName,</span><br><span class="line">            interfaces,</span><br><span class="line">            isInterface,</span><br><span class="line">            members.toArray(<span class="keyword">new</span> ClassReference.Member[members.size()])); <span class="comment">// 把所有找到的字段封装</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录类信息，保存到 discoveredClasses</span></span><br><span class="line">    discoveredClasses.add(classReference);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">super</span>.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>save</code> 方法存储收集到的类信息和方法信息，同时调用 <code>InheritanceDeriver.derive</code> 获取继承信息并保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法存储数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// classes.dat 数据格式：</span></span><br><span class="line">    <span class="comment">// 类名 父类名 接口A,接口B,接口C 是否为接口 字段1!字段1描述符!字段1类型!字段2!字段2描述符!字段2类型</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;classes.dat&quot;</span>), <span class="keyword">new</span> ClassReference.Factory(), discoveredClasses);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// methods.dat 数据格式：</span></span><br><span class="line">    <span class="comment">// 类名 方法名 方法描述符 是否为静态方法</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;methods.dat&quot;</span>), <span class="keyword">new</span> MethodReference.Factory(), discoveredMethods);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ClassReference clazz : discoveredClasses) &#123;</span><br><span class="line">        classMap.put(clazz.getHandle(), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对上面的类信息进行递归整合，得到 `子类-&gt;父类集合` 的继承信息，保存到 inheritanceMap.dat</span></span><br><span class="line">    InheritanceDeriver.derive(classMap).save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-PassthroughDiscovery"><a href="#5-PassthroughDiscovery" class="headerlink" title="5. PassthroughDiscovery"></a>5. PassthroughDiscovery</h2><p><code>discover</code> 方法主要执行了三个步骤：① 搜索方法调用信息，即每个方法都调用了哪些方法；② 将调用信息进行逆拓扑排序，为了便于后续分析；③ 分析每个方法的参数，判断是否能够传递污染，即方法的返回结果是否可以被其参数影响。</p>
<p>例如以下两个方法中，foo 方法的返回结果可以被参数控制，而 bar 方法的返回结果无法被控制。因此如果污点（攻击者的输入数据）走到 bar 方法就不能再继续下去了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foo</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">bar</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>discover</code> 方法的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法调用信息：方法-&gt;调用的方法集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodCalls = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到每个方法能够传递污染的参数（索引）集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config                  配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, <span class="keyword">final</span> GIConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载方法信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">    <span class="comment">// 加载类信息</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">    <span class="comment">// 加载继承信息（inheritanceMap：子类-&gt;父类集合，subClassMap：父类-&gt;子类集合）</span></span><br><span class="line">    InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索方法的调用关系（methodCalls）并得到 `类名-&gt;类资源` 映射集合</span></span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对方法的调用关系进行逆拓扑排序</span></span><br><span class="line">    List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分析每个方法能够传递污染的参数</span></span><br><span class="line">    <span class="comment">// classResourceByName  类资源集合</span></span><br><span class="line">    <span class="comment">// classMap             类信息</span></span><br><span class="line">    <span class="comment">// inheritanceMap       继承信息</span></span><br><span class="line">    <span class="comment">// sortedMethods        方法集合（经逆拓扑排序）</span></span><br><span class="line">    <span class="comment">// SerializableDecider  序列化决策者</span></span><br><span class="line">    passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods,</span><br><span class="line">            config.getSerializableDecider(methodMap, inheritanceMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>discoverMethodCalls</code> 方法利用 asm 的访问者记录方法调用的方法集合信息，同时存储类名和类资源的映射关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索方法调用信息：方法-&gt;被调用方法集合</span></span><br><span class="line"><span class="comment"> * 存储类资源映射信息：类名-&gt;类资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, ClassResourceEnumerator.ClassResource&gt; discoverMethodCalls(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 类名-&gt;类资源</span></span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourcesByName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有的类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123; <span class="comment">// 读取类文件</span></span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(in);   <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 继承 asm 的 ClassVisitor(MethodVisitor) 实现对类文件的观察</span></span><br><span class="line">                MethodCallDiscoveryClassVisitor visitor = <span class="keyword">new</span> MethodCallDiscoveryClassVisitor(Opcodes.ASM6);</span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitMethod -&gt; visitEnd</span></span><br><span class="line">                cr.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                <span class="comment">// 存储 `类名(String)-&gt;类资源(ClassResource)` 的映射关系</span></span><br><span class="line">                classResourcesByName.put(visitor.getName(), classResource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classResourcesByName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodCallDiscoveryClassVisitor</code> 类继承了 asm 中的 ClassVisitor，重写了三个访问者方法，并实现了一个返回类名的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCallDiscoveryClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodCallDiscoveryClassVisitor</span><span class="params">(<span class="keyword">int</span> api)</span> </span>&#123;   <span class="comment">// 访问者实现的 ASM API 版本，必须是 Opcodes.</span></span><br><span class="line">        <span class="keyword">super</span>(api);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="keyword">null</span>; <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回类名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visit</code> 方法只记录了当前访问的类的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">                  String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类方法</span></span><br><span class="line">    <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;ClassVisitor already visited a class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录类名</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitMethod</code> 方法使用 <code>MethodCallDiscoveryMethodVisitor</code> 类（继承了 asm 中的 MethodVisitor）观察方法，并调用 <code>JSRInlinerAdapter</code> 简化代码分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">    MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    <span class="comment">// 创建 MethodCallDiscoveryMethodVisitor 观察方法</span></span><br><span class="line">    MethodCallDiscoveryMethodVisitor modelGeneratorMethodVisitor = <span class="keyword">new</span> MethodCallDiscoveryMethodVisitor(</span><br><span class="line">            api, mv, <span class="keyword">this</span>.name, name, desc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简化代码分析，删除 JSR 指令并内联引用的子例程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitEnd</code> 方法直接调用的父类方法，在这里不重写应该可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodCallDiscoveryMethodVisitor</code> 类继承了 asm 中的 MethodVisitor，只重写了 <code>visitMethodInsn</code> 方法，用于访问调用方法的指令；利用 <code>calledMethods</code> 记录当前访问的方法调用的所有方法，然后记录到 <code>methodCalls</code> 变量中，这里不注意点就看混了😵。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCallDiscoveryMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法调用的方法集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;MethodReference.Handle&gt; calledMethods;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法访问者构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> api   ASM API 版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mv    MethodVisitor 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> owner 方法所属类的类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  方法的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc  方法的描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodCallDiscoveryMethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> api, <span class="keyword">final</span> MethodVisitor mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">final</span> String owner, String name, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api, mv);</span><br><span class="line">        <span class="comment">// 调用的方法集合，初始化</span></span><br><span class="line">        <span class="keyword">this</span>.calledMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存储到 PassthroughDiscovery 的 methodCalls 中</span></span><br><span class="line">        methodCalls.put(<span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc), calledMethods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问方法指令</span></span><br><span class="line"><span class="comment">     * 方法指令是调用方法的指令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> opcode 调用操作码：INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> owner  被调用的方法所属类的类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name   被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc   被调用方法的描述符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> itf    被调用的类是否为接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录调用的方法，存储到 MethodCallDiscoveryMethodVisitor 的 calledMethods 中</span></span><br><span class="line">        calledMethods.add(<span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc));</span><br><span class="line">        <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>topologicallySortMethodCalls</code> 方法对方法调用的方法集合进行逆拓扑排序，用于后续判断方法参数与返回值的关系，举个例子：</p>
<p>方法 parentMethod 在返回前调用了 Obj.childMethod，因为 Obj.childMethod 的参数 carg 与返回值有关，同时 parentMethod 将其返回值作为自己的返回结果，所以最后可以判定 parentMethod 的参数 arg 和返回值有关。</p>
<p>因此要先判断子方法返回值与子方法参数的关系，再判断父方法返回值与参数的关系，这样才能判断方法参数与返回值的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">parentMethod</span><span class="params">(String arg)</span></span>&#123;</span><br><span class="line">    String vul = Obj.childMethod(arg);</span><br><span class="line">    <span class="keyword">return</span> vul;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">childMethod</span><span class="params">(String carg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> carg.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现先判断子方法后判断父方法，这里就需要进行逆拓扑排序，逆拓扑排序使用栈实现，变量 <code>dfsStack</code> 和 <code>visitedNodes</code> 用于避免形成环，同时 <code>visitedNodes</code> 还可以避免重复排序，具体的排序操作由 <code>dfsTsort</code> 实现，所有方法调用整合为一个集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对方法的调用关系进行逆拓扑排序（按名称逆序）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123;</span><br><span class="line">    <span class="comment">// 拷贝方法调用的方法集合</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123;</span><br><span class="line">        MethodReference.Handle method = entry.getKey(); <span class="comment">// 方法</span></span><br><span class="line">        outgoingReferences.put(method, <span class="keyword">new</span> HashSet&lt;&gt;(entry.getValue()));    <span class="comment">// 调用的方法集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Topological sort methods</span></span><br><span class="line">    LOGGER.debug(<span class="string">&quot;Performing topological sort...&quot;</span>);</span><br><span class="line">    Set&lt;MethodReference.Handle&gt; dfsStack = <span class="keyword">new</span> HashSet&lt;&gt;();     <span class="comment">// 避免形成环</span></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; visitedNodes = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 在调用链出现重合时，避免重复排序</span></span><br><span class="line">    List&lt;MethodReference.Handle&gt; sortedMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(outgoingReferences.size());    <span class="comment">// 方法调用集合</span></span><br><span class="line">    <span class="keyword">for</span> (MethodReference.Handle root : outgoingReferences.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 遍历集合中的起始方法，进行递归搜索（DFS），经过逆拓扑排序，调用链的最末端排在最前面，</span></span><br><span class="line">        <span class="comment">// 后续进行参数、返回值、调用链之间的污点传递分析</span></span><br><span class="line">        dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.debug(String.format(<span class="string">&quot;Outgoing references %d, sortedMethods %d&quot;</span>, outgoingReferences.size(), sortedMethods.size()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆拓扑排序后的方法调用集合</span></span><br><span class="line">    <span class="keyword">return</span> sortedMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆拓扑排序的具体实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outgoingReferences 方法调用的方法集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortedMethods      逆拓扑排序后的方法集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> visitedNodes       已排序的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stack              栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node               待排序的起始方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfsTsort</span><span class="params">(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences,</span></span></span><br><span class="line"><span class="function"><span class="params">                             List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止在遍历一条调用链中进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (stack.contains(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止对某个方法及被调方法重复排序</span></span><br><span class="line">    <span class="keyword">if</span> (visitedNodes.contains(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据起始方法，取出被调用的方法集合</span></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node);</span><br><span class="line">    <span class="keyword">if</span> (outgoingRefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.add(node);    <span class="comment">// 入栈，避免递归死循环</span></span><br><span class="line">    <span class="keyword">for</span> (MethodReference.Handle child : outgoingRefs) &#123; <span class="comment">// 对被调用方法递归进行排序</span></span><br><span class="line">        dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.remove(node); <span class="comment">// 出栈，方法排序完毕</span></span><br><span class="line">    visitedNodes.add(node);     <span class="comment">// 记录已访问的方法，在递归遇到重复方法时可以跳过</span></span><br><span class="line">    sortedMethods.add(node);    <span class="comment">// 记录已排序的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后使用 <code>calculatePassthroughDataflow</code> 方法判断每个方法的返回值与参数关系，首先跳过静态代码块，然后利用 asm 的访问者对逆拓扑排序得到的方法集合进行遍历和分析判断。</p>
<ul>
<li>静态代码块在类加载时调用，只执行一次，且优先于主函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析方法调用集合，获取数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceByName 类资源集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classMap            类信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritanceMap      继承信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortedMethods       所有方法集合（经过逆拓扑排序）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serializableDecider 序列化决策者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; calculatePassthroughDataflow(Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName,</span><br><span class="line">                                                                                      Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                                                                                      InheritanceMap inheritanceMap,</span><br><span class="line">                                                                                      List&lt;MethodReference.Handle&gt; sortedMethods,</span><br><span class="line">                                                                                      SerializableDecider serializableDecider) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 数据流信息：方法、传递污染的参数索引</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (MethodReference.Handle method : sortedMethods) &#123;</span><br><span class="line">        <span class="comment">// 跳过 static 静态初始化代码（静态代码块）</span></span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;&lt;clinit&gt;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法所属类的类资源</span></span><br><span class="line">        ClassResourceEnumerator.ClassResource classResource = classResourceByName.get(method.getClassReference().getName());</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = classResource.getInputStream()) &#123;    <span class="comment">// 读取类文件</span></span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream);  <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * classMap             类信息</span></span><br><span class="line"><span class="comment">                 * inheritanceMap       继承信息</span></span><br><span class="line"><span class="comment">                 * passthroughDataflow  数据流信息，初始为空</span></span><br><span class="line"><span class="comment">                 * serializableDecider  序列化决策者</span></span><br><span class="line"><span class="comment">                 * Opcodes.ASM6         ASM API 版本</span></span><br><span class="line"><span class="comment">                 * method               待观察的方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 继承 asm 的 ClassVisitor(MethodVisitor) 实现对类文件的观察，记录类信息和方法信息</span></span><br><span class="line">                PassthroughDataflowClassVisitor cv = <span class="keyword">new</span> PassthroughDataflowClassVisitor(classMap, inheritanceMap,</span><br><span class="line">                        passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitMethod</span></span><br><span class="line">                cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存方法的哪些参数会影响返回值</span></span><br><span class="line">                passthroughDataflow.put(method, cv.getReturnTaint());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Exception analyzing &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Unable to analyze &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passthroughDataflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PassthroughDataflowClassVisitor</code> 继承了 asm 中的 ClassVisitor，重写 <code>visit</code> 记录方法所属类的名称，重写 <code>visitMethod</code> 对待观察的方法用 <code>PassthroughDataflowMethodVisitor</code> 判断返回值与参数的关系，方法 <code>getReturnTaint</code> 返回能够传递污染的参数索引集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PassthroughDataflowClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap;    <span class="comment">// 类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle methodToVisit;     <span class="comment">// 待观察的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;            <span class="comment">// 继承信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;    <span class="comment">// 数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;  <span class="comment">// 序列化决策者</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> PassthroughDataflowMethodVisitor passthroughDataflowMethodVisitor;  <span class="comment">// 方法访问者</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PassthroughDataflowClassVisitor</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           SerializableDecider serializableDecider, <span class="keyword">int</span> api, MethodReference.Handle methodToVisit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api); <span class="comment">// ASM API 版本</span></span><br><span class="line">        <span class="keyword">this</span>.classMap = classMap;</span><br><span class="line">        <span class="keyword">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        <span class="keyword">this</span>.methodToVisit = methodToVisit;</span><br><span class="line">        <span class="keyword">this</span>.passthroughDataflow = passthroughDataflow;</span><br><span class="line">        <span class="keyword">this</span>.serializableDecider = serializableDecider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="keyword">this</span>.name = name;   <span class="comment">// 记录类名</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不是待观察方法的所属类</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.name.equals(methodToVisit.getClassReference().getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Expecting to visit &quot;</span> + methodToVisit.getClassReference().getName() + <span class="string">&quot; but instead got &quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不是待观察方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(methodToVisit.getName()) || !desc.equals(methodToVisit.getDesc())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflowMethodVisitor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Constructing passthroughDataflowMethodVisitor twice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类方法，返回新的方法观察者</span></span><br><span class="line">        <span class="comment">// 如果类观察者的 cv 变量为空，则返回 null，否则返回 cv.visitMethod</span></span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法访问者，判断方法返回值与参数的关系</span></span><br><span class="line">        <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visitCode -&gt; visitInsn -&gt; visitFieldInsn -&gt; visitMethodInsn</span></span><br><span class="line">        passthroughDataflowMethodVisitor = <span class="keyword">new</span> PassthroughDataflowMethodVisitor(</span><br><span class="line">                classMap, inheritanceMap, <span class="keyword">this</span>.passthroughDataflow, serializableDecider,</span><br><span class="line">                api, mv, <span class="keyword">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化代码分析，删除 JSR 指令并内联引用的子例程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(passthroughDataflowMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回能够传递污染的参数索引集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">getReturnTaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflowMethodVisitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Never constructed the passthroughDataflowmethodVisitor!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> passthroughDataflowMethodVisitor.returnTaint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PassthroughDataflowMethodVisitor</code> 继承 <code>TaintTrackingMethodVisitor</code> 实现，重写了其中的 4 个访问者方法：</p>
<ul>
<li>visitCode：启动对方法代码的访问，把参数全部存到本地变量表</li>
<li>visitInsn：访问零操作数的指令，这里只分析返回指令</li>
<li>visitFieldInsn：访问字段指令，字段指令是加载或存储对象字段值的指令</li>
<li>visitMethodInsn：访问方法指令，方法指令是调用方法的指令</li>
</ul>
<p>但是 TaintTrackingMethodVisitor 继承 asm 的 MethodVisitor 并重写了大量的方法，模拟 JVM 在处理方法调用中的本地变量表和操作数栈，因此实际调用的访问者方法来自 PassthroughDataflowMethodVisitor、TaintTrackingMethodVisitor、MethodVisitor 三个类。模拟是根据对字节码指令和 JVM 的了解手动进行实现（救命），先解析这里的 4 个重写方法。</p>
<p>数据流信息 <code>passthroughDataflow</code> 初始为空，集合变量 <code>returnTaint</code> 用于记录传递污染的参数索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PassthroughDataflowMethodVisitor</span> <span class="keyword">extends</span> <span class="title">TaintTrackingMethodVisitor</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, ClassReference&gt; classMap;              <span class="comment">// 类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;                                    <span class="comment">// 继承信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;    <span class="comment">// 数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;                          <span class="comment">// 序列化决策者</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> access;               <span class="comment">// 访问标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;              <span class="comment">// 描述符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; returnTaint; <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PassthroughDataflowMethodVisitor</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            InheritanceMap inheritanceMap, Map&lt;MethodReference.Handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            Set&lt;Integer&gt;&gt; passthroughDataflow, SerializableDecider serializableDeciderMap, <span class="keyword">int</span> api, MethodVisitor mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String owner, <span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inheritanceMap, passthroughDataflow, api, mv, owner, access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="keyword">this</span>.classMap = classMap;</span><br><span class="line">        <span class="keyword">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        <span class="keyword">this</span>.passthroughDataflow = passthroughDataflow;</span><br><span class="line">        <span class="keyword">this</span>.serializableDecider = serializableDeciderMap;</span><br><span class="line">        <span class="keyword">this</span>.access = access;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">        returnTaint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitCode</code> 方法将被访问的方法参数记录到本地变量表中，如果是非静态方法，则添加隐式参数 this。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;   <span class="comment">// 启动对方法代码的访问</span></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitCode 初始化本地变量表</span></span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录参数到本地变量表 savedVariableState.localVars</span></span><br><span class="line">    <span class="keyword">int</span> localIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 非静态方法，第一个参数（隐式）为对象实例 this</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        setLocalTaint(localIndex, argIndex);</span><br><span class="line">        localIndex += <span class="number">1</span>;</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历参数，根据描述符得出参数类型（占用空间大小）</span></span><br><span class="line">    <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        setLocalTaint(localIndex, argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitInsn</code> 方法将存储在栈顶的返回值（传递污染的参数索引集合，可能为空）中的元素添加到 <code>returnTaint</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123; <span class="comment">// 访问零操作数指令</span></span><br><span class="line">    <span class="comment">// 方法执行完毕后将从栈返回结果给调用者，因此栈顶即返回值</span></span><br><span class="line">    <span class="comment">// 存储可能被污染的返回值到 returnTaint</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.IRETURN:   <span class="comment">// 从当前方法返回 int</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.FRETURN:   <span class="comment">// 从当前方法返回 float</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.ARETURN:   <span class="comment">// 从当前方法返回对象引用</span></span><br><span class="line">            <span class="comment">// 调用 TaintTrackingMethodVisitor.getStackTaint 读取栈顶，大小为 1（32位）</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">0</span>));   <span class="comment">// 栈空间从内存高位到低位分配空间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.LRETURN:   <span class="comment">// 从当前方法返回 long</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.DRETURN:   <span class="comment">// 从当前方法返回 double</span></span><br><span class="line">            <span class="comment">// 调用 TaintTrackingMethodVisitor.getStackTaint 读取栈顶，大小为 2（64位）</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.RETURN:    <span class="comment">// 从当前方法返回 void</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitInsn 进行出/入栈操作</span></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitFieldInsn</code> 方法在读取或存储对象字段的值时调用，这里判断字段是否可序列化，如果可序列化则认为方法所属类的实例对象本身或被调用方法所属类的实例对象是受污染的，将其传递污染的参数索引集合存储到 <code>taint</code> 变量中。<br>因为可能读取的是方法所属类的实例对象字段，也可能是其他对象，其他对象得通过方法调用读取字段，涉及到方法调用方法，具体见 <code>visitMethodInsn</code> 方法中的分析。最后将栈顶（读取字段的返回值）设置为 <code>taint</code>，这里可能是空的 HashSet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFieldInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc)</span> </span>&#123;    <span class="comment">// 访问字段指令，字段指令是加载或存储对象字段值的指令。</span></span><br><span class="line">    <span class="comment">// 方法执行过程中可能访问对象字段，访问前会进行入栈操作</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETSTATIC: <span class="comment">// 获取类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTSTATIC: <span class="comment">// 设置类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETFIELD:  <span class="comment">// 获取对象字段</span></span><br><span class="line">            Type type = Type.getType(desc); <span class="comment">// 字段类型</span></span><br><span class="line">            <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                Boolean isTransient = <span class="keyword">null</span>; <span class="comment">// 如果字段被 transient 关键字修饰，则不可序列化</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断读取的字段所属类是否可序列化，即字段是否可以序列化</span></span><br><span class="line">                <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> ClassReference.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                    isTransient = Boolean.TRUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若读取的字段所属类可序列化</span></span><br><span class="line">                    ClassReference clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(owner));</span><br><span class="line">                    <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历类的所有字段</span></span><br><span class="line">                        <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                            <span class="comment">// 是否为目标字段</span></span><br><span class="line">                            <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                <span class="comment">// 是否被 transient 关键字修饰</span></span><br><span class="line">                                isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isTransient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若找不到目标字段，则向上查找（超类）</span></span><br><span class="line">                        clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(clazz.getSuperClass()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">                Set&lt;Integer&gt; taint;</span><br><span class="line">                <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                    <span class="comment">// 若字段没有被 transient 修饰，则调用 TaintTrackingMethodVisitor.getStackTaint 读取栈顶</span></span><br><span class="line">                    <span class="comment">// 取出的是 this 或某实例对象，即字段所属实例</span></span><br><span class="line">                    taint = getStackTaint(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则为空</span></span><br><span class="line">                    taint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">                <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.setStackTaint 将栈顶设置为 taint</span></span><br><span class="line">                setStackTaint(<span class="number">0</span>, taint);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTFIELD:  <span class="comment">// 设置对象字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">    <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br></pre></td></tr></table></figure>

<p><code>visitMethodInsn</code> 方法在方法调用方法时调用（绕口令呢😅）</p>
<ul>
<li>首先记录被调用方法的参数类型（列表），根据是否为静态方法添加第一个隐式参数（被调用方法所属类的实例对象）</li>
<li>然后记录被调用方法的返回值类型长度（0~2），用于最后存储索引集合</li>
<li>模拟被调用方法的操作数栈，如果是构造方法则认为隐式参数能够传递污染，如果被调用方法在已经分析的数据流信息中则直接取出相应的参数索引集合，保存到 <code>resultTaint</code> 变量中</li>
<li>调用父类方法 <code>TaintTrackingMethodVisitor.visitMethodInsn</code> 执行真正的出/入栈模拟，然后将参数索引集合存储到栈顶</li>
<li>最后根据被调用方法的返回值类型长度将 <code>resultTaint</code> 也合并到栈顶</li>
</ul>
<p>调用方法时会创建新的栈帧存储用到的相关数据，因此当调用到 <code>visitMethodInsn</code> 时会创建新的栈帧，其操作数栈中是被调用方法的参数（而不是当前方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;  <span class="comment">// 访问方法指令，方法指令是调用方法的指令。</span></span><br><span class="line">    <span class="comment">// 根据描述符得出被调用方法的参数类型（占用空间大小）</span></span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法的第一个参数是对象本身，即 this</span></span><br><span class="line">    <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">        Type[] extendedArgTypes = <span class="keyword">new</span> Type[argTypes.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">        extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);    <span class="comment">// 对象类型</span></span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据描述符获取被调用方法的返回值类型大小</span></span><br><span class="line">    <span class="keyword">int</span> retSize = Type.getReturnType(desc).getSize();</span><br><span class="line">    <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">    Set&lt;Integer&gt; resultTaint;</span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESTATIC:      <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:     <span class="comment">// 调用实例方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESPECIAL:     <span class="comment">// 调用超类构造方法，实例初始化方法，私有方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:   <span class="comment">// 调用接口方法</span></span><br><span class="line">            <span class="comment">// 模拟操作数栈</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;Set&lt;Integer&gt;&gt; argTaint = <span class="keyword">new</span> ArrayList&lt;Set&lt;Integer&gt;&gt;(argTypes.length);</span><br><span class="line">            <span class="comment">// 调用方法前先把操作数入栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                argTaint.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录数据起始位置</span></span><br><span class="line">            <span class="keyword">int</span> stackIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                Type argType = argTypes[i];</span><br><span class="line">                <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 根据参数类型的大小，调用 TaintTrackingMethodVisitor.getStackTaint 读取栈中的值</span></span><br><span class="line">                    <span class="comment">// 参数从右往左入栈，这里将参数值拷贝到 argTaint</span></span><br><span class="line">                    argTaint.set(argTypes.length - <span class="number">1</span> - i, getStackTaint(stackIndex + argType.getSize() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                stackIndex += argType.getSize();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果被调用的是构造方法，则认为被调用方法所属类的实例对象本身可以传递污染</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">                <span class="comment">// parameters</span></span><br><span class="line">                resultTaint = argTaint.get(<span class="number">0</span>);  <span class="comment">// 从栈顶取出对象，实际上是该对象的参数索引集合</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultTaint = <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">// 否则初始化为空</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 经过逆拓扑排序，调用链末端的方法先被访问和判断，即被调用方法已经被判断过</span></span><br><span class="line">            <span class="comment">// 例如 A-&gt;B，判断 A 时 B 已经有判断结果了，并且此时栈中的数据是这样：B对象 B参数</span></span><br><span class="line">            Set&lt;Integer&gt; passthrough = passthroughDataflow.get(<span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc));</span><br><span class="line">            <span class="comment">// 如果被调用方法存在能够传递污染的参数</span></span><br><span class="line">            <span class="keyword">if</span> (passthrough != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历参数索引</span></span><br><span class="line">                <span class="keyword">for</span> (Integer passthroughDataflowArg : passthrough) &#123;</span><br><span class="line">                    <span class="comment">// 从栈中获取能够传递污染的参数索引集合，全部添加到 resultTaint</span></span><br><span class="line">                    resultTaint.addAll(argTaint.get(passthroughDataflowArg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitMethodInsn 执行出/入栈操作，根据预定义的判断规则分析参数索引集合</span></span><br><span class="line">    <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值不为空</span></span><br><span class="line">    <span class="comment">// 实例对象本身有可能传递污染，因此不能直接根据返回值判断（即不能最先执行这一块）</span></span><br><span class="line">    <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;  <span class="comment">// 1 或者 2</span></span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.getStackTaint 将 resultTaint 中的元素合并到参数索引集合中</span></span><br><span class="line">        <span class="comment">// 这里减 1 是因为在 TaintTrackingMethodVisitor.visitMethodInsn 中已经将第一个单位的值设置为其分析得到的参数索引集合</span></span><br><span class="line">        getStackTaint(retSize - <span class="number">1</span>).addAll(resultTaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>save</code> 方法和 <code>load</code> 方法使用工厂方法实现数据的存取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法存储存储数据流信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (passthroughDataflow == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Save called before discover()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>), <span class="keyword">new</span> PassThroughFactory(), passthroughDataflow.entrySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 passthrough.dat 加载数据流信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; load() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; entry : DataLoader.loadData(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>), <span class="keyword">new</span> PassThroughFactory())) &#123;</span><br><span class="line">        passthroughDataflow.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passthroughDataflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据工厂接口实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PassThroughFactory</span> <span class="keyword">implements</span> <span class="title">DataFactory</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">MethodReference</span>.<span class="title">Handle</span>, <span class="title">Set</span>&lt;<span class="title">Integer</span>&gt;&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; parse(String[] fields) &#123;</span><br><span class="line">        ClassReference.Handle clazz = <span class="keyword">new</span> ClassReference.Handle(fields[<span class="number">0</span>]);</span><br><span class="line">        MethodReference.Handle method = <span class="keyword">new</span> MethodReference.Handle(clazz, fields[<span class="number">1</span>], fields[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; passthroughArgs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String arg : fields[<span class="number">3</span>].split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                passthroughArgs.add(Integer.parseInt(arg));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(method, passthroughArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] serialize(Map.Entry&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String[] fields = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">        fields[<span class="number">0</span>] = entry.getKey().getClassReference().getName();   <span class="comment">// 方法所属类的类名</span></span><br><span class="line">        fields[<span class="number">1</span>] = entry.getKey().getName();   <span class="comment">// 方法的名称</span></span><br><span class="line">        fields[<span class="number">2</span>] = entry.getKey().getDesc();   <span class="comment">// 方法的描述符</span></span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Integer arg : entry.getValue()) &#123;</span><br><span class="line">            sb.append(Integer.toString(arg));</span><br><span class="line">            sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fields[<span class="number">3</span>] = sb.toString();  <span class="comment">// 参数索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fields;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-TaintTrackingMethodVisitor"><a href="#6-TaintTrackingMethodVisitor" class="headerlink" title="6. TaintTrackingMethodVisitor"></a>6. TaintTrackingMethodVisitor</h2><p>继承 asm 的 MethodVisitor，模拟 JVM 内存结构，即本地变量表 <code>localVars</code> 和操作数栈 <code>stackVars</code>；重写了大量方法模拟调用参数时的出/入栈操作，用于进行污点分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedVariableState</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    List&lt;Set&lt;T&gt;&gt; localVars; <span class="comment">// 本地变量表</span></span><br><span class="line">    List&lt;Set&lt;T&gt;&gt; stackVars; <span class="comment">// 操作数栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedVariableState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localVars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stackVars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedVariableState</span><span class="params">(SavedVariableState&lt;T&gt; copy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.localVars = <span class="keyword">new</span> ArrayList&lt;&gt;(copy.localVars.size());</span><br><span class="line">        <span class="keyword">this</span>.stackVars = <span class="keyword">new</span> ArrayList&lt;&gt;(copy.stackVars.size());</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; original : copy.localVars) &#123;</span><br><span class="line">            <span class="keyword">this</span>.localVars.add(<span class="keyword">new</span> HashSet&lt;&gt;(original));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Set&lt;T&gt; original : copy.stackVars) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackVars.add(<span class="keyword">new</span> HashSet&lt;&gt;(original));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(SavedVariableState&lt;T&gt; copy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copy.localVars.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="keyword">this</span>.localVars.size()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.localVars.add(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.localVars.get(i).addAll(copy.localVars.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copy.stackVars.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="keyword">this</span>.stackVars.size()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stackVars.add(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.stackVars.get(i).addAll(copy.stackVars.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预定义了一些数据流信息：类名，方法名，方法描述符，传递污染的参数索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[][] PASSTHROUGH_DATAFLOW = <span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Taint from ObjectInputStream. Note that defaultReadObject() is handled differently below</span></span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream&quot;</span>, <span class="string">&quot;readObject&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream&quot;</span>, <span class="string">&quot;readFields&quot;</span>, <span class="string">&quot;()Ljava/io/ObjectInputStream$GetField;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream$GetField&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass taint from class name to returned class</span></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Object&quot;</span>, <span class="string">&quot;getClass&quot;</span>, <span class="string">&quot;()Ljava/lang/Class;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;forName&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass taint from class or method name to returned method</span></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getMethod&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        <span class="comment">// Pass taint from class to methods</span></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getMethods&quot;</span>, <span class="string">&quot;()[Ljava/lang/reflect/Method;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;)V&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/StringBuffer;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;append&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;II)Ljava/lang/StringBuilder;&quot;</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/lang/StringBuilder&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/io/ByteArrayInputStream&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;([B)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ByteArrayInputStream&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;([BII)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/ObjectInputStream&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/io/InputStream;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;I)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/io/File;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;java/io/File&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/nio/paths/Paths&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">        &#123;<span class="string">&quot;java/net/URL&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>问题：这里实现的 <code>visitMethodInsn</code> 比 PassthroughDataflowMethodVisitor.visitMethodInsn 多三个判断规则，后面 CallGraphDiscovery 中的 ModelGeneratorMethodVisitor 也重写了该方法并在最后调用该父类方法，为什么不直接剥离出来？</p>
<ul>
<li>PassthroughDataflowMethodVisitor 中存储的是参数索引，而 ModelGeneratorMethodVisitor 中存储的是 <code>arg参数索引.字段名称</code></li>
<li>出入栈操作都在 TaintTrackingMethodVisitor 中实现</li>
<li>经过该方法的模拟，栈顶元素即该方法能够传递污染的参数索引集合</li>
</ul>
<p>举个例子看一看字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cmd = <span class="keyword">new</span> A().method1(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;100&quot;</span>;</span><br><span class="line">        Integer n = Integer.parseInt(s);</span><br><span class="line"></span><br><span class="line">        n = number;</span><br><span class="line">        String value = n.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method1</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getValue</code> 部分的字节码，用空行分隔了上面四条语句的字节码，出现的字节码指令包括：<br>ldc 从常量池加载数据到操作数栈，astore 从栈顶弹出并存储到本地变量表，aload 从本地变量表加载数据到操作数栈，invokestatic 调用类方法（静态），invokevirtual 调用实例方法，return 从当前方法返回 void。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">(java.lang.Integer)</span></span>;</span><br><span class="line">  descriptor: (Ljava/lang/Integer;)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">       0: ldc           #5                  // String 100 入栈</span><br><span class="line">       <span class="number">2</span>: astore_2                          <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">       <span class="number">3</span>: aload_2                           <span class="comment">// 入栈，invokestatic 的参数，执行完毕后结果入栈</span></span><br><span class="line">       4: invokestatic  #6                  // Method java/lang/Integer.parseInt:(Ljava/lang/String;)I</span><br><span class="line">       7: invokestatic  #7                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">      <span class="number">10</span>: astore_3                          <span class="comment">// 出栈，存储执行结果</span></span><br><span class="line"></span><br><span class="line">      <span class="number">11</span>: aload_1                           <span class="comment">// 入栈，参数 number</span></span><br><span class="line">      <span class="number">12</span>: astore_3                          <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line">      <span class="number">13</span>: aload_3                           <span class="comment">// 入栈，invokevirtual 的参数</span></span><br><span class="line">      14: invokevirtual #8                  // Method java/lang/Integer.toString:()Ljava/lang/String; 执行完毕后结果入栈</span><br><span class="line">      <span class="number">17</span>: astore        <span class="number">4</span>                   <span class="comment">// 出栈</span></span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span>                            <span class="comment">// 返回 void</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">3</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">11</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">13</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">19</span></span><br></pre></td></tr></table></figure>

<p>在调用方法前，进行参数的入栈，即创建一个新的栈帧，执行完毕后继续执行下一条指令。实际上这部分的模拟不是很懂，要说汇编语言倒还会看，但是 Java 字节码也还没到那么底层，我的理解是调用函数就会创建一个栈帧，执行完毕后从系统栈弹出栈帧，那么返回结果存入上一个栈帧的操作数栈栈顶？回头等我搞明白了再补两张图…</p>
<h2 id="7-CallGraphDiscovery"><a href="#7-CallGraphDiscovery" class="headerlink" title="7. CallGraphDiscovery"></a>7. CallGraphDiscovery</h2><p><code>discover</code> 方法利用之前得到的类信息、方法信息、继承/重写信息、数据流信息，结合 asm 访问者分析被调方法的参数是否会被调用者方法的参数所影响。</p>
<p>以下面 getValue 方法为例，调用了 parseInt 和 toString 两个方法，但是参数 number 只会影响到 toString。因此如果污点（攻击者的输入数据）走到 getValue 方法且参数 number 是可控的（即上一步分析能够传递污染），那么进一步只需要检查 toString 方法，而 parseInt 方法就不用再检查了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">&quot;100&quot;</span>;</span><br><span class="line">    Integer n = Integer.parseInt(s);</span><br><span class="line">    </span><br><span class="line">    n = number;</span><br><span class="line">    String value = n.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>discover</code> 方法的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CallGraphDiscovery.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用关系信息：方法所属类名，方法名，方法描述符，被调方法所属类名，被调方法名，被调方法描述符，方法参数索引，方法参数对象的字段名称，被调方法参数索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GraphCall&gt; discoveredCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析调用关系，即被调方法的参数是否会被（调用者）方法的参数所影响</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classResourceEnumerator 类枚举器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config                  配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, GIConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加载方法信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">    <span class="comment">// 加载类信息</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">    <span class="comment">// 加载继承信息（inheritanceMap：子类-&gt;父类集合，subClassMap：父类-&gt;子类集合）</span></span><br><span class="line">    InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">    <span class="comment">// 加载数据流信息：方法-&gt;传递污染的参数索引</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化决策者</span></span><br><span class="line">    SerializableDecider serializableDecider = config.getSerializableDecider(methodMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123; <span class="comment">// 读取类文件</span></span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(in);   <span class="comment">// 创建 ClassReader，后续调用 accept 方法解析类文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断被调方法的参数是否会被调用者方法的参数所影响</span></span><br><span class="line">                <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）：visit -&gt; visitMethod -&gt; visitOuterClass -&gt; visitInnerClass -&gt; visitEnd</span></span><br><span class="line">                cr.accept(<span class="keyword">new</span> ModelGeneratorClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6),</span><br><span class="line">                        ClassReader.EXPAND_FRAMES);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ModelGeneratorClassVisitor</code> 类继承了 asm 中的 ClassVisitor，重写了五个访问者方法，主要关注 <code>visitMethod</code> 中调用 <code>ModelGeneratorMethodVisitor</code> 对方法进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelGeneratorClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ClassReference.Handle, ClassReference&gt; classMap;              <span class="comment">// 类信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InheritanceMap inheritanceMap;                                    <span class="comment">// 继承信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow;    <span class="comment">// 数据流信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SerializableDecider serializableDecider;                          <span class="comment">// 序列化决策者</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ModelGeneratorClassVisitor</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InheritanceMap inheritanceMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      SerializableDecider serializableDecider, <span class="keyword">int</span> api)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(api); <span class="comment">// ASM API 版本</span></span><br><span class="line">        <span class="keyword">this</span>.classMap = classMap;</span><br><span class="line">        <span class="keyword">this</span>.inheritanceMap = inheritanceMap;</span><br><span class="line">        <span class="keyword">this</span>.passthroughDataflow = passthroughDataflow;</span><br><span class="line">        <span class="keyword">this</span>.serializableDecider = serializableDecider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;            <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> String signature;       <span class="comment">// 签名</span></span><br><span class="line">    <span class="keyword">private</span> String superName;       <span class="comment">// 父类名</span></span><br><span class="line">    <span class="keyword">private</span> String[] interfaces;    <span class="comment">// 接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        <span class="comment">// 记录类的相关信息</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.signature = signature;</span><br><span class="line">        <span class="keyword">this</span>.superName = superName;</span><br><span class="line">        <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类方法，返回新的方法观察者</span></span><br><span class="line">        <span class="comment">// 如果类观察者的 cv 变量为空，则返回 null，否则返回 cv.visitMethod</span></span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法访问者，判断方法参数与被调用方法参数的传递关系</span></span><br><span class="line">        <span class="comment">// 重写方法的调用顺序（没有重写的调用默认方法）:visitCode -&gt; visitFieldInsn -&gt; visitMethodInsn</span></span><br><span class="line">        ModelGeneratorMethodVisitor modelGeneratorMethodVisitor = <span class="keyword">new</span> ModelGeneratorMethodVisitor(classMap,</span><br><span class="line">                inheritanceMap, passthroughDataflow, serializableDecider, api, mv, <span class="keyword">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="comment">// 简化代码分析，删除 JSR 指令并内联引用的子例程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span> </span>&#123;   <span class="comment">// 访问类的外围类（如果有）</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Write some tests to make sure we can ignore this</span></span><br><span class="line">        <span class="keyword">super</span>.visitOuterClass(owner, name, desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, String innerName, <span class="keyword">int</span> access)</span> </span>&#123;  <span class="comment">// 访问内部类，该内部类不一定是被访问的类的成员</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Write some tests to make sure we can ignore this</span></span><br><span class="line">        <span class="keyword">super</span>.visitInnerClass(name, outerName, innerName, access);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ModelGeneratorMethodVisitor</code> 也继承了 <code>TaintTrackingMethodVisitor</code> 实现，不过只重写了其中的 3 个访问者方法</p>
<ul>
<li>visitCode：启动对方法代码的访问，把参数全部存到本地变量表</li>
<li>visitFieldInsn：访问字段指令，字段指令是加载或存储对象字段值的指令</li>
<li>visitMethodInsn：访问方法指令，方法指令是调用方法的指令</li>
</ul>
<p><code>visitCode</code> 和 PassthroughDataflowMethodVisitor（直接存储参数索引）中的实现类似，不同的是这里将 <code>arg</code> 与参数索引进行拼接，存储字符串到本地变量表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;   <span class="comment">// 启动对方法代码的访问</span></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitCode 初始化本地变量表</span></span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录参数到本地变量表 savedVariableState.localVars</span></span><br><span class="line">    <span class="keyword">int</span> localIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法，第一个参数（隐式）为对象实例 this</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        <span class="comment">// 使用 arg 前缀来表示方法入参，后续用于判断是否为目标调用方法的入参</span></span><br><span class="line">        setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">        localIndex += <span class="number">1</span>;</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历参数，根据描述符得出参数类型（占用空间大小）</span></span><br><span class="line">    <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">        <span class="comment">// 调用 TaintTrackingMethodVisitor.setLocalTaint 添加到本地变量表</span></span><br><span class="line">        setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">        localIndex += argType.getSize();</span><br><span class="line">        argIndex += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitFieldInsn</code> 也和 PassthroughDataflowMethodVisitor（直接存储参数索引）中的实现类似，不同的是这里将字段名称与 <code>arg参数索引</code> 字符串进行拼接，然后存储到栈顶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFieldInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc)</span> </span>&#123;    <span class="comment">// 访问字段指令，字段指令是加载或存储对象字段值的指令。</span></span><br><span class="line">    <span class="comment">// 方法执行过程中可能访问对象字段，访问前会进行入栈操作</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETSTATIC: <span class="comment">// 获取类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTSTATIC: <span class="comment">// 设置类的静态字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETFIELD:  <span class="comment">// 获取对象字段</span></span><br><span class="line">            Type type = Type.getType(desc); <span class="comment">// 字段类型</span></span><br><span class="line">            <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                Boolean isTransient = <span class="keyword">null</span>; <span class="comment">// 如果字段被 transient 关键字修饰，则不可序列化</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断读取的字段所属类是否可序列化，即字段是否可以序列化</span></span><br><span class="line">                <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> ClassReference.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                    isTransient = Boolean.TRUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 若读取的字段所属类可序列化</span></span><br><span class="line">                    ClassReference clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(owner));</span><br><span class="line">                    <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历类的所有字段</span></span><br><span class="line">                        <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                            <span class="comment">// 是否为目标字段</span></span><br><span class="line">                            <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                <span class="comment">// 是否被 transient 关键字修饰</span></span><br><span class="line">                                isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isTransient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 若找不到目标字段，则向上查找（超类）</span></span><br><span class="line">                        clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(clazz.getSuperClass()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 能够传递污染的参数索引集合</span></span><br><span class="line">                Set&lt;String&gt; newTaint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s : getStackTaint(<span class="number">0</span>)) &#123;</span><br><span class="line">                        newTaint.add(s + <span class="string">&quot;.&quot;</span> + name);   <span class="comment">// 拼接名称</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">                <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用 TaintTrackingMethodVisitor.setStackTaint 将栈顶设置为 newTaint</span></span><br><span class="line">                setStackTaint(<span class="number">0</span>, newTaint);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTFIELD:  <span class="comment">// 设置对象字段</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitFieldInsn 进行出/入栈操作</span></span><br><span class="line">    <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>visitMethodInsn</code> 方法分析被调方法的操作数栈，栈中的元素要么为空集合，要么为能够传递污染的参数集合，模拟操作数栈的元素个数，但元素值是集合（模拟值，不是真实/实际值）。<br>最开始的时候已经将当前方法的参数以 <code>arg参数索引</code> 的形式存储到了本地变量表，当调用其他方法时，会从本地变量表加载数据到栈中，如果用到对象字段，则以 <code>arg参数索引.字段名称</code> 的形式入栈，因此根据栈中元素的名称就可以得知方法的哪些参数（根据名称判断）影响了被调方法的哪些参数（已知参数个数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;  <span class="comment">// 访问方法指令，方法指令是调用方法的指令。</span></span><br><span class="line">    <span class="comment">// 获取被调用方法的参数和类型，非静态方法需要把实例类型放在第一个元素</span></span><br><span class="line">    <span class="comment">// 根据描述符得出被调用方法的参数类型（占用空间大小）</span></span><br><span class="line">    Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态方法的第一个参数是对象本身，即 this</span></span><br><span class="line">    <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;   <span class="comment">// 非静态方法的第一个参数是实例</span></span><br><span class="line">        Type[] extendedArgTypes = <span class="keyword">new</span> Type[argTypes.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">        extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);    <span class="comment">// 对象类型</span></span><br><span class="line">        argTypes = extendedArgTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESTATIC:      <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:     <span class="comment">// 调用实例方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKESPECIAL:     <span class="comment">// 调用超类构造方法，实例初始化方法，私有方法</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:   <span class="comment">// 调用接口方法</span></span><br><span class="line">            <span class="keyword">int</span> stackIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 被调用方法的操作数栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 最右边的参数，就是最后入栈，即在栈顶</span></span><br><span class="line">                <span class="keyword">int</span> argIndex = argTypes.length - <span class="number">1</span> - i; <span class="comment">// 参数索引</span></span><br><span class="line">                Type type = argTypes[argIndex]; <span class="comment">// 参数类型</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 参数从右往左入栈，因此最右边的参数在栈底</span></span><br><span class="line">                Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                <span class="keyword">if</span> (taint.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果存在能够传递污染的参数</span></span><br><span class="line">                    <span class="comment">// 遍历参数</span></span><br><span class="line">                    <span class="keyword">for</span> (String argSrc : taint) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!argSrc.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">&quot;arg&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid taint arg: &quot;</span> + argSrc);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// arg数字.字段名称</span></span><br><span class="line">                        <span class="keyword">int</span> dotIndex = argSrc.indexOf(<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 分隔位置</span></span><br><span class="line">                        <span class="keyword">int</span> srcArgIndex;    <span class="comment">// 第几个参数</span></span><br><span class="line">                        String srcArgPath;</span><br><span class="line">                        <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>));</span><br><span class="line">                            srcArgPath = <span class="keyword">null</span>;  <span class="comment">// 没有名称</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>, dotIndex));</span><br><span class="line">                            srcArgPath = argSrc.substring(dotIndex + <span class="number">1</span>);  <span class="comment">// 字段名称</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 记录参数流动关系</span></span><br><span class="line">                        <span class="comment">// argIndex：当前方法参数索引；srcArgIndex：对应上一级方法的参数索引</span></span><br><span class="line">                        discoveredCalls.add(<span class="keyword">new</span> GraphCall(</span><br><span class="line">                                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(<span class="keyword">this</span>.owner), <span class="keyword">this</span>.name, <span class="keyword">this</span>.desc),</span><br><span class="line">                                <span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc),</span><br><span class="line">                                srcArgIndex,</span><br><span class="line">                                srcArgPath,</span><br><span class="line">                                argIndex));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往左一个参数</span></span><br><span class="line">                stackIndex += type.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TaintTrackingMethodVisitor.visitMethodInsn 执行出/入栈操作</span></span><br><span class="line">    <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>save</code> 方法存储分析得到的调用关系信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工厂方法存储调用关系信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> GraphCall.Factory(), discoveredCalls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-GadgetChainDiscovery"><a href="#8-GadgetChainDiscovery" class="headerlink" title="8. GadgetChainDiscovery"></a>8. GadgetChainDiscovery</h2><p>针对不同的挖掘类型，污点源信息收集的实现不同，这里关注 Java 原生序列化的污点源，分析已经在 <strong>0x02 项目结构 - gadgetinspector/javaserial - SimpleSourceDiscovery</strong> 一节中给出。</p>
<p>挖掘利用链实际就是找一条从 source 点到 sink 点的路径，前面收集的信息都是为了这里的搜索做准备。</p>
<p>这里定义了两个类分别表示利用链和利用链上的的节点（即方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用链</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GadgetChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;GadgetChainLink&gt; links;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GadgetChain</span><span class="params">(List&lt;GadgetChainLink&gt; links)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.links = links;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GadgetChain</span><span class="params">(GadgetChain gadgetChain, GadgetChainLink link)</span> </span>&#123;</span><br><span class="line">        List&lt;GadgetChainLink&gt; links = <span class="keyword">new</span> ArrayList&lt;GadgetChainLink&gt;(gadgetChain.links);</span><br><span class="line">        links.add(link);</span><br><span class="line">        <span class="keyword">this</span>.links = links;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用链（节点）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GadgetChainLink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodReference.Handle method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> taintedArgIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GadgetChainLink</span><span class="params">(MethodReference.Handle method, <span class="keyword">int</span> taintedArgIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.taintedArgIndex = taintedArgIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        GadgetChainLink that = (GadgetChainLink) o;</span><br><span class="line">        <span class="keyword">if</span> (taintedArgIndex != that.taintedArgIndex) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> method != <span class="keyword">null</span> ? method.equals(that.method) : that.method == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = method != <span class="keyword">null</span> ? method.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + taintedArgIndex;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>discover</code> 方法首先加载方法信息、继承信息，调用 <code>InheritanceDeriver.getAllMethodImplementations</code> 获取方法的重写信息，分析也已经在 <strong>0x02 项目结构</strong> 一节中给出，并保存到文件中，再加载上一步得到的调用关系信息。</p>
<p>然后加载污点源信息，将每个 source 方法作为初始节点创建一条链，加入待分析的链集合。遍历集合中的链，取出链并从尾节点（方法）开始分析，第一次分析污点源，如果其参数索引与被调方法的参数索引相同，则创建新节点并加入链的最末端，如果被调方法不是 sink 点，则加入待分析的链集合，否则加入发现的利用链集合。之后重复上面的步骤，集合中待分析的链会越来越长，直到所有链都被弹出和分析完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索可能的利用链，保存到 gadget-chains.txt 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 加载方法信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">    <span class="comment">// 加载继承信息（inheritanceMap：子类-&gt;父类集合，subClassMap：父类-&gt;子类集合）</span></span><br><span class="line">    InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">    <span class="comment">// 加载重写信息：方法-&gt;重写方法集合</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">            inheritanceMap, methodMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回目标方法的可序列化重写方法（包括目标方法本身）</span></span><br><span class="line">    <span class="keyword">final</span> ImplementationFinder implementationFinder = config.getImplementationFinder(</span><br><span class="line">            methodMap, methodImplMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存重写信息到 methodimpl.dat：（缩进）类名 方法名 描述符</span></span><br><span class="line">    <span class="keyword">try</span> (Writer writer = Files.newBufferedWriter(Paths.get(<span class="string">&quot;methodimpl.dat&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">            writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">            writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            writer.write(entry.getKey().getName());</span><br><span class="line">            writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            writer.write(entry.getKey().getDesc());</span><br><span class="line">            writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(method.getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(method.getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(method.getDesc());</span><br><span class="line">                writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载调用关系信息</span></span><br><span class="line">    Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">        MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">        <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">            Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            graphCalls.add(graphCall);</span><br><span class="line">            graphCallMap.put(caller, graphCalls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            graphCallMap.get(caller).add(graphCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经访问过的方法（节点）</span></span><br><span class="line">    Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 待分析的链</span></span><br><span class="line">    LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加载所有 sources，并将每个 source 分别作为链的第一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> Source.Factory())) &#123;</span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        GadgetChainLink srcLink = <span class="keyword">new</span> GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">        <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建仅有一个节点的链</span></span><br><span class="line">        methodsToExplore.add(<span class="keyword">new</span> GadgetChain(Arrays.asList(srcLink)));</span><br><span class="line">        <span class="comment">// 将方法标记为已访问</span></span><br><span class="line">        exploredMethods.add(srcLink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">long</span> iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 保存找到的利用链</span></span><br><span class="line">    Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// BFS 搜索 source 到 sink 的利用链</span></span><br><span class="line">    <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Iteration &quot;</span> + iteration + <span class="string">&quot;, Search space: &quot;</span> + methodsToExplore.size());</span><br><span class="line">        &#125;</span><br><span class="line">        iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        GadgetChain chain = methodsToExplore.pop(); <span class="comment">// 取出一条链</span></span><br><span class="line">        GadgetChainLink lastLink = chain.links.get(chain.links.size() - <span class="number">1</span>); <span class="comment">// 取这条链最后一个节点（方法）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前方法与其被调方法的调用关系</span></span><br><span class="line">        Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br><span class="line">        <span class="keyword">if</span> (methodCalls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                <span class="comment">// 如果当前方法的污染参数与被调方法受方法参数影响的索引不一致则跳过（即第 index 个参数）</span></span><br><span class="line">                <span class="comment">// 判断 source 时，索引指出能够被攻击者控制的参数</span></span><br><span class="line">                <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取被调方法的可序列化重写信息</span></span><br><span class="line">                Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历被调方法的重写方法</span></span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                    GadgetChainLink newLink = <span class="keyword">new</span> GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">                    <span class="comment">// 如果被调方法已经被访问过了，则跳过，减少开销</span></span><br><span class="line">                    <span class="comment">// 但是跳过会使其他链在经过此节点时断掉</span></span><br><span class="line">                    <span class="comment">// 而去掉这步可能会遇到环状问题，造成路径无限增加</span></span><br><span class="line">                    <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 新节点（被调方法）与之前的链组成新链</span></span><br><span class="line">                    GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);</span><br><span class="line">                    <span class="comment">// 判断被调方法是否为 sink 点，如果是则加入利用链集合</span></span><br><span class="line">                    <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">                        discoveredGadgets.add(newChain);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 否则将新链加入待分析的链集合，被调方法加入已访问的方法集合</span></span><br><span class="line">                        methodsToExplore.add(newChain);</span><br><span class="line">                        exploredMethods.add(newLink);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将搜索到的利用链保存到 gadget-chains.txt</span></span><br><span class="line">    <span class="keyword">try</span> (OutputStream outputStream = Files.newOutputStream(Paths.get(<span class="string">&quot;gadget-chains.txt&quot;</span>));</span><br><span class="line">         Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">            printGadgetChain(writer, chain);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Found &#123;&#125; gadget chains.&quot;</span>, discoveredGadgets.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isSink</code> 方法判断方法（和参数）是否触发预定义的 JDK 中的 sink 点，比如 <code>Runtime.exec</code> 方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预定义的 sink 点</span></span><br><span class="line"><span class="comment"> * Represents a collection of methods in the JDK that we consider to be &quot;interesting&quot;. If a gadget chain can</span></span><br><span class="line"><span class="comment"> * successfully exercise one of these, it could represent anything as mundade as causing the target to make a DNS</span></span><br><span class="line"><span class="comment"> * query to full blown RCE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method            方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> argIndex          参数索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritanceMap    继承信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Parameterize this as a configuration option</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSink</span><span class="params">(MethodReference.Handle method, <span class="keyword">int</span> argIndex, InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/io/FileInputStream&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/io/FileOutputStream&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/nio/file/Files&quot;</span>)</span><br><span class="line">            &amp;&amp; (method.getName().equals(<span class="string">&quot;newInputStream&quot;</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">&quot;newOutputStream&quot;</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">&quot;newBufferedReader&quot;</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">&quot;newBufferedWriter&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/Runtime&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exec&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (method.getClassReference().getName().equals(&quot;java/lang/Class&quot;)</span></span><br><span class="line"><span class="comment">            &amp;&amp; method.getName().equals(&quot;forName&quot;)) &#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (method.getClassReference().getName().equals(&quot;java/lang/Class&quot;)</span></span><br><span class="line"><span class="comment">            &amp;&amp; method.getName().equals(&quot;getMethod&quot;)) &#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// If we can invoke an arbitrary method, that&#x27;s probably interesting (though this doesn&#x27;t assert that we</span></span><br><span class="line">    <span class="comment">// can control its arguments). Conversely, if we can control the arguments to an invocation but not what</span></span><br><span class="line">    <span class="comment">// method is being invoked, we don&#x27;t mark that as interesting.</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/reflect/Method&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;invoke&quot;</span>) &amp;&amp; argIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/net/URLClassLoader&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;newInstance&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/System&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/Shutdown&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/Runtime&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/nio/file/Files&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;newOutputStream&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/lang/ProcessBuilder&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>) &amp;&amp; argIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;java/lang/ClassLoader&quot;</span>))</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;java/net/URL&quot;</span>) &amp;&amp; method.getName().equals(<span class="string">&quot;openStream&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some groovy-specific sinks</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;org/codehaus/groovy/runtime/InvokerHelper&quot;</span>)</span><br><span class="line">            &amp;&amp; method.getName().equals(<span class="string">&quot;invokeMethod&quot;</span>) &amp;&amp; argIndex == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;groovy/lang/MetaClass&quot;</span>))</span><br><span class="line">            &amp;&amp; Arrays.asList(<span class="string">&quot;invokeMethod&quot;</span>, <span class="string">&quot;invokeConstructor&quot;</span>, <span class="string">&quot;invokeStaticMethod&quot;</span>).contains(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This jython-specific sink effectively results in RCE</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;org/python/core/PyCode&quot;</span>) &amp;&amp; method.getName().equals(<span class="string">&quot;call&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>printGadgetChain</code> 方法用于输出利用链信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将利用链写入文件：（缩进）类名 方法名 方法描述符 传递污点的参数索引</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> writer 写入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chain  利用链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printGadgetChain</span><span class="params">(Writer writer, GadgetChain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writer.write(String.format(<span class="string">&quot;%s.%s%s (%d)%n&quot;</span>,    <span class="comment">// 污点源</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).method.getClassReference().getName(),    <span class="comment">// 类名</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).method.getName(),    <span class="comment">// 方法名</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).method.getDesc(),    <span class="comment">// 描述符</span></span><br><span class="line">            chain.links.get(<span class="number">0</span>).taintedArgIndex));   <span class="comment">// 污点参数索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chain.links.size(); i++) &#123;  <span class="comment">// 利用链</span></span><br><span class="line">        writer.write(String.format(<span class="string">&quot;  %s.%s%s (%d)%n&quot;</span>,</span><br><span class="line">                chain.links.get(i).method.getClassReference().getName(),</span><br><span class="line">                chain.links.get(i).method.getName(),</span><br><span class="line">                chain.links.get(i).method.getDesc(),</span><br><span class="line">                chain.links.get(i).taintedArgIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 结语"></a>0x04 结语</h1><p>测试时发现 Gadget Inspector 无法分析用 Java16 生成的 jar 包，听说 Java8 的兼容性比较好，尝试使用 Java8 打包，可以正常执行分析，之后再补充例子。</p>
<p>这个工具很明显无法搜索所有的利用链，为了避免路径爆炸对每个方法只访问一次，可以用最大深度限制修改；另外也有文章分析表示生成的调用关系不够全，我没有验证过；扩充的话可以从添加 source/sink 点（规则）开始，也有人扩充了对 SQL 注入（Web）的检测之类的。</p>
<p>当然还是先熟悉工具的运行原理，用简单的程序测试之后，再拿实际例子（比如 ysoserial）测，难顶🤯。</p>
<h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a>参阅</h1><ul>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45354152">Java虚拟机—栈帧、操作数栈和局部变量表</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/index.html">Java Language and Virtual Machine Specifications</a></li>
<li><a target="_blank" rel="noopener" href="https://asm.ow2.io/javadoc/org/objectweb/asm/ClassReader.html">Class ClassReader</a></li>
<li><a target="_blank" rel="noopener" href="https://asm.ow2.io/javadoc/org/objectweb/asm/ClassVisitor.html">Class ClassVisitor</a></li>
<li><a target="_blank" rel="noopener" href="https://asm.ow2.io/javadoc/org/objectweb/asm/MethodVisitor.html">Class MethodVisitor</a></li>
<li><a target="_blank" rel="noopener" href="https://asm.ow2.io/javadoc/org/objectweb/asm/FieldVisitor.html">Class FieldVisitor</a></li>
<li><a target="_blank" rel="noopener" href="https://asm.ow2.io/javadoc/org/objectweb/asm/commons/JSRInlinerAdapter.html">Class JSRInlinerAdapter</a></li>
<li><a target="_blank" rel="noopener" href="https://paper.seebug.org/1034/">Java 反序列化工具 gadgetinspector 初窥</a></li>
<li><a target="_blank" rel="noopener" href="http://galaxylab.pingan.com.cn/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E4%B9%8B-gadgetinspector/">Java反序列化漏洞辅助工具之 gadgetinspector</a></li>
<li><a target="_blank" rel="noopener" href="https://threedr3am.github.io/2020/01/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B7%A5%E5%85%B7gadgetinspector%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">java反序列化利用链自动挖掘工具gadgetinspector源码浅析</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jckling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jckling.github.io/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">https://jckling.github.io/2021/10/12/Security/Gadget Inspector 源码解析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jckling.github.io" target="_blank">Jckling's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/jckling/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/jckling/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1035234274961147" data-ad-slot="3100725659" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="https://developer.logicblox.com/wp-content/uploads/2017/12/prod-bg-panelfour.jpg" onerror="onerror=null;src='/img/jckling/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LogiQL 入门</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/"><img class="next-cover" src="https://about.twitter.com/content/dam/about-twitter/en/brand-toolkit/brand-banner-desktop.jpg.twimg.1920.jpg" onerror="onerror=null;src='/img/jckling/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python 爬取 twitter 数据</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/08/Security/%E7%99%BE%E5%BA%A6%20OpenRASP%20%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/" title="百度 OpenRASP 组成分析"><img class="cover" src="https://avatars.githubusercontent.com/u/31592614?s=200&v=4" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-08</div><div class="title">百度 OpenRASP 组成分析</div></div></a></div><div><a href="/2021/09/16/Security/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/" title="Java 反序列化漏洞入门"><img class="cover" src="https://github.com/frohoff/ysoserial/raw/master/ysoserial.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-16</div><div class="title">Java 反序列化漏洞入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/jckling/avatar.jpg" onerror="this.onerror=null;this.src='/img/jckling/avatar_404.png'" alt="avatar"/></div><div class="author-info__name">Jckling</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jckling"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎访问本站 🥳 <br/>评论需要审核，请不要重复提交~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">0x01 预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Java-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">1.1 Java 字节码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JVM"><span class="toc-text">1.2 JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ASM"><span class="toc-text">1.3 ASM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84"><span class="toc-text">代码组织架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85"><span class="toc-text">访问者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ClassVisitor"><span class="toc-text">1. ClassVisitor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MethodVisitor"><span class="toc-text">2. MethodVisitor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-FieldVisitor"><span class="toc-text">3. FieldVisitor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-text">0x02 项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gadgetinspector-data"><span class="toc-text">gadgetinspector&#x2F;data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DataLoader"><span class="toc-text">1. DataLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DataFactory"><span class="toc-text">2. DataFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ClassReference"><span class="toc-text">3. ClassReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MethodReference"><span class="toc-text">4. MethodReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-inheritanceMap"><span class="toc-text">5. inheritanceMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-InheritanceDeriver"><span class="toc-text">6. InheritanceDeriver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-GraphCall"><span class="toc-text">7. GraphCall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Source"><span class="toc-text">8. Source</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gadgetinspector"><span class="toc-text">gadgetinspector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SerializableDecider"><span class="toc-text">1. SerializableDecider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ImplementationFinder"><span class="toc-text">2. ImplementationFinder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SourceDiscovery"><span class="toc-text">3. SourceDiscovery</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gadgetinspector-config"><span class="toc-text">gadgetinspector&#x2F;config</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GIConfig"><span class="toc-text">1. GIConfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ConfigRepository"><span class="toc-text">2. ConfigRepository</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-GIConfig-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. GIConfig 接口实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gadgetinspector-javaserial"><span class="toc-text">gadgetinspector&#x2F;javaserial</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SimpleSerializableDecider"><span class="toc-text">1. SimpleSerializableDecider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SimpleImplementationFinder"><span class="toc-text">2. SimpleImplementationFinder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SimpleSourceDiscovery"><span class="toc-text">3. SimpleSourceDiscovery</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">0x03 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Util"><span class="toc-text">1. Util</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ClassResourceEnumerator"><span class="toc-text">2. ClassResourceEnumerator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-GadgetInspector"><span class="toc-text">3. GadgetInspector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MethodDiscovery"><span class="toc-text">4. MethodDiscovery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-PassthroughDiscovery"><span class="toc-text">5. PassthroughDiscovery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-TaintTrackingMethodVisitor"><span class="toc-text">6. TaintTrackingMethodVisitor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-CallGraphDiscovery"><span class="toc-text">7. CallGraphDiscovery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-GadgetChainDiscovery"><span class="toc-text">8. GadgetChainDiscovery</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-%E7%BB%93%E8%AF%AD"><span class="toc-text">0x04 结语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E9%98%85"><span class="toc-text">参阅</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/" title="Datalog 引擎 Soufflé 指南"><img src="https://i.loli.net/2021/06/14/oSn9dxfYhEHClIe.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Datalog 引擎 Soufflé 指南"/></a><div class="content"><a class="title" href="/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/" title="Datalog 引擎 Soufflé 指南">Datalog 引擎 Soufflé 指南</a><time datetime="2021-11-22T11:01:43.000Z" title="发表于 2021-11-22 19:01:43">2021-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪"><img src="https://i.loli.net/2021/06/14/bk5UlhqE4DZJfYu.png" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="CVE-2020-12691 漏洞利用相关信息追踪"/></a><div class="content"><a class="title" href="/2021/11/05/Jaeger/CVE-2020-12691%20%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%BD%E8%B8%AA/" title="CVE-2020-12691 漏洞利用相关信息追踪">CVE-2020-12691 漏洞利用相关信息追踪</a><time datetime="2021-11-05T07:25:15.000Z" title="发表于 2021-11-05 15:25:15">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/" title="LogiQL 入门"><img src="https://developer.logicblox.com/wp-content/uploads/2017/12/prod-bg-panelfour.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="LogiQL 入门"/></a><div class="content"><a class="title" href="/2021/10/26/Other/LogiQL%20%E5%85%A5%E9%97%A8/" title="LogiQL 入门">LogiQL 入门</a><time datetime="2021-10-26T08:15:05.000Z" title="发表于 2021-10-26 16:15:05">2021-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Gadget Inspector 源码解析"><img src="https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Gadget Inspector 源码解析"/></a><div class="content"><a class="title" href="/2021/10/12/Security/Gadget%20Inspector%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Gadget Inspector 源码解析">Gadget Inspector 源码解析</a><time datetime="2021-10-12T03:41:30.000Z" title="发表于 2021-10-12 11:41:30">2021-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/" title="Python 爬取 twitter 数据"><img src="https://about.twitter.com/content/dam/about-twitter/en/brand-toolkit/brand-banner-desktop.jpg.twimg.1920.jpg" onerror="this.onerror=null;this.src='/img/jckling/404.jpg'" alt="Python 爬取 twitter 数据"/></a><div class="content"><a class="title" href="/2021/10/11/Other/Python%20%E7%88%AC%E5%8F%96%20twitter%20%E6%95%B0%E6%8D%AE/" title="Python 爬取 twitter 数据">Python 爬取 twitter 数据</a><time datetime="2021-10-11T10:44:50.000Z" title="发表于 2021-10-11 18:44:50">2021-10-11</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1035234274961147" data-ad-slot="8787224657" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/06/14/2NXqsznriG8blc7.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Jckling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://blog-comments-puce.vercel.app',
      avatar: 'retro',
      avatarCDN: 'https://sdn.geekzu.org/avatar/',
      path: location.pathname,
      visitor: false,
      dark: 'html[data-theme="dark"]'
    }, {"emoji":"https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji"}))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !false) {
  if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>